% LyX 1.3 created this file.  For more info, see http://www.lyx.org/. % Do not
% edit unless you really know what you are doing.
\documentclass[brazil,ruledheader]{abnt} \usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\input{commands}
\input{symbols}

\hyphenation{FreeRTOS bi-bli-o-grá-fi-co}
\makeatletter
\usepackage{babel}

\makeatother
\begin{document}

\autor{Stephenson de S. L. Galvão}


\titulo{Modelagem Formal do Sistema Operacional de Tempo Real FreeRTOS Utilizando
o Método B}

\orientador{Prof. Dr. David Déharbe}


\comentario{Qualificação de mestrado apresentada ao programa de Pós-graduação em
Sistemas e Computação do Departamento de Informática e Matemática Aplicada da
Universidade Federal do Rio Grande do Norte, como requisito parcial para a
obtenção do grau de Mestre em Ciências da Computação.}


\instituicao{Universidade Federal do Rio Grande do Norte \par Centro de Ciências
Exatas e Da Terra \par Departamento de Informática e Matemática Aplicada \par
Programa de Pós-graduação em Sistemas e Computação}


\local{Natal - RN, Brasil}


\data{2 de dezembro de 2009}

\capa

\folhaderosto

% \begin{folhadeaprovacao} Monografia de Projeto Final de Graduação sob o título
% \textit{``\ABNTtitulodata''}, defendida por \ABNTautordata~e aprovada em
% \ABNTdatadata, em Vitória, Estado do Espírito Santo, pela banca examinadora
% constituída pelos professores: \setlength{\ABNTsignthickness}{0.4pt}

% \assinatura{Prof. Msc. Sérgio A. A. de Freitas\\ Orientador} \assinatura{Prof.
% Dr. Flávio Miguel Varejão\\ Universidade Federal do Espírito Santo}
% \assinatura{Prof. Dr. Raul Henriques Cardoso Lopes\\ Universidade Federal do
% Espírito Santo} \end{folhadeaprovacao} 

\begin{resumo}
Este trabalho apresenta uma contribuição para o esforço internacional do
\textit{Verified} \textit{Software} \textit{Repository}, o qual tem como alguns
de seus objetivos acelerar o desenvolvimento das tecnologias de verificação de
software e colecionar especificações de diversas aplicações como \textit{smart}
\textit{card}, bibliotecas padrões de desenvolvimento e sistema operacionais
embarcados. Para essa contribuição, será adotada a sugestão do pesquisador
britânico Woodcock de especificar formalmente o sistema operacional de tempo real
FreeRTOS, o qual tem como características a sua simplicidade, portabilidade e
popularidade. Com essa especificação será possível verificar o correto
funcionamento desse sistema e, conseqüentemente, garantir uma maior
confiabilidade para as aplicações desenvolvidas através dele, cooperando, com
isso, também para o desafio da construção de sistemas disponíveis, seguros,
escalonáveis e ubíquos, proposto pela Sociedade Brasileira de Computação. O
formalismo que será utilizado nessa especificação é o método B, que, devido as
suas semelhanças com as linguagens de programação imperativas e suas técnicas de
modularização e refinamento, tornou-se viável para a construção dessa
especificação. O modelo desenvolvido terá como principal foco as funcionalidades
e abstrações de hardware do sistema e o seu desenvolvimento será feito de forma
incremental. Para provar a viabilidade desse trabalho, uma especificação abstrata
foi inicialmente desenvolvida, na qual algumas propriedades do sistema puderam
ser tratadas. Ao final, pretende-se com a especificação do FreeRTOS, além de
validar os requisitos desse sistema, criar uma documentação formal do mesmo, a
qual poderá ser usada como entrada para a geração de testes, no nível de código,
para o sistema especificado. Em suma, a especificação do FreeRTOS auxiliará na
resolução dos desafios anteriormente citados, servindo desse modo como uma
contribuição para a sociedade de computação, em especial a sociedade de métodos
formais.
\end{resumo}
% seu resumo. \end{resumo} \begin{abstract} Write here the English version of
% your {}``Resumo''. \end{abstract}

% \chapter*{Dedicatória}

% Dedico este trabalho a ...


% \chapter*{Agradecimentos}

% Agradeço a ...

\tableofcontents{}\listoffigures



\listoftables


\chapter{Introdução\label{cap:introducao}}

A Ciência da Computação é uma área relativamente jovem, mas com grande impacto na
sociedade atual. Através dela, é possível acelerar-se anos de desenvolvimento e
pesquisas das demais áreas da ciência, como ocorreu com o mapeamento do genoma
humano. Devido a isso, em \cite{USAReport} ela chegou a ser citada como um dos
pilares da ciência, considerada também como um fator crucial para a economia,
tecnologia e desenvolvimento de um pais.

Ciente dessa importância, pesquisadores de todo mundo tem buscado reunir esforços
em torno de objetivos comuns, definindo diretrizes a serem seguidas pela
computação ao longo dos próximos anos. Essas diretrizes são estabelecidas visando
suprir as necessidades mais relevantes da sociedade atual, as quais, em geral,
são obstáculos ainda não vencidos pela computação, e, por isso, denominados como
``Grandes Desafios da Computação''.

Seguindo esse contexto, a Sociedade Brasileira de Computação (SBC) listou, em
\cite{GDSBC}, alguns desses principais desafios, dentre os quais está o desafio
de \textit{desenvolvimento tecnológico de qualidade: sistemas disponíveis,
corretos, seguros, escaláveis, persistentes e ubíquos}. Esse desafio visa a
construção de sistemas disponíveis, sem falhas, previsíveis, escaláveis e
seguros. Qualidades que, devido à crescente utilização dos sistemas
computacionais, tornaram-se cada vez mais necessárias.

Uma das inspirações para o desafio acima foram os sistema críticos. Nesses
sistemas, é de suma importância o seu correto funcionamento, pois a sua principal
característica é a criticidade das suas operações, nas quais uma falha pode ter
conseqüências catastróficas. E, devido a isso, a grande necessidade do
desenvolvimento de técnicas para a construção de sistemas fidedignos.

Uma abordagem utilizada com sucesso para a criação de sistemas ``corretos'' tem
sido os métodos formais. Métodos formais são técnicas matemáticas usadas para
desenvolver sistema de \textit{software} e \textit{hardware}. O rigor matemático
dessas técnicas permite ao usuário analisar e verificar seus modelos em todas as
partes do seu ciclo de vida: requisitos, especificação, modelagem, implementação,
teste e manutenção. Atualmente, esses métodos têm sido utilizados, de forma
auspiciosa, pela indústria para a construção de pequenas, mas significantes
aplicações \cite{Jim09}.

Entretanto, a comunidade de métodos formais também possui seus desafios, entre
eles está o projeto do ``Software Verificado''\cite{bicarregui06}. O Software
Verificado é um conjunto de teorias, ferramentas e experiências usadas para
verificação e validação de softwares. Ao final desse projeto, pretende-se criar
um verificador de softwares que garanta o comportamento fidedigno do sistema
analisado. Outra atividade associada a esse projeto é a criação de estudos de
caso a serem utilizados pelas abordagens proposta. Entre tais estudos de caso, um
dos mais interessantes e proveitosos é sem dúvida a especificação formal do
sistema operacional de tempo real FreeRTOS \cite{Hoare05}\cite{Jim09}.

O FreeRTOS \cite{Barry09} é um estratégico e importante estudo de caso. Isso,
devido a sua larga utilização, simplicidade e portabilidades. Atualmente, o seu
repositório possui uma taxa maior que 6.000 downloads por mês; o seu núcleo é
acessível, aberto e pequeno, são aproximadamente 2.200 linhas de código, com
funções comuns a maioria dos sistemas modernos e suportadas oficialmente por 17
arquiteturas de microcontroladores diferentes. Devido a essas qualidades, a
especificação desse sistema seria uma grande contribuição, principalmente para
o desenvolvimento da computação, em especial a comunidade de métodos formais.

Entre as possíveis abordagens formais para a especificação do FreeRTOS está o
método B \cite{schneider06}\cite{abrial96}. O método B é uma abordagem de
especificação, validação e construção de sistemas. Através dele é possível
modularizar e refinar uma especificação até um nível algoritmo, passível de
transformação para as linguagens de programação imperativas. Além disso, ele é
apoiado por um pacote de ferramentas que suportam todos os seus ciclos de
desenvolvimento, o que tornou essa abordagem uma forte candidata para a
especificação do FreeRTOS.

Em suma, especificação formal do FreeRTOS através do método B, além ser um
esforço para a resolução dos desafios apresentados, é uma grande contribuição
para a computação, principalmente à comunidade de métodos formais. Tal
especificação poderá ainda agregar valor ao sistema, servindo como documentação e
entrada para técnicas de teste de sistemas construídos utilizando o Sistema
Operacional em questão \cite{jaffuel07}.

Prosseguindo nesta introdução, tem-se, na seção~\ref{sec:objetivo}, o objetivo a
ser atingido com esse trabalho, na seção~\ref{sec:metodologia}, a metodologia
para atingir tal objetivo, e, na seção~\ref{sec:trabalhos}, os trabalhos
relacionados a essa proposta. Na continuação do trabalho, as fundamentações
teóricas referentes ao FreeRTOS e ao Método B são apresentada, respectivamente,
nos capítulos~\ref{cap:freertos} e~\ref{cap:metodob}. Em seguida, a parte do
trabalho já realizada é demonstrada no capítulo~\ref{cap:primeiros_passos} e a
proposta, junto com as atividades e o cronograma de trabalho, são exibidos no
capítulo~\ref{cap:proposta}. Por último, tem-se a conclusão no
capítulo~\ref{cap:conclusao}.

\section{Objetivo}\label{sec:objetivo}
O objetivo desse trabalho é, através da especificação do FreeRTOS em B,
contribuir para os desafios do software verificado e da construção de software
fidedigno. A especificação desenvolvida modelará funcionalmente as
funcionalidades que compõem o FreeRTOS, sendo a mesma capaz de analisar
propriedades estáticas do FreeRTOS e validar algumas de seus principais
requisitos.

\section{Metodologia}\label{sec:metodologia}
A metodologia de desenvolvimento desse trabalho pode ser sucintamente resumida
pelos itens abaixo, os quais serão comentados nos parágrafos seguintes:

\begin{itemize}
  \item Estudo do método B;
  \item Levantamento bibliográfico sobre FreeRTOS;
  \item Estudo do código fonte do FreeRTOS;
  \item Elaboração de um plano para a modelagem funcional do FreeRTOS;
  \item Modelagem funcional do FreeRTOS considerando apenas as entidades Tarefa
  e Fila de Mensagens
  \item Refinamento da modelagem desenvolvida para adicionar a característica
  de prioridade;
  \item Refinamento da modelagem para adicionar a característica de tamanho da
  fila;
  \item Acrescentar as demais entidades do FreeRTOS à especificação; e
  \item Refinar especificação para tratar demais requisitos do sistema.
\end{itemize}

A elaboração desse trabalho iniciou-se com o estudo do método B. Esse estudo
ocorreu principalmente através do desenvolvimento de uma especificação do
microcontrolador $8051$ (melhor detalhada em \cite{ermac}) e com colaborações
para os trabalhos \cite{dantas08} e \cite{dantas08-2}.

O estudo sobre o FreeRTOS foi divido em duas partes principais: o levantamento
bibliográfico sobre o sistema e a analise do código fonte do mesmo. Essas
partes serão detalhadas nos parágrafos seguintes.

No levantamento bibliográfico, a documentação disponível sobre o sistema foi
examinada. Assim, os principais requisitos, funcionalidade e características do
FreeRTOS poderam ser identificados e classificados de acordo com sua importância.
Esse trabalho serviu como base para a análise do código fonte e para a
elaboração do plano de desenvolvimento de uma modelagem funcional do sistema.

Durante a análise do código fonte, foi possível identificar a arquitetura do
sistema e como suas principais abstrações de hardware e funcionalidades são
implementados. Nessa análise, percebeu-se que muita vezes o sistema possui
detalhes em níveis de assembler, o que segundo Dantas, em \cite{dantas08-2},
também podem ser tratados utilizando o método B.

Através da análise do FreeRTOS descobriu-se que, apesar dele ser um sistema
simples e pequeno, a sua modelagem é um trabalho que levará muito tempo e
esforço. Assim, como primeiro passo para especificação do sistema, foi
desenvolvido um modelo funcional inicial, bastante abstrato, do FreeRTOS.
Entretanto, para uma melhor elaboração e aproveitamento desse modelo, antes da
sua criação, foi elaborado um plano para identificar quais elementos e
funcionalidades que devem fazer parte dessa modelagem funcional inicial.

No plano de modelagem, determinou-se que, para essa modelagem inicial, devido a
sua importância, apenas as entidades tarefas e fila de mensagens serão
especificadas, sendo as demais entidades (semáforo, co-rotina e mutex) tratadas
nas próximas etapas da especificação. Após essa definição, o plano foi divido em
módulos incrementais, os quais foram compostos pelas funcionalidades e
representações de cada entidade, sendo cada módulo uma etapa da modelagem
funcional.

Através da modelagem funcional do sistema, utilizando-se o mecanismo
composicional do método B, foi possível definir um esboço da arquitetura da
especificação. Nela, o sistema foi divido inicialmente em sete módulos,
organizados de acordo com a figura~\ref{fig:arquitetura}. Os módulos mais abaixo
fornecem operações e implementam elementos para os módulos superiores realizarem
suas funções, sendo o módulo $\mathit{FreeRTOS}$ responsável por especificar as
funcionalidades do sistema.

Entretanto, por tratar-se de um modelo funcional, a modelagem inicial abstraiu
muitas características importantes do FreeRTOS, entre elas a característica de
prioridade de uma tarefa. A adição dessa característica ao modelo foi feita na
etapa de ``Refinamento da modelagem desenvolvida para adicionar a característica
de prioridade'' utilizando-se o mecanismo de refinamento do método B, no qual uma
especificação abstrata é refinada para um modelo mais concreto.

Ao total, nessa especificação inicial foram criadas 1.974 linhas, as quais
geraram 538 obrigações de prova (seção~\ref{subsec:obrigacao_de_prova}). Entre
essas obrigações de prova, somente 49 necessitaram da interação humana para sua
resolução, sendo as demais provadas automaticamente pela ferramenta adotada pelo
projeto. Como fruto dessa etapa, foi publicado o seguinte trabalho
\cite{david09}.

Dando continuidade na metodologia do trabalho, as próximas etapas são: refinar a
modelagem adicionando a característica tamanho da fila; implementar as demais
entidades do FreeRTOS; e refinar a modelagem para abranger os requisitos do
sistema ainda não tratados.

A etapa de refinar a modelagem adicionando a característica tamanho da fila foi
desenvolvida com a ajuda dos alunos da disciplina de Métodos Formais do Período
2009.1 da Universidade Federal do Rio Grande do Norte. Nessa etapa, foram criados
módulos separados da modelagem desenvolvida até aqui, restando apenas adaptar
esses módulos à especificação do sistema.

Após o refinamento das etapas anteriores, a especificação atingirá um nível
razoavelmente maduro, restando ainda acrescentar à especificação as entidades
semáforo, mutex e co-rotina. Essa etapa consistirá em acrescentar essas entidades
de forma abstrata, tratando apenas algumas das suas principais características.
  
Com a especificação dos elementos do sistema, resta ao modelo, somente adquirir
níveis de abstração capazes de abranger os requisitos do sistema ainda
não tratados. Com isso, as próximas etapas da modelagem serão realizadas através de
refinamentos e refatoramento da modelagem, até que as características do FreeRTOS
sejam totalmente especificadas.

Ao final da especificação, pretende-se atingir uma modelagem concreta do
FreeRTOS, na qual funcionalidades do sistema possam ser testadas e validadas.
Além disso, a especificação aqui desenvolvida servirá como material de apoio ao
FreeRTOS, gerando uma documentação do sistema no ponto de vista formal.

\section{Trabalhos Relacionados}\label{sec:trabalhos}

Alguns trabalhos relacionados ao objetivo dessa qualificação são:
\cite{kleine09}, \cite{sola05} e \cite{Craig06}. No primeiro, é demonstrada,
utilizando o formalismo CSP \cite{hoare04}, uma técnica de análise da
concorrência entre processos de uma aplicação. Em \cite{sola05}, uma modelagem
bastante simples do microkernel L4 é feita em Event B  \cite{abrial05}. E por
último, no trabalho \cite{Craig06}, Craig demonstra uma modelagem em Z
\cite{Jim95} de um sistema operacional clássico dividido em camadas. A seguir,
tem-se uma explicação mais detalhada de cada um desses trabalhos.

No trabalho desenvolvido por Kleine em \cite{kleine09}, a validação de uma
aplicação concorrente é feita através da transformação da linguagem intermediária
do compilador LLVM para uma modelagem de baixo nível em CSP. Esse modelo é
dividido em três partes: Aplicação, onde o comportamento dos processos do sistema
é descritos; Domínio, onde os aspectos comuns do domínio da aplicação são
especificados; e Plataforma, onde os detalhes da plataforma utilizada são
formalizados. Um fator positivo dessa divisão é que essa especificação pode
disponibilizar diversas visões do sistema e as partes de domínio e plataforma
podem ser parametrizáveis, podendo assim ser reutilizadas em várias aplicações.

Após a criação do modelo CSP, este é analisada através das ferramentas de
verificação para CSP, como FDR2 e ProB, que verificam situações de
\textit{deadlock} e condições de corrida do sistema, podendo assim garantir o
correto funcionamento da concorrência no sistema. Além disso, com a geração do
modelo CSP, as atividades implementadas no sistema são abstraídas para um ponto
de vista mais prático e abstrato, permitindo assim uma melhor análise do sistema.

No trabalho de Solá, \cite{sola05}, o formalismo utilizado, Event B, é muito
parecido com o método B. Ele também é formado por estados, que devem ser
mantidos, e operações, denominadas de eventos, responsáveis por alterar esses
estados. Assim, na especificação do L4, as abstrações de hardware do sistema,
como \textit{threads} e comunicação IPC, foram especificadas através de estados e
as chamadas da API do sistema através de eventos.
 
O principal objetivo de Solá nesse trabalho foi especificar a API do L4. Com
isso, devido a API preocupar-se primordialmente com as chamadas ao sistema, o
guia para o desenvolvimento dessa especificação foram as chamadas ao sistema.
Assim as abstrações de hardware e suas propriedades foram colocadas de acordo com
as necessidades surgidas na especificação das atividades das chamadas ao sistema,
o que proporcionou uma formalização bastante abstrata desses elementos, mas
completa em relação às interações do sistema através de chamadas. Com a
especificação do L4 foi possível: validar propriedades estáticas do sistema;
descrever mais precisamente o mecanismo do L4; e obter uma documentação mais
extensiva da sua API.

Em seu trabalho, \cite{Craig06}, Craig começa afirmando que o parte mais
importante de uma aplicação é o sistema operacional, que gerencia os recursos
usados pela aplicação. Após isso, ele certifica que os métodos formais há tempos
estão relacionados com os sistemas operacionais e que, na maioria das vezes,
foram utilizados para especificar as operações de fila dos sistemas. De posse
dessas afirmações, Craig defende a especificação formal como uma prática de suma
importância a ser realizada antes da codificação, pois através dela o sistema
pode ser analisado de forma abstrata, como uma entidade matemática. Assim,
propriedades importantes do sistema podem ser provadas antes mesmo de sua
codificação, o que diminui os riscos do projeto.

Continuando o trabalho, Craig demonstra a divisão em camadas de um sistema
operacional convencional, sendo essas: a camada das primitivas de
 \textit{hardware}, localizada assim do \textit{hardware}; a camada responsável
 pelo gerenciamento de disco e interrupções de \textit{hardware} (Relógio do
 sistema); a camada de gerenciamentos de arquivos e controle de interfaces; e a
 camada de chamadas do sistema utilizada pelas aplicações. Essa divisão
 proporciona uma modelagem incremental de um SO, na qual os elementos mais
 abstratos e importantes são tratados inicialmente.


\newpage

\chapter{FreeRTOS}\label{cap:freertos}

O FreeRTOS é um Sistema Operacional de Tempo Real - SOTR enxuto, simples e de
fácil uso. O seu código fonte, feito em \textit{C} e com partes em
\textit{assembly}, é aberto e possui um pouco mais de 2.200 linhas de código, que
são essencialmente distribuídas em quatro arquivos: \textit{task.c},
\textit{queue.c}, \textit{croutine.c} e \textit{list.c}. Outra característica
marcante desse sistema está na sua portabilidade, sendo o mesmo oficialmente
portável para 17 arquiteturas mono-processadores diferentes, entre elas a PIC,
ARM e Zilog Z80, as quais são amplamente difundidas em produtos comerciais
através de sistemas computacionais embutidos \cite{Barry09}.

Como a maioria dos sistemas operacionais, o FreeRTOS provê, para os seus
usuários, acesso facilitado aos recursos de \textit{hardware}, agilizando com
isso o desenvolvimento de sistemas de tempo real. Desse modo, ele funciona como
na figura \ref{fig:rtos}, uma camada de abstração, localizada entre a
aplicação e o hardware, que tem o papel de esconder dos desenvolvedores de
aplicações detalhes do hardware, no qual a aplicações será utilizada\cite{Kalinsky03}.


\begin{figure}[!h]
\centering
\includegraphics[scale=0.8]{../fig/rtos_pt.jpg}
\caption{Camada abstrata proporcionada pelo FreeRTOS \cite{Kalinsky03}}
\label{fig:rtos}
\end{figure}

Para prover tal abstração, o FreeRTOS possui um conjunto de bibliotecas de tipos
e funções que devem ser linkeditadas\footnote{Processo que liga o código da
aplicação ao código das funcionalidades de outras bibliotecas utilizada por ela.}
com o código da aplicação a ser desenvolvida. Juntas, essas bibliotecas fornecem
aos desenvolvedores serviços como gerenciamento de tarefa, comunicação e
sincronização entre tarefas, gerenciamento de memória e controle dos dispositivos
de entrada e saída\cite{Barry09}.

Devido a sua portabilidade e ao fato de trabalhar em ambientes com limitações de
hardware, o FreeRTOS pode ser pré-configurado antes da sua execução. Essa
configuração é feita por uma biblioteca de configuração, que, através de
atributos, armazena as definições de configuração do usuário. Com isso, as aplicações
desenvolvidas com o FreeRTOS podem ser mais enxutas e moldadas, provendo uma
melhor utilização dos recursos de hardware.

Nas seções a seguir, será explicado, em maiores detalhes, os principais serviços
providos pelo FreeRTOS, assim como as bibliotecas e funções que os
disponibilizam.


\section{Gerenciamento de Tarefas e Co-Rotinas}

\subsection{Tarefa}
\label{sec:tarefa}

Para entender como funciona o gerenciamento de tarefas do FreeRTOS, é necessário
primeiramente entender-se o conceito de tarefa. Tarefa é uma unidade básica de
execução que compõe os sistemas, os quais, para realizar suas atividades,
geralmente possuem várias tarefas com diferentes obrigações\cite{Barry09}. Para o
FreeRTOS, as principais características de uma tarefa são:

\begin{description}
  \item{\textbf{Estado}}: Demonstra a atual situação da tarefa;
  \item{\textbf{Prioridade}}: Indica a importância da tarefa para o sistema. Uma
  prioridade varia de zero até uma constante máxima pré configurada pelo
  projetista;
  \item{\textbf{Pilha de execução}}: Local onde uma tarefa armazena informações
  necessárias para a sua execução;
  \item{\textbf{Contexto Próprio}}: Capacidade de uma tarefa armazenar o
  ambiente de execução quando suas atividades são suspensas; e
  \item{\textbf{Tempo de bloqueio}}: Tempo que uma tarefa pode permanecer
  bloqueada a espera de algum evento.
\end{description}

Em um sistema, uma tarefa pode assumir vários estados, que variam de acordo com
a sua situação. O FreeRTOS disponibiliza quatro tipos de estados
diferentes para uma tarefa, sendo eles:

\begin{description}
  \item{ \textbf{EM EXECUÇÃO}:} Indica que a tarefa está em execução;
  \item{ \textbf{PRONTA}:} Indica que a tarefa está pronta para entrar em
  execução, mas não está sendo executada;
  \item{ \textbf{BLOQUEADA}:} Indica que a tarefa está esperando por algum
  evento para continuar a sua execução; e
  \item{ \textbf{SUSPENSA}:} Indica que a tarefa foi suspensa pelo gerenciador
  de tarefas através da chamada de uma funcionalidade usada para controlar as
  tarefas.
\end{description}

No FreeRTOS, uma tarefa só possuir um estado em um determinado instante. Assim,
as alterações de estado de uma tarefa funcionam como demonstra o diagrama da
figura~\ref{fig:task_states}. Nela, uma tarefa com o estado EM EXECUÇÃO pode
assumir os estados PRONTA, BLOQUEADA ou SUSPENSA. Uma tarefa com o estado PRONTA
pode ser suspensa ou entrar em execução, e as tarefas com o estado BLOQUEADA ou
SUSPENSA só podem ir para o estado PRONTA.

Um fator preocupante, observado nas possíveis troca de estados de uma tarefa,
ocorre quando uma tarefa bloqueada é suspensa e logo em seguida retornada. Assim
o tempo de bloqueio de uma tarefa pode ser ``enganado'' e a tarefa pode retornar
antes do tempo indicado para o desbloqueio.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.6]{../fig/task_states_pt.jpg}
\caption{Diagrama de estados de uma tarefa no FreeRTOS \cite{Barry09}}
\label{fig:task_states}
\end{figure}

Por fim, vale enfatizar que, por tratar-se de um sistema operacional para
arquiteturas mono-processadores, o FreeRTOS não permite que mais de uma tarefa
seja executada ao mesmo tempo. Assim, em um determinado instante, apenas uma das
tarefas com estado PRONTA pode assumir o processador e entrar no estado EM
EXECUÇÃO. Com isso, para decidir qual tarefa entrará em execução, o FreeRTOS
possui um mecanismo denominado escalonador, o qual será detalhado na
seção~\ref{sec:escalonador}.


\subsubsection{Tarefa Ociosa}
\label{subsubsection:tarefa_ociosa}

No FreeRTOS existe uma tarefa especial, denominada Tarefa Ociosa, que é
executada, como o próprio nome já diz, quando o processador encontra-se ocioso,
ou seja, quando nenhuma tarefa estiver em execução. Essa tarefa tem como
principal funcionalidade liberar áreas de memórias que não estão sendo mais
utilizadas pelo sistema. Por exemplo, quando uma aplicação cria uma nova tarefa,
uma área da memória é reservada a ela, em seguida, quando essa tarefa é
excluída do sistema, a memória destinada a ela continua ocupada, sendo esta liberada
somente quando a tarefa ociosa entra em execução. A tarefa ociosa deve possuir
prioridade menor que as demais tarefas do sistema e, por isso, ela só é executada
quando nenhuma tarefa estiver em execução.


\subsection{Co-rotinas}
\label{sec:corotinas}
Outro conceito importante suportado pelo FreeRTOS é o conceito de co-rotina.
Co-rotinas, assim como as tarefas, são unidades de execução independentes que
formam uma aplicação. Elas também são formadas por uma prioridade e um estado
responsáveis, respectivamente, pela importância da co-rotina no sistema e pela
situação da mesma. Para o FreeRTOS, o suporte às co-rotinas é opcional e
pré-configurável antes da execução, em tempo de compilação \cite{Barry09}.

Uma diferença crucial entre co-rotinas e tarefas está no contexto do
ambiente de execução. Co-rotinas não possuem contexto de execução próprio.
Consequentemente, sua pilha de execução é compartilhada com as demais co-rotinas
do sistema. Diferente das tarefas, que possuem uma pilha própria devido ao
armazenamento do seu contexto de execução.

Devido ao fato de co-rotinas compartilharem a mesma pilha de execução, a
utilização dessa entidade deve ser feita de forma cuidadosa, pois uma informação
armazenada por uma co-rotina pode ser alterada por outra. Por exemplo, a
co-rotina \textit{A} armazena na pilha de execução o valor dois, outra co-rotina,
ao entrar em execução, altera o valor armazenado pela co-rotina \textit{A}.
Assim, quando a co-rotina \textit{A} for ler novamente o valor armazenado, este
poderá não ser mais dois.

Os estados possíveis para uma co-rotina são:

\begin{description}
  \item{\textbf{EM EXECUÇÃO}:} Indica que uma co-rotina está em execução;
  \item{\textbf{PRONTA}:} Indica que uma co-rotina está pronta para ser
  executada, mas não está em execução; e
  \item{\textbf{BLOQUEADA}:} Indica que a co-rotina está bloqueada esperando por
  algum evento para continuar a sua execução. 
\end{description}

Como as tarefas, co-rotinas possuem somente um estado em um determinado instante.
Assim, as transições entre os estados de uma co-rotina ocorrem como demonstra a
figura~\ref{fig:croutine_states}. Nela, uma co-rotina em execução pode ir tanto
para o estado PRONTA como para o estado BLOQUEADA. Uma co-rotina de estado
BLOQUEADA só pode ir para o estado PRONTA e uma co-rotina de estado PRONTA só
pode ir para o estado EM EXECUÇÃO.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.6]{../fig/croutine_states_pt.jpg}
\caption{Grafo de estados de uma co-rotina \cite{Barry09}}
\label{fig:croutine_states}
\end{figure}

Assim como nas tarefas, a decisão de qual co-rotina irá entrar em execução é
feita pelo escalonador, através da chamada à uma funcionalidade específica, esse
processo será melhor explicado na seção \ref{sec:escalonador}.


\subsection{Escalonador de Tarefas}
\label{sec:escalonador}

O escalonador é a parte mais importante de um sistema. Ele é quem decide qual
unidade de execução\footnote{Aqui o termo ``unidade de execução'', as vezes
citado apenas como unidade, refere-se a todas as tarefas(seção~\ref{sec:tarefa})
e co-rotinas (seção~\ref{sec:corotinas}) do sistema} irá entrar execução. Além
disso, é ele que faz a troca entre a unidade em execução e a nova unidade que irá
entrar em execução. No FreeRTOS, o escalonador pode funcionar de três modos
diferentes, configuráveis em tempo de compilação:

\begin{itemize}
  \item \textbf{Preemptivo}: Quando o escalonador interrompe a unidade em
  execução, alterando assim o seu estado, e ocupa o processador com outra
  unidade;
  \item \textbf{Cooperativo}: Quando o escalonador não tem permissão de
  interromper a unidade em execução. Assim a interrupção da execução da unidade
  em processamento e a chamada ao escalonador para decidir quem irá entra em
  execução devem ser implementadas pelo projetista; e
  \item \textbf{Híbrido}:  Quando o escalonador pode comportar-se tanto como
  preemptivo como cooperativo.
\end{itemize}

Para as tarefas, o escalonador funciona de forma preemptiva, sendo que a decisão
de qual tarefa deve entrar em execução é baseada na prioridade e adota a seguinte
política: a tarefa em execução deve ter prioridade maior ou igual à tarefa de
maior prioridade de estado PRONTA. Assim sempre que uma tarefa, com prioridade
maior que a tarefa em execução, entrar no estado PRONTA, ela deve imediatamente
entrar em execução. Um exemplo claro da política preemptiva pode ser visto na
figura \ref{fig:scheduler}, onde três tarefas, em ordem crescente de prioridade,
disputam a execução do processador.

%SG->DD
%Queria adcionar o texto à figura. É melhor que fazer isso pelo latex ou fazer
% quando for criar uma figura em português

\begin{figure}[!h]
\centering
\includegraphics[scale=0.4]{../fig/scheduler_pt.jpg}
\small{
\begin{enumerate}
  \item Tarefa 1 entra no estado PRONTA, como não há nenhuma tarefa em execução
  esta assume controle do processador entrando em execução.
  \item Tarefa 2 entra no estado PRONTA, como esta tem prioridade maior do que
  a tarefa 1  ela entra em execução passando a tarefa 1 para o estado PRONTA.
  \item Tarefa 3 entra no estado PRONTA, como está tem prioridade maior do que
  a tarefa 2  ela entra em execução passando a tarefa 2 para o estado PRONTA.
  \item Tarefa 3 encerra a sua execução, sendo a tarefa 2 escolhida para entrar
  em execução por ser a tarefa de maior prioridade no estado PRONTA.
  \item Tarefa 2 encerra a sua execução e o funcionamento do escalonador é
  passado para a tarefa 1.
\end{enumerate}
}



\caption{Funcionamento de um escalonador preemptivo baseado na prioridade
\cite{Li03}}
\label{fig:scheduler}
\end{figure}

Um fato a adicionar sobre a política de funcionamento do escalonador é que,
quando duas ou mais tarefas de estado PRONTA tiverem prioridades iguais e maiores
que as demais tarefas do mesmo estado, o tempo de execução será divido entre
essas tarefas. Assim, ao possuir duas tarefas de prioridades máximas e estado
PRONTA, essas tarefas irão permutar entre si a execução do processador.

Para as co-rotinas, o escalonador funciona de forma cooperativa e baseada na
prioridade. Assim, a co-rotina em execução é quem decide o momento da sua
interrupção e, em seguida, o sistema deve chamar o escalonador através de uma
funcionalidade específica para decidir qual será a próxima co-rotina que irá
entrar em execução. A escolha da próxima co-rotina a ser executada também é
baseada na maior prioridade, assim como ocorre com as tarefas. Um exemplo do
funcionamento do escalonador pode ser visto na
seção~\ref{subsec:corotina_utilizacao}.


\subsection{Bibliotecas}
\label{subsection:api_tarefas_corotinas}

Para disponibilizar as características discutidas nesta seção, o FreeRTOS contém
um conjunto de bibliotecas de tipos e funções, as quais estão classificadas da
seguinte forma: criação de tarefas, controle de tarefas, utilidades de tarefas,
controle do kernel e co-rotinas. A seguir tem-se em detalhes a descrição de cada
uma dessas bibliotecas junto com os tipos e funcionalidades que as compõem.

\subsubsection{Criação de Tarefas}
\label{sec:criacao_tarefa_api}

Essa biblioteca é responsável pela entidade tarefa e sua criação. Nela, estão
presentes um tipo, responsável por representar uma tarefa do sistema, e duas
funcionalidades, uma para a criação e outra para a remoção de tarefas do sistema.
Em seguida, tem-se o tipo e as funcionalidades que compõem a biblioteca em
questão.


\begin{itemize}
  
  \item \textbf{xTaskHandle}: Tipo pelo qual uma tarefa e referenciada. Por
  exemplo, quando uma tarefa é criada através do método \textit{xTaskCreate},
  este retorna uma referência para nova tarefa através do tipo
  \textit{xTaskHandle}.
  \item \textbf{xTaskCreate}: Funcionalidade usada para criar uma nova tarefa
  para o sistema.
  \item \textbf{vTaskDelete}: Funcionalidade usada para remover uma tarefa do
  sistema\footnote{A memória alocada pela tarefa será liberada somente
  quando a tarefa ociosa entrar em
  execução(seção~\ref{subsubsection:tarefa_ociosa})}.
  
\end{itemize}

\subsubsection{Controle de tarefas}
\label{sec:controle_tarefa_api}
A biblioteca de controle de tarefas realiza operações sobre as tarefas do
sistema. Ela disponibiliza funcionalidades capazes de bloquear, suspender, e
retornar uma tarefa do sistema, informar e alterar a prioridade de uma tarefa no
sistema. A lista das principais funcionalidades presentes nessa biblioteca pode
ser vista a seguir:

\begin{itemize}
  \item \textbf{vTaskDelay}: Funcionalidade usada para bloquear uma tarefa por
  um determinado tempo. Nessa funcionalidade, para calcular o tempo que a tarefa
  deve permanecer bloqueada, será levado em consideração o instante da chamada à
  funcionalidade. Devido a isso, essa funcionalidade não é recomendada para a
  criação de tarefas cíclicas, pois o instante em que ela é chamada pode variar
  a cada execução da tarefa, por causa das interrupções que uma tarefa pode
  sofrer.
  
  \item \textbf{vTaskDelayUntil}: Funcionalidade usada para bloquear uma tarefa
  por um determinado tempo. Essa funcionalidade, diferente da
  \textit{vTaskDelay}, calcula o tempo que a tarefa deve permanecer bloqueada
  com base no instante do último desbloqueio da tarefa. Assim, se ocorrer uma
  interrupção no momento da chamada à funcionalidade, o instante que a tarefa
  foi desbloqueada não ira mudar. Com isso, esse método torna-se recomendável para a
  criação de tarefas cíclicas.
  
  \item \textbf{uxTaskPriorityGet}: Funcionalidade usada para informar a
  prioridade de uma determinada tarefa.
  \item \textbf{vTaskPrioritySet}: Funcionalidade usada para mudar a prioridade
  de uma determinada tarefa.
  \item \textbf{vTaskSuspend}: Funcionalidade usada para colocar uma
  determinda tarefa no estado SUSPENSA.
  \item \textbf{vTaskResume}: Funcionalidade usada para colocar uma
  determinada tarefa suspensa no estado PRONTA.
  \item \textbf{xTaskResumeFromISR} - Funcionalidade usada pelo tratamento
  de interrupções do sistema. Ela coloca uma determinada tarefa suspensa para o
  estado PRONTA.
\end{itemize}

\subsubsection{Utilitários de tarefas}
\label{sec:utilitarios_tarefa_api}
Através dessa biblioteca o FreeRTOS disponibiliza, para o usuário, informações
importantes a respeito das tarefas e do escalonador de tarefas. Nela, estão
presentes funcionalidades capazes de retornar uma referência para a atual tarefa
em execução, retornar o tempo de funcionamento e o estado do escalonador e
retornar o número de tarefas que estão sendo gerenciadas pelo sistema. Uma lista
das principais funcionalidades dessa biblioteca é encontrada a seguir:

\begin{itemize}
  \item \textbf{xTaskGetCurrentTaskHandle}: Funcionalidade que retornar
  uma referência para a atual tarefa em execução.
  \item \textbf{uxTaskGetStackHighWaterMark}: Funcionalidade que retona a
  quantidade de espaço restante na pilha de uma tarefa.
  \item \textbf{xTaskGetTickCount}: Funcionalidade que retorna o tempo decorrido
  desde a inicialização do escalonador.
  \item \textbf{xTaskGetSchedulerState}: Funcionaliade que retornar o estado do
  escalonador.
  \item \textbf{uxTaskGetNumberOfTasks}: Funcionalidade que retorna o número de
  tarefas do sistema.
  \item \textbf{TaskSetApplicationTag}: Funcionalidade usada para associa uma
  'tag' a uma tarefa. Essa tag será utilizada principalmente pelas
  funcionalidades de rastreamento do sistema. Entretanto, é possível usar essa
  'tag' para associar uma função gancho a uma tarefa. Essa função é executada
  através da chamada à funcionalidade \textit{TaskCallApplicationTaskHook},
  informando a tarefa associada.
  \item \textbf{TaskCallApplicationTaskHook}: Funcionalidade usada para chamar a
  função gancho de uma determinada tarefa.
\end{itemize}

\subsubsection{Controle do Escalonador}
\label{sec:controle_escalonador_api}
Nessa biblioteca estão presentes as funcionalidades responsáveis por controlar
as atividades do escalonador de tarefas. Nela, encontram-se as funcionalidades
que iniciam, finalizam, suspendem e reativam as atividades do escalonador. As
principais funcionalidades presente nessa biblioteca são:

\begin{itemize}
\item \textbf{vTaskStartScheduler}: Funcionalidade usada para iniciar as
atividades do escalonador, ou seja inicializar o sistema.
\item \textbf{vTaskEndScheduler}: Funcionalidade usada para encerrar as
atividades do escalonador, ou seja finalizar o sistema.
\item \textbf{vTaskSuspendAll}: Funcionalidade usada para suspender as atividades
do escalonador.
\item \textbf{xTaskResumeAll}: Funcionalidade usada reativar o escalonador
quando o mesmo está suspenso.
\item \textbf{taskYIELD}: Funcionalidade usada para força a troca de
contexto\footnote{Troca de contexto é a operação na qual a tarefa em execução é
trocada por outra. Para que a troca de contexto sejá realizada, deve existir uma
tarefa de prioridade igual à da tarefa em execução} entre tarefas.
\item \textbf{taskENTER\_CRITICAL}: Funcionalidade usada para indicar o início de
uma região crítica. Ela desabilita temporariamente a característica de preempção
do escalonador impedindo que a tarefa em execução seja interrompida por outra.
\item \textbf{taskEXIT\_CRITICAL}: Funcionalidade usada para indicar o final de
uma região crítica, permitindo que ocorrá novamento escalonamento preemptivo.
\item \textbf{taskDISABLE\_INTERRUPTS}: Funcionalidade usada para desabilita as
interrupções do microcontrolador.
\item \textbf{taskENABLE\_INTERRUPTS}: Funcionalidade usada para habilitar as
interrupções do microcontrolador.
\end{itemize}

\subsubsection{Co-rotina}
\label{sec:corotina_api}
A última biblioteca do serviço de gerenciamento de tarefa e co-rotina é a
biblioteca co-rotina. Nela, estão presentes as funcionalidades e tipos
responsáveis por criar e gerenciar o elemento co-rotina. A lista completa das
funcionalidades presentes nessa biblioteca pode ser vista a seguir:

\begin{itemize}
\item \textbf{xCoRoutineHandle}: Tipo responsável por representar uma co-rotina.
	
\item \textbf{xCoRoutineCreate}: Funcionalidade usada para criar uma nova
co-rotina no sistema.
	
\item \textbf{crDELAY}: Funcionalidade usada para bloquear uma co-rotina durante
uma determinada quantidade de tempo.
	
\item \textbf{crQUEUE\_SEND}: Funcionalidade usada para enviar uma mensagem para
uma fila através de uma co-rotina.
	
\item \textbf{crQUEUE\_RECEIVE}: Funcionalidade usada para receber uma mensagem
de uma fila através de uma co-rotina.
	
\item \textbf{crQUEUE\_SEND\_FROM\_ISR}: Funcionalidade especial usada para
enviar uma mensagem para uma fila, através de uma co-rotina responsável por
tratar uma interrupção.
	
\item \textbf{crQUEUE\_RECEIVE\_FROM\_ISR}: Funcionalidade especial usada para
receber uma mensagem de uma fila, através de uma co-rotina responsável por
tratar uma interrupção.
	
\item \textbf{vCoRoutineSchedule}: Funcionalidade usada para chamar o escalonador
para escolher e colocar em execução a co-rotina de maior prioridade entre as
co-rotinas de estado pronto.

\end{itemize}

\section{Comunicação e sincronização entre tarefa}
Frequentemente tarefas necessitam se comunicar entre elas. Por exemplo, a tarefa
\textit{A} depende da leitura do teclado, feita pela tarefa \textit{B}, para
disponibilizar em uma tela as teclas digitadas pelo usuário. Para que essa
comunicação possa ser estruturada e sem interrupções, os sistemas operacionais
possuem mecanismos específicos de comunicações.

A maioria dos sistemas operacionais oferece vários tipos de comunicação entre as
tarefas. Geralmente esses tipos são: tarefas trocando informações entre si;
tarefas utilizando, de forma sincronizada, o mesmo recurso; tarefas dependentes
dos resultados produzidos por outras.

No FreeRTOS, como nos demais sistemas operacionais, os mecanismos responsáveis
por realizar a comunicação entre as tarefas são as filas de mensagens, os
semáforos e o mutexes (\textit{Mutal Exclusion}). Para entender melhor como
funciona essa comunicação, cada um desses mecanismos será detalhado a seguir.

\subsection{Fila de Mensagens}
\label{sec:fila}

Filas de mensagens são estruturas primitivas de comunicação entre tarefas. Elas
funcionam como um túnel, através do qual tarefas enviam e recebem mensagem
(figura~\ref{fig:fila_de_mensagens}). Assim, quando uma tarefa necessita
comunicar-se com outra, ela envia uma mensagem para o túnel para que a outra
tarefa possa ler sua mensagem \cite{Li03}.
 

\begin{figure}[!h] \centering \includegraphics[scale=0.7]{../fig/queue_pt.jpg}
\caption{Funcionamento de uma fila de mensagens}
\label{fig:fila_de_mensagens}
\end{figure} 
 
 
No FreeRTOS, uma fila de mensagens é formada por: 

\begin{itemize}
  \item A lista das mensagens na fila;
  \item A lista de tarefas que aguardam para enviar uma mensagem para a fila;
  \item A lista de tarefas que aguardam pela chegada de uma mensagem na fila;
  \item Uma variável que indica o tamanho das mensagem da fila; e
  \item Uma variável responsável por indicar o tamanho da fila, quantidade de
  mensagens que podem ser armazenadas pela fila. Ou seja, a capacidade máxima
  da fila.
\end{itemize}

O funcionamento de uma fila de mensagens no FreeRTOS ocorre da seguinte forma.
Primeiro a tarefa remetente envia uma mensagem para a fila e, em seguida, a
tarefa receptora retira a mensagem da fila. Entretanto, se, no momento do envio
da mensagem, a fila estiver cheia a tarefa remetente é bloqueada e colocada na
lista de tarefas que aguardam para enviar uma mensagem para a fila. O mesmo
ocorre quando a tarefa receptora tenta receber uma mensagem de uma fila vazia.

A retirada de uma tarefa da listas de espera de uma fila é feita levando em
consideração a prioridade das tarefas da lista. Assim, quando uma mensagem é
retirada de uma fila cheia, a lista de tarefas que aguardam para enviar uma
mensagem para a fila é percorrida e a tarefa de maior prioridade é retirada da
fila, sendo consequentemente desbloqueada. Fato parecido ocorre com a fila
de tarefas bloqueadas em leitura quando uma mensagem chega a uma fila vazia.

No momento de enviar uma mensagem para uma fila, uma tarefa pode especificar o
tempo máximo que ela deve permanecer bloqueada, aguardando para enviar a
mensagem. Assim como, ao solicitar uma mensagem para a fila, uma tarefa também
pode definir o tempo máximo que ela pode ficar bloqueada, esperando pela chegada
de uma mensagem na fila. As funcionalidades que tornam possível essas
características serão demonstradas na seção~\ref{sec:gerenciamento_fila_api}.


 
%Uma lista de tamanho fixo que armazena as mensagens, também de tamanhos fixos,
%enviadas para a lista. Assim, quando uma mensagem é envida para uma fila, uma
%cópia dessa mensagem é armazenada na lista para que posteriormente a outra
%tarefa possa ler a mensagem. Entretanto, contrária a copiar toda mensagem para
%a lista de mensagens, existe também a possibilidade de armazenar-se apenas uma
%referência da mensagem na lista, economizando assim a memória do sistema.
%Contudo, a técnica de armazenar apenas a referência da mensagen na lista torna
%mais complicado um trabalho do projetista, pois deste modo o acesso à mensagem
%na fila será compartilhado entre as tarefas interessadas, necessitando com
%isso de uma estrutura para sincronização o acesso da mensagem pelas tarefas.
%Na maioria das aplicações os projetistas utilizam a troca de mensagens
%através de cópia.

%Além da lista de mensagens, uma fila de mensagens é composta por mais duas
%lista, uma para armazenar as tarefas que estão aguardando enviar uma mensagens
%para a fila e outra para armazenar as tarefas que estão aguardando receber uma
%mensagem da fila. Assim, quando uma tarefa tenta enviar uma mensagem para uma
%fila cheia, a tarefa é bloqueada e colocada na lista de tarefa que aguardam
%para enviar uma mensagem para fila até que um lugar na fila seja liberado. O
%mesmo acontece quando uma tarefa tenta ler uma mensagem de uma fila vazia,
%neste caso, a tarefa vai para a lista de tarefas aguardando por uma mensagem
%da fila.

%No FreeRTOS, é possíveis definir o tempo máximo que uma tarefa pode ficará
%bloqueada esperado por uma fila (liberação de espaço ou chega de mensagem). E
%quando existirem mais de uma tarefa bloqueadas aguardando por um evento de uma
%fila, as tarefas de maior prioridade têm preferência sobre as demais.

\subsection{Semáforo}
\label{sec:semaforo}

Os semáforos são mecanismos usados para realizar a sincronização entre tarefas.
Eles funcionam como uma chave de pré-condição para uma tarefa executar uma
operação sincronizada ou acessar um recurso compartilhado. Assim, antes de
executar tal ação, a tarefa deve solicitar o semáforo responsável pela guarda da
ação. Caso o semáforo esteja disponível, a tarefa realiza a ação, caso contrário,
a tarefa é bloqueada até que o semáforo seja liberado.

O FreeRTOS disponibiliza dois tipos de semáforos para o usuário, o semáforo
binário e o semáforo com contador. A diferença entre esses dois tipos de semáforo
está no número de tarefas que podem reter o semáforo ao mesmo tempo. No semáforo
binário é possível apenas uma tarefa manter o semáforo. Entretanto, no semáforo
com contador existe um número fixo de tarefa (maior ou igual a um) que podem
reter o semáforo. 

Para controlar o acesso de várias tarefas ao semáforo com contador, ele possui
uma variável denominada contador, cujo valor é definido no momento da criação do
semáforo. Assim, seu funcionamento ocorre como demonstra a
figura~\ref{fig:semaforo}, para cada tarefa que retém o semáforo, o contador é
decrementado e, para cada tarefa que libera o semáforo, o contador é
incrementado. Com isso, o semáforo estará indisponível quando o valor do contador
for igual a zero e seu valor não poderá ultrapassar o número definido
inicialmente.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.4]{../fig/counting_semaphore_pt.jpg}
\caption{Diagrama de estado do semáforo com contador \cite{Li03}}
\label{fig:semaforo}
\end{figure}

%O funcionamento do semáforo com contador ocorre da seguinte maneira. Primeiro o
%semáforo é criado com um contador que ira determinar o número de tarefas que
%podem reter o semáforo ao mesmo tempo. Em seguida, quando um tarefa retem o
%semáforo essa variáveis é decrementada de uma unidade. Assim ocorre até que o
%contador fique zerado, indicando que o semáforo está indisponível e o número
%máximo de tarefas foi atingido. Consequentemente, quando as tarefas liberam o
%semáforo, o seu contador é incrementado. O semáforo binário trata-se de um
%semáforo com o contador igual à um.

No FreeRTOS, os semáforos são implementados como uma fila de mensagens que
informa o estado do semáforo através da situação da fila. Assim, quando a fila estiver
vazia, indica que o semáforo não poderá ser retido e, nas demais situações da
fila, indica que o semáforo está liberado. Com isso, para representar-se um
semáforo binário, é criada uma fila de capacidade um e, para representar um
semáforo com contador, é criada uma fila de capacidade igual ao valor inicial do
contador do semáforo.

\subsection{Mutex}
\label{sec:mutex}

Mutexes são estruturas parecidas com os semáforos binários. A única diferença
entre os dois é que o mutex implementa o mecanismo de herança de prioridade, o
qual impede que uma tarefa, de maior prioridade, fique bloqueada a espera de um
semáforo ocupado por outra tarefa, de menor prioridade, causando assim uma
situação de bloqueio por inversão de prioridade.

O mecanismo de herança de prioridade funciona como demonstra a
figura~\ref{fig:mutex}, quando uma tarefa solicita o mutex, ele primeiro verifica
se a tarefa solicitante possui prioridade maior que a tarefa com o semáforo. Caso
afirmativo, a tarefa que retém o semáforo tem, momentaneamente, a sua prioridade
elevada, para que assim ela possa realizar as suas funções sem interrupções e,
conseqüentemente, liberar o semáforo mais rapidamente. Um detalhe interessante
desse elemento é que ele utiliza as mesmas funcionalidades do semáforo para
reter e liberar o mutex. Essas funcionalidades serão explicadas na
seção~\ref{sec:semaforo_api}.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.5]{../fig/Priority_inheritance_pt.jpg}
\caption{Funcionamento do mecanismo de herança de prioridade}
\label{fig:mutex}
\end{figure}

\subsection{Bibliotecas}
Para disponibilizar as características de comunicação e sincronização entre
tarefas, o FreeRTOS dispõe de um conjunto de funcionalidades e tipos agrupados em
duas bibliotecas: gerenciamento de fila de mensagens e semáforo/mutex. Juntas
essas bibliotecas possuem vinte e quatro funcionalidades, das quais as principais
serão listadas nas seções seguintes.

\subsubsection{Gerencialmente de fila de Mensagens}
\label{sec:gerenciamento_fila_api}
O conjunto de funcionalidades de gerenciamento de uma fila de mensagens é
responsável pela criação e utilização da entidade fila de mensagens. Nele,
estão presentes funcionalidades responsáveis por instanciar e remover uma fila do
sistema e funcionalidades que enviam e recebem mensagens de uma fila do sistema.
A seguir, tem-se a lista das funcionalidades mais relevantes dessa biblioteca.


\begin{itemize}
  \item \textbf{xQueueCreate}: Funcionalidade usada para criar uma nova fila de
  mensagens no sistema.
  \item \textbf{vQueueDelete}: Funcionalidade usada para remover uma fila de
  mensagens do sistema.
  \item \textbf{xQueueSend}: Funcionalidade usada para enviar uma mensagem para
  uma fila.
  \item \textbf{xQueueSendToBack}: Funcionalidade usada para enviar uma mensagem
  para o final de uma fila.
  \item \textbf{xQueueSendToFront}: Funcionalidade usada para enviar uma
  mensagem para o início de uma fila.
  \item \textbf{xQueueReceive}: Funcionalidade usada para retirar uma mensagem
  de uma fila.
  \item \textbf{xQueuePeek}: Funcionalidade usada para ler uma mensagem de uma
  fila, sem removê-la.
 \item \textbf{xQueueSendFromISR}: Funcionalidade especial usada, pelas
  tarefas quem tratam de interrupções, para mandar uma mensagem para uma fila.
  \item \textbf{xQueueSendToBackFromISR}: Funcionalidade especial usada, pelas
  tarefas quem tratam de interrupções, para mandar uma mensagem para o final de
  uma fila.
  \item \textbf{xQueueSendToFrontFromISR}: Funcionalidade especial usada, pelas
  tarefas quem tratam de interrupções, para mandar uma mensagem para o início de
  uma fila.
  \item \textbf{xQueueReceiveFromISR} : Funcionalidade especial usada, pelas
  tarefas quem tratam de interrupções, para mandar uma mensagem de uma fila.
\end{itemize}

\subsubsection{Semáforo/Mutex}
\label{sec:semaforo_api}
Na biblioteca de semáforo e mutex estão implementadas, junto com as suas
funcionalidades, as estruturas de sincronização entre tarefas semáforo e mutex.
Assim, nesta biblioteca estão presentes funcionalidades que criam e removem
semáforos e mutex do sistema, como também funcionalidades utilizadas para
solicitar e liberar um semáforo ou mutex. As principais funcionalidades desta
biblioteca podem ser vista a seguir.


\begin{itemize}
  \item \textbf{vSemaphoreCreateBinary}: Funcionalidade usada para criar um
  semáforo binário.
  \item \textbf{vSemaphoreCreateCounting}: Funcionalidade usada para
  criar um semáforo com contador.
  \item \textbf{xSemaphoreCreateMutex}: Funcionalidade usada para criar um mutex.
  \item \textbf{xSemaphoreTake}: Funcionalidade usada para reter um semáforo
  ou um mutex.
  \item \textbf{xSemaphoreGive}: Funcionalidade usada para liberar um semáforo ou
  um mutex retido.
  \item \textbf{xSemaphoreGiveFromISR}: Funcionalidade especial usada, pelas
  tarefas que tratam de interrupções do sistema, para liberar um semáforo binário
  ou com contador. Não deve ser utilizada para mutex.
\end{itemize}

%Procurar um melhor nome para essa seção
\section{Utilizando práticas dos elementos FreeRTOS}

Para construir uma aplicação de tempo real utilizando o FreeRTOS, o desenvolvedor
deve seguir determinadas restrições impostas pelo sistema. A maioria destas
restrições são parâmetros de configuração e modelos para a criação dos elementos
do sistema. Assim, com o intuito de ajudar o desenvolvedor a criar suas primeiras
aplicações, o FreeRTOS disponibilizou, junto com seu código fonte, aplicações
exemplos classificadas por plataformas. Desse modo, essas aplicações exemplos
podem ser utilizadas como ponto de partida na criação de novos projetos.

Entretanto, a criação e análise de uma nova aplicação no FreeRTOS é uma atividade
que necessita de maior conhecimento sobre as suas funcionalidades, fugindo assim
do objetivo geral desse capitulo, que é proporcionar uma breve introdução ao
FreeRTOS, demonstrando seus principais conceitos, funcionalidades e
características. Com isso, para um melhor entendimento das explicações
apresentadas neste capítulo, será demonstrada, nas seções seguintes, de forma
didática, a utilização das principais entidades aqui discutidas, tarefa,
co-rotinas, fila de mensagens e semáforos.

\subsection{Utilização da entidade tarefa}
\label{sec:tarefa_utilizacao}

A tarefa é a parte mais importante de uma aplicação. É nela que são colocadas as
ações responsáveis pelo funcionamento da aplicação\cite{Li03}. No FreeRTOS, as
ações realizadas pelas tarefas são colocadas dentro de rotinas, as quais
devem seguir uma estrutura pré-definida, demonstrada pela
figura~\ref{fig:estruta_rotina_tarefa}. Nela, tem-se que uma rotina deve ser
formada inicialmente por um cabeçalho com o seu nome e seguido de uma lista
de parâmetros utilizados por ela. Em seguida, tem-se o código que realiza as
finalidades da tarefa, no qual um laço infinito é colocado para abrigar a parte
repetitiva desse código. Assim, a atividade de uma tarefa nunca termina, ficando
sob o controle do escalonador.
 
\begin{figure}[!h] \centering
\begin{small}
\begin{verbatim}
void functionName( void *vParameters ) 
{
      for( ;; )
      {
          -- Task application code here. --
      }
}
\end{verbatim}
\end{small}
\caption{Estrutura da rotina de uma tarefa}
\label{fig:estruta_rotina_tarefa}
\end{figure}

Um exemplo concreto da criação de uma tarefa pode ser visto na figura
\ref{fig:app_tarefa_ciclica}. Nela, tem-se a rotina \textit{cyclicalTasks}, que
utiliza a funcionalidade \textit{vTaskDelayUntil}
(seção~\ref{sec:controle_tarefa_api}) para bloquear a execução da tarefa em
intervalos iguais de tempo. Essa funcionalidade possui como parâmetros,
respectivamente, o último tempo que a tarefa foi reativa do estado SUSPENSA e o
período que a tarefa deve permanecer bloqueada. Após isso, a tarefa é criada no
sistema junto com sua prioridade, pilha de contexto e nome. Essa operação é feita
através da funcionalidade \textit{xTaskCreate} que possui como parâmetros os
seguintes argumentos:

\begin{description}
\item[cyclicalTasks]: Ponteiro para a rotina que deve ser executada
pela tarefa;
\item[``cyclicalTasks'']: Nome da tarefa utilizada nos arquivos de log
do sistema;
\item[STACK\_SIZE]: Tamanho da pilha de execução da função especificado
de acordo com o número de variáveis declaradas na rotina da função;
\item[pvParameters]: Lista de valores dos parâmetros de entrada da rotina da
função;
\item[TASK\_PRIORITY]: Prioridade da tarefa;
\item[cyclicalTasksHandle]: Gancho de retorno da tarefa criada.
\end{description}

\begin{figure}[!h] \centering
\begin{small}

\begin{verbatim}
void cyclicalTasks( void * pvParameters ){
    portTickType xLastWakeTime;
    const portTickType xFrequency = 10;
    // Initialise the xLastWakeTime variable with the current time.
    xLastWakeTime = xTaskGetTickCount();
    for( ;; ){
        // Wait for the next cycle.
        vTaskDelayUntil( &xLastWakeTime, xFrequency );
        // Perform action here.
    }
}

xTaskHandle cyclicalTasksHandle;

xTaskCreate( cyclicalTask, "cyclicalTasks", STACK_SIZE, 
                 ( void * ) pvParameters, TASK_PRIORITY, &cyclicalTasksHandle);

vTaskStartScheduler();

\end{verbatim}
\end{small}
\caption{Aplicação formada por uma tarefa cíclica}
\label{fig:app_tarefa_ciclica}
\end{figure}

Para finalizar o exemplo da figura~\ref{fig:app_tarefa_ciclica}, após ser criada
a tarefa,  o escalonador do sistema deve ser iniciado e com ele a aplicação. Essa
operação é feita pela a funcionalidade \textit{vTaskStartScheduler()}, localizada
no final do código.


\subsection{Utilização da fila de mensagens}
\label{fila_utilizacao}

A utilização de uma fila de mensagens é resumidamente demonstrada na aplicação da
figura~\ref{fig:app_fila_de_mensagens}. Nela, inicialmente tem-se a estrutura
\textit{AMessage}, que define o tipo da mensagem que será utilizada. Em seguida,
através do método \textit{xQueueCreate}, é criada uma fila de mensagens que será
referenciada pela variável \textit{xQueue}, do tipo \textit{xQueueHandle}. Para
isso, o método \textit{xQueueCreate} recebe como parâmetros, respectivamente, a
quantidade de mensagens que a fila pode armazenar e o tamanho da mensagens
manuseadas por ela.


\begin{figure}[!h] \centering
\begin{small}

\begin{verbatim}
struct AMessage { 
    portCHAR ucMessageID; 
    portCHAR ucData[ 20 ]; 
}xMessage;

xQueueHandle xQueue;
//Create a queue capable of containing 10 pointers to AMessage structures.
xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
// Task to create a queue and post a value. 
void sendTask( void *pvParameters ) { 
struct AMessage *pxMessage;
	 
    if( xQueue == 0 ) { 
        // Failed to create the queue. 
    }else{
        // Send a pointer to a struct AMessage object. Don't block if the 
        // queue is already full. 
        pxMessage = & xMessage; 
        xQueueSend( xQueue, ( void * ) &pxMessage, ( portTickType ) 0 );
    }
// ... Rest of task code.
 
}

// Task to receive from the queue. 
void receiveTask( void *pvParameters ) { 
struct AMessage *pxRxedMessage;

    if( xQueue != 0 ) { 
        // Receive a message on the created queue. Block for 10 ticks if a 
        // message is not immediately available. 
        if( xQueueReceive( xQueue, &( pxRxedMessage ), ( portTickType ) 10 ) ) {
            // pcRxedMessage now points to the struct AMessage variable posted 
            // by vATask. 
        } 
    }
    // ... Rest of task code. 
} 

\end{verbatim}
\end{small}
\caption{Aplicação que utiliza uma fila de mensagens}
\label{fig:app_fila_de_mensagens}
\end{figure}
  

Estabelecida a fila de mensagens, é necessário agora definir as tarefas que irão
enviar e receber mensagens da mesma. Na figura~\ref{fig:app_fila_de_mensagens},
estão presentes apenas as rotinas de cada uma dessas tarefas, sendo que a
explicação completa de como é criada uma tarefa foi demonstrada na
seção~\ref{sec:tarefa_utilizacao}. A seguir tem-se a explanação sobre cada uma
dessas rotinas.

Para enviar uma mensagem para a fila \textit{xQueue}, a rotina \textit{sendTask}
utiliza-se da funcionalidade \textit{xQueueSend}. Essa funcionalidade possui como
parâmetros a fila para qual a mensagem será enviada, a mensagem que será enviada
para a fila e o tempo máximo que a tarefa poderá ficar bloqueada aguardando para
enviar a mensagem. 
%O código que deve ser executado após o envio da
%mensagem é colocado abaixo de uma condição \textit{if}, que recebe a
%confirmação do envio da mensagem como retorno de \textit{xQueueSend}.

Por último, na rotina \textit{receiveTask}, uma mensagem é retirada da fila
\textit{xQueue} através da funcionalidade \textit{xQueueReceive}. Para isso, ela
utiliza como argumentos, respectivamente, a fila, de onde será retirada a
mensagem, o local que o endereço da mensagem que irá ser armazenado, e o tempo
máximo que a tarefa pode ficar esperando pela fila. Como retorno, essa
funcionalidade informa se a mensagem foi retirada da fila com sucesso ou não,
sendo, com isso, utilizada como guarda para o código que deve ser executado após
a retirada da mensagem.


\subsection{Utilização do semáforo}
\label{sec:semaforo_utilizacao}

%Semáforos são estruturas de sincronização entre tarefas. Eles são utilizados
%para coordenar o uso de recurso compartilhado por uma ou mais tarefas e para
%coordenar a execução de uma determinada função sicronizada. Assim, o código da
%tarefa responsável por acessar o recurso compartilhado ou executar uma função
%sicronizada deve ser protegido de maneira que a sua execução só ocorra quando a
%tarefa possuir o semáforo.

Para a construção de uma aplicação que se utiliza do semáforo são necessárias
basicamente três funcionalidades da biblioteca de semáforos,
\textit{vSemaphoreCreateBinary}, \textit{xSemaphoreTake} e
\textit{xSemaphoreGive}. A primeira funcionalidade cria o semáforo e as demais
solicitam e liberam o semáforo, respectivamente.

Um exemplo de uma aplicação que utiliza um semáforo para controlar o acesso de um
recurso compartilhado pode ser visto na figura~\ref{fig:app_semaforo}. Nela,
inicialmente é criada a variável \textit{xSemaphore} para armazenar uma
referência ao novo semáforo. Em seguida, o método \textit{vSemaphoreCreateBinary}
é usado para criar o novo semáforo e retornar uma referência para o mesmo.

\begin{figure}[!h] \centering
\begin{small}

\begin{verbatim}

xSemaphoreHandle xSemaphore = NULL;


// Create the semaphore to guard a shared resource. As we are using 
// the semaphore for mutual exclusion we create a mutex semaphore 
// rather than a binary semaphore. 
xSemaphore = xvSemaphoreCreateBinary();

// A task that uses the semaphore. 
void semaphoreTask( void * pvParameters ) { 
    // ... Do other things.
    if( xSemaphore != NULL ) {
        // See if we can obtain the semaphore. If the semaphore is not available 
        // wait 10 ticks to see if it becomes free. 
        if( xSemaphoreTake( xSemaphore, ( portTickType ) 10 ) == pdTRUE ) { 
            // We were able to obtain the semaphore and can now access the 
            // shared resource.
            // We have finished accessing the shared resource. Release the 
            // semaphore. 
            xSemaphoreGive( xSemaphore ); 
        } else
            // We could not obtain the semaphore and can therefore not access 
            // the shared resource safely 
       { 
    } 
} 
\end{verbatim}
\end{small}
\caption{Aplicação que demonstra a utilização de um semáforo}
\label{fig:app_semaforo}
\end{figure}

Após a criação do semáforo, a rotina da tarefa que utilizará o recurso
compartilhado é desenvolvida. Nela, o código que acessará tal recurso está
protegido pela segunda condição \textit{if}, a qual recebe o retorno do método
\textit{xSemaphoreTake}, informando se o semáforo foi retido ou não. Ao final da
rotina, o semáforo é liberado pelo método \textit{xSemaphoreGive}, permitindo que
outra tarefa possa retê-lo e usar o recurso compartilhado.

A utilização do mutex é bem parecida com a do semáforo binário. A diferença, para
o usuário, entre os dois mecanismos está apenas no método de criação da entidade,
\textit{xSemaphoreCreateMutex}. As formas e os métodos para solicitar e liberar o
mutex são os mesmos do semáforo, \textit{xSemaphoreTake}  e
\textit{xSemaphoreGive}. Com isso, para transformar a aplicação da
figura~\ref{fig:app_semaforo} de semáforo para mutex basta apenas trocar o método
\textit{vSemaphoreCreateBinary} por \textit{xSemaphoreCreateMutex}.


\subsection{Utilização das co-rotinas}
\label{subsec:corotina_utilizacao}

As co-rotinas, assim como as tarefas, possuem as ações resposáveis pelas
atividades da aplicação. Essas ações são colocadas dentro das rotinas executadas
pelas co-rotinas, as quais devem seguir o modelo demonstrado na
figura~\ref{fig:rotina_corotina}. Nele, a rotina deve possuir um nome, seguido de
dois parâmetros \textit{xHandle}, uma referência para a co-rotina que será
utilizado pelas funcionalidades de controle da co-rotina, e \textit{uxIndex},
que é usado opcionalmente no desenvolvimento do código da co-rotina. Por último, o
código de execução da co-rotina deve ser iniciado com a função
\textit{crSTART(xHandle)} e finalizado pela função \textit{crEND()}.

\begin{figure}[!h] \centering
\begin{small}

\begin{verbatim}

void vACoRoutineFunction(xCoRoutineHandle xHandle, 
						unsigned portBASE_TYPE uxIndex ){
        crSTART( xHandle );
        for( ;; )
        {
            -- Co-routine application code here. --
        }
        crEND();
    }

\end{verbatim}
\end{small}
\caption{Modela da rotina de execução de uma co-rotina}
\label{fig:rotina_corotina}
\end{figure}

Um exemplo completo da utilização de uma co-rotina pode ser vito na
figura~\ref{fig:utilizacao_corotina}. Nesse exemplo é criada uma co-rotina que,
através da rotina \textit{vFlashCoRoutine}, controla o funcionamento de um LED.
Para isso ela interrompe a sua execução durante um tempo de dez ticks (unidade de
tempo do FreeRTOS), utilizando a funcionalidade \textit{crDELAY}, que tem como
argumentos o gancho da co-rotina e o tempo de bloqueio da co-rotina. Após isso, a
função de controle do LED \textit{vParTestToggleLED} é chamada. Observa-se, nesse
exemplo, a utilização dos parâmetros da rotina como argumentos para a
funcionalidade \textit{crDELAY}.

Com a criação da rotina utilizada pela co-rotina, resta apenas criar a co-rotina
no sistema. Esse trabalho é feito através da funcionalidade
\textit{xCoRoutineCreate}, que recebe como parâmetros respectivamente a rotina
que será associada à co-rotina, a prioridade da co-rotina e o valor do parâmetro
\textit{uxIndex} da rotina associada à co-rotina.

Por fim, devido à política de escalonamento cooperativo das co-rotinas, ao final
da aplicação de figura~\ref{fig:utilizacao_corotina} é colocada na rotina
\textit{vApplicationIdleHook} (rotina executada pela tarefa ociosa,
seção~\ref{subsubsection:tarefa_ociosa}) a funcionalidade
\textit{vCoRoutineSchedule} que chama o escalonador para realizar a troca da
co-rotina em execução. Assim, sempre que a co-rotina em execução é bloqueada, a
tarefa ociosa entra em ação chamando o escalonador para fazer a troca de
co-rotinas.


\begin{figure}[!h] \centering
\begin{small}

\begin{verbatim}
...
void main( void )    {
	// This time i is passed in as the index.
	xCoRoutineCreate( vFlashCoRoutine, PRIORITY_0, 10 );

    // NOTE: Tasks can also be created here!
	// Start the scheduler.
    vTaskStartScheduler();
}

void vFlashCoRoutine( xCoRoutineHandle xHandle, 
							unsigned portBASE_TYPE uxIndex ){
	// Co-routines must start with a call to crSTART().
	crSTART( xHandle );
        for( ;; ){            
            crDELAY( xHandle, uxIndex);
            vParTestToggleLED;
        }
	// Co-routines must end with a call to crEND().
	crEND();

}

void vApplicationIdleHook( void ){
        vCoRoutineSchedule( void );
}


\end{verbatim}
\end{small}
\caption{Aplicação que demonstra a utilização de uma co-rotina}
\label{fig:utilizacao_corotina}
\end{figure}


%\section{Comentários conclusivos}
% Relatar aqui as propriedade que o sistema em execução deve satisfazer. Dar
% nomes/números para futuras referências no texto.



\chapter{Método B}
\label{cap:metodob}

Métodos Formais provêem abordagens formais para a especificação e construção de
sistemas computacionais. Eles utilizam-se de conceitos matemáticos sólidos como
lógica de primeira ordem e teorias dos conjuntos para a criação e verificação de
sistemas consistentes, seguros e sem ambigüidades. Devido aos seus rigorosos
métodos de construção, a sua principal utilização, embora timidamente, tem sido
na criação de sistemas críticos para as indústrias de aeronáutica, viação férrea,
equipamentos médicos e empresas que movimentam grandes quantidades
monetárias, como os bancos\cite{Jim09}.

%SG->DD:
% Talvez seja melhor retirar o parágrafo abaixo, mas acho que ele da uma
% atrativo a mais para a utilização de métodos formais
% A base teórica dele esta em
% www51.honeywell.com/aero/technology/common/documents/formal-methods.pdf
% Não sei se é uma fonte bibligráfica válida

Segundo a Honeywell, uma empresa que desenvolve sistemas para aeronaves, a
utilização de métodos formais no processo de desenvolvimento provê várias
vantagens, entre eles estão \cite{honeywell03}:
\begin{itemize}
  \item A produção mensurada pela corretude, métodos formais provêem uma forma
  objetiva de mensurar a corretude do sistema;  
  \item Antecipação na detecção de erros, métodos formais são usados previamente
  em projetos de artefatos do sistema, permitindo assim a sua verifica e com
  isso a detecção antecipada de possíveis erros do projeto;  
  \item Garantia da corretude, através mecanismo de verificação formal é
  possível provar que sistema funcionará de forma coerente com a sua especificação inicial.
\end{itemize} 
  
O método B\cite{abrial96} é uma abordagem formal usada para especificar e
construir sistemas computacionais seguros. Seu criador, Jean-Raymond Abrial,
junto com a colaboração de outros pesquisadores da universidade de Oxford, procurou
reunir no método B vários conceitos presentes nos demais métodos formais. Entre
esses conceitos, destacam-se as pré e pós condições (seção~\ref{sec:operacao}), o
desenvolvimento incremental através de refinamentos (seção~\ref{sec:refinamento})
e a modularização da especificação. A seguir, tem-se a explicação de como e
feito o desenvolvimento de sistemas utilizando o método B.




%o método B proporciona uma criação de sistemas através de sucessiveis níveis de
%abstração, na qual inicialmente cria-se um modulo abstrato em uma linguagem de
%modelagem. Esse módulo é refinado através de vários outros módulos até chegar
%em uma linguagem algorítmica, denominada B0, que pode ser traduzida
%automaticamente em algumas linguagem de programação imperativa com C, Ada,
%Java, JavaCard e C\#.

%Cada módulo criado no desenvolvimento do sistema com o método B deve ser
%analisado estaticamente para saber se ele é implementável ou consistente, ou
%seja, que sua execução não leve a um estado não permitido pela especificação.
%Assim como também cada nível de abstração deve ser analisado estaticamente para
%saber se ele é coerente com o nível acima.

\section{Etapas do desenvolvimento em B}

O processo de desenvolvimento através do método B inicia-se com a criação de um
módulo, que define em alto nível um modelo funcional do sistema. Em B, esses
módulos são denominados de Máquinas Abstratas (\textit{MACHINE}). Nessa fase de
modelagem, técnicas semi-formais como UML podem ser utilizadas e, em seguidas,
transformadas para a notação formal do método B. Após a criação dos módulos,
esses são analisados estaticamente para verificar se são coerentes e
implementáveis.

Uma vez estabelecido o modelo abstrato inicial do sistema, o método B permite que
sejam construídos módulos mais concretos do sistema, denominados refinamentos.
Mais especificamente, refinamentos correspondem a uma decisão de projeto, na qual
partes da especificação abstrata do sistema devem ser modeladas em um nível mais
concreto. Assim, um refinamento deve necessariamente estar relacionado com o
módulo abstrato imediatamente anterior. Como ocorre na criação das máquinas
abstratas, um refinamento também é passível de uma análise estática, na qual é
verificada a relação entre o refinamento e o seu nível abstrato anterior.

Devido à técnica de refinamentos, o desenvolvimento de sistemas utilizando o
método B pode chegar a um nível de abstração semelhante aos das linguagens de
programação imperativas e seqüenciais. Para isso, sucessivos refinamentos devem
ser desenvolvidos até a especificação chegar a um último nível de refinamento
denominado implementação (\textit{IMPLEMENTATION}). Nesse nível, a linguagem
utilizada, chamada B0, é um formalismo algorítmico passível de ser sintetizado
para linguagens de programação com C, Java e JavaCard.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.9]{../fig/desenvolvimento_b.jpg}
\caption{Etapas do desenvolvimento de sistema através do método B
\cite{dantas08}}
\label{fig:desenvolvimento_b}
\end{figure}

Assim o desenvolvimento de sistemas utilizando o método B é feito como demonstra
a figura~\ref{fig:desenvolvimento_b}. Nela, os requisitos do sistema são
inicialmente especificados em um alto nível de abstração e, após sucessivos
refinamentos, um nível algorítmico do sistema é alcançado. Em seguida, essa
especificação é sintetizada para um código de linguagem de programação, para o
qual é possível, a partir da especificação funcional inicial, gerar testes para
validar a sua correta transformação.

Atualmente, o desenvolvimento de sistemas utilizando o método B pode ser apoiado
por diversas ferramentas com funcionalidades que vão da análise estática da
especificação até a geração de código em linguagens de programação. Uma das mais
famosas e completas ferramentas de apoio ao desenvolvimento de sistemas
utilizando o método B é o AtelierB \cite{atelierb}. Nela, é possível, além da
análise sintática e estática da especificação, gerenciar-se projetos, controlando
as dependências entre os vários módulos que constituem uma especificação. Devido
as suas vastas funcionalidades e popularidade, o AtelierB será adotado como
ferramenta padrão desse trabalho.

Um exemplo de sistemas desenvolvidos através da abordagem B é o controle de
porta do metrô de paris, desenvolvido pela Clearsy\footnote{www.clearsy.com},
empresa especialista em sistemas críticos. Esse sistema impede que o trem saia da
estação quando a porta do mesmo estiver aberta, evitando assim possíveis
acidentes\cite{behm99}.

\section{Máquina Abstrata}
\label{sec:maquina_abstrata}

A base do método B está na notação de máquina abstrata (em inglês:
\textit{Abstract Machine Notation} - AMN), a qual disponibiliza um framework
comum para a especificação, construção e verificação estática de sistemas. Em
outras palavras, a AMN é uma linguagem de especificação de sistemas formada por
módulos básicos de construção chamados de Máquina Abstrata ou simplesmente
Máquina.

Cada Máquina Abstrata é composta por diferentes seções, sendo que cada seção é
responsável por definir um aspecto da especificação do sistema como: parâmetros,
tipos, constantes, variáveis de estado, estados iniciais e transições do sistema.
Por exemplo, a figura~\ref{fig:maquina_kernel} contém uma Máquina Abstrata,
chamada \textit{Kernel}, a qual especifica um sistema que permite incluir e
excluir tarefas até o limite de 10. Essa máquina possui as seguintes seções:

\begin{description}
\item[MACHINE] é onde se inicia o código da máquina abstrata. Nela,
identifica-se a natureza e o nome do módulo, seguido opcionalmente por um ou mais parâmetros de
máquina, os quais são separados por vírgula e limitados por parênteses;
\item[SETS] introduz um novo tipo de entidade, como é o caso de 
  $\mathit{TASK}$ no exemplo em questão. Nesse momento, nenhum detalhe é
  fornecido quanto à maneira como essa entidade será implementada;
\item[VARIABLES] informa o nome das diferentes variáveis que compõem o estado
da máquina. No exemplo da figura~\ref{fig:maquina_kernel}, há apenas uma
variável de estado, $\mathit{tasks}$;
\item[INVARIANT] especifica o tipo das variáveis de estado
  e os estados válidos do sistema. No exemplo em questão, a variável
  $\mathit{tasks}$ é um conjunto de até 10 elementos do tipo $\mathit{TASK}$. A
  caracterização lógica do conjunto dos estados válidos é uma das atividades mais
  importantes da especificação;
\item[INITIALISATION] identifica quais são os possíveis estados
  iniciais do sistema. No caso da figura~\ref{fig:maquina_kernel} ,
  $\mathit{tasks}$ é inicializado como um o conjunto vazio; e
\item[OPERATIONS] determina os diferentes tipo de eventos que o
  sistema pode sofrer. No exemplo demonstrado, tem-se operações para
  adicionar e eliminar um elemento de $\mathit{tasks}$. Uma operação
  pode ter parâmetros, resultados e alterar o valor de variáveis
  de estado. Um ponto importante encontrados nas operações são as pré-condições,
  as quais são condições que devem ser satisfeitas para que a operação seja
  realizada.
\end{description}  
\begin{figure}[!ht]
\begin{small}

$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\MACHINE\\
\quad \mathit{Kernel}\\
    
\SETS\\
\quad \mathit{TASK}\\
    
\VARIABLES\\
\quad \mathit{tasks}\\
    
\INVARIANT\\
\quad \mathit{tasks} \in \pow(\mathit{TASK}) \land \\
\quad \card(\mathit{tasks})\leq 10\\
    
\INITIALISATION\\
\quad \mathit{tasks}:=\emptyset\\
    
\end{array}
\begin{array}[t]{l}
\OPERATIONS\\\\
\mathit{task\_add}(\mathit{task}) = \\
\quad \PRE \\
\quad\quad \mathit{task}\in \mathit{TASK} \land \\
\quad\quad \mathit{task}\not\in \mathit{tasks} \land\\
\quad\quad \card(\mathit{tasks})<10\\
\quad \THEN\\
\quad\quad \mathit{tasks}:=\mathit{tasks}\cup \{\mathit{task}\}\\
\quad   \END;\\

\end{array}

\begin{array}[t]{l}
\ldots\\
\mathit{task\_delete}(\mathit{task})=\\
\quad \PRE\\
\quad \quad \mathit{task}\in \mathit{tasks}\\
\quad \THEN\\
\quad \quad \mathit{tasks}:=\mathit{tasks}-\{\mathit{task}\}\\
\quad \END\\
	
\END\\
\end{array}
\end{array}
$$
\end{small}
\caption{Maquina abstrata de tarefas}
\label{fig:maquina_kernel}
\end{figure}

Para uma melhor compreensão, a especificação de sistemas através das maquinas
abstratas será resumidamente dividida em duas partes principais. Na primeira
parte, serão colocadas informação a respeito dos estados da máquina, suas
variáveis e restrições. Na segunda parte, será especificado o comportamento da
máquina, ou seja, a sua parte dinâmica, como a inicialização e as operações.
Essas duas partes serão melhor discutidas a seguir.

\subsection{Especificação do estado da máquina}

Nessa parte, são determinados os estados que uma máquina pode assumir. Esses
estados são definidos através das variáveis e dos seus invariantes
($\INVARIANT$). As variáveis são diferentes elementos que compõem o estado do
sistema. Os invariantes são expressões lógicas que determinam os valores que as
variáveis podem assumir. Assim, uma especificação só pode definir o correto
funcionamento da máquina, quando ela encontra-se em um estado válido, nada sendo
especificado para os demais casos.

O estado de uma máquina é especificado por meio de lógica dos predicados, teoria
dos conjuntos e aritmética dos inteiros, permitindo com isso uma análise
estática da máquina através das expressões lógicas geradas apartir de sua
especificação. No exemplo da figura~\ref{fig:maquina_kernel}, o estado da máquina
\textit{kernel} foi especificado através da variável $\mathit{tasks}$, sendo
$\mathit{tasks} \in \pow(\mathit{TASK})$ e $ \card(\mathit{tasks})\leq 10$, o que
define que $\mathit{tasks}$ deve ser um conjunto de $\mathit{TASK}$ e que o
tamanho máximo permitido para o conjunto $\mathit{tasks}$ é de dez elementos.

\subsection{Especificação das operações da máquina}
\label{sec:operacao}
Nas operações da máquina é especificado o comportamento dinâmico do sistema. É
através das operações que o estado da máquina é alterado, respeitando sempre as
suas restrições. Mais especificamente, as condições declaradas no invariante da
máquina devem ser sempre satisfeitas ao final da operação, levando assim a
máquina a um estado válido.

O cabeçalho de uma operação é composto por um nome, uma lista de parâmetros de
entrada e uma lista de parâmetros de saída \footnote{A notação de máquina
abstrata permite que uma operação retorne mais de um.}, sendo os parâmetro de
entrada e os parâmetros de saída argumentos opcionais. Um exemplo de uma
operação com parâmetros de entrada e saída pode ser visto na figura~\ref{fig:query_task}.
Nela, o nome da operação é $\mathit{query\_task}$, o parâmetro de entrada é
$\mathit{task}$ e o parâmetro de saída é $\mathit{ans}$.

A operação propriamente dita é formada por pré-condição e corpo da operação. Na
pré-condição, são colocadas as informações sobre todos os parâmetros de entrada e
as condições que devem ser satisfeitas para que a operação seja executada. Com
isso, a pré-condição funciona como uma premissa que deve ser suprida para que a
operação funcione corretamente. Por exemplo, na figura~\ref{fig:maquina_kernel},
para que a operação $\mathit(add\_task)$ funcione corretamente, ou seja, não leve
a máquina para um estado inválido, as pré-condições $\mathit{task}\in
\mathit{TASK}$, $\mathit{task}\not\in \mathit{tasks}$ e
$\card(\mathit{tasks})<10$ devem ser obedecidas.


\begin{figure}[!ht]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
\mathit{ans}\leftarrow \mathit{query\_task}(\mathit{task}) =\\
\PRE
\quad \mathit{task} \in \mathit{TASK}\\
\THEN\\
\quad\quad \IF \quad \mathit{task} \in \mathit{TASK} \\
\quad\quad \THEN \quad ans := yes\\
\quad\quad \ELSE \quad ans:=no\\
\END
\end{array}
\end{array}
$$
\end{small}
\caption{Operação que consulta se uma tarefa pertence a máquina
$\mathit{Kernel}$}
\label{fig:query_task}
\end{figure}

No corpo da operação é especificado o seu comportamento. Nele, os parâmetros de
saída devem ser obrigatoriamente valorados e os estados da máquina podem ser
alterados ou consultados. Assim, para realizar, de um modo formal, as
atualizações de estado e definições de parâmetros de saída, a notação de máquina
abstrata possui um conjunto de atribuições abstratas, denominadas substituições,
as quais serão explicadas a seguir.

Formalmente, uma substituição é um transformador de predicados (ou de formulas).
Ela funcionam da seguinte forma, se $\mathit{P}$ for um predicado,
$[\mathit{S}]\mathit{P}$ é um predicado resultado da aplicação da substituição de
$\mathit{S}$ à $\mathit{P}$. A seguir são demonstrados algumas das principais
substituições da AMN e como são transformados os predicados utilizados por elas.

\subsubsection{Substituição Simples}

A substituição simples é definida da seguinte forma: $$\mathit{x}:= \mathit{E}$$
Nela, $\mathit{x}$ é uma variável de máquina ou parâmetro de saída, para o
qual será atribuído o valor da expressão $\mathit{E}$. Mais precisamente, uma
substituição simples é interpreta da seguinte maneira:

$$[\mathit{x}:=\mathit{E}]\mathit{P} \Rightarrow \mathit{P}(\mathit{x}\setminus
\mathit{E})$$

Onde se tem que, no predicado $\mathit{P}$, a variável $\mathit{x}$ deve ser
substituída por $\mathit{E}$.

%Por exemplo na operação
%$\mathit{add\_task}$ a substituição $\mathit{tasks}:=\mathit{tasks}\cup
%\{\mathit{task}\}$ pode ser vista como $[\mathit{tasks}:=\mathit{tasks}\cup
%\{\mathit{task}\}] \card(\mathit{tasks})<10$, Na qual
%$\card(\mathit{tasks})<10$ é o predicado, no caso o invariante da máquina, que
%deve ser obedecido quando a substituição for realizada, ficando ao final
%$\mathit{tasks}\cup \{\mathit{task}\}<10$.

\subsubsection{Substituição Múltipla}

A substituição múltipla é uma generalização da substituição simples. Ela permite
que várias variáveis sejam atribuídas simultaneamente. Uma substituição múltipla
utilizando duas variáveis tem a seguinte forma:

$$\mathit{x},\mathit{y}:=\mathit{E},\mathit{F} $$

Na definição acima, às variáveis $\mathit{x}$ e $\mathit{y}$ são atribuídos os
valores das expressões $\mathit{E}$ e $\mathit{F}$, respectivamente. Assim, da
mesma forma que a substituição simples, a substituição múltipla é definida da
seguinte maneira:

$$[\mathit{x}:=\mathit{E},\mathit{y}:=\mathit{F}] \mathit{P} \Rightarrow
\mathit{P}[\mathit{E},\mathit{F} \setminus \mathit{x},\mathit{y}]$$ Na qual, no
predicado $\mathit{P}$, as variáveis $\mathit{x}$ e $\mathit{y}$ são substituidas
por $\mathit{E}$ e $\mathit{F}$, respectivamente. Por exemplo,
$\mathit{x},\mathit{y} :=\mathit{y}+5 , \mathit{x}+10$ resulta em
$\mathit{y}+5<\mathit{x}+10$.

\subsubsection{Substituição Condicional}

As substituições simples e múltipla permitem somente uma opção de especificação,
onde uma atribuição é sempre feita de maneira uniforme, sem opções e sem levar em
consideração os estados iniciais da operação. Entretanto, as linguagens de
programação convencionais disponibilizam um tipo condicional de atribuição, na
qual são permitidos caminhos diferentes escolhidos de acordo com expressões
lógicas que utilizam os valores iniciais das variáveis do sistema e os parâmetros
passados.

Como nas linguagens de programação, a notação de máquina abstrata também permite
a construção de atribuições condicionais, as quais são feitas através da
substituição condicional. Com isso, uma substituição condicional funciona da
mesma forma que nas linguagens de programação. Nela, inicialmente uma expressão
lógica é avaliada e, em seguida o caminho que a estrutura deve seguir, quais
atribuições devem ser realizadas, é escolhido de acordo com o resultado da
expressão. A forma como é especificada uma substituição condicional na ANM pode
ser vista a seguir:

$$\IF \quad \mathit{E}\quad \THEN\quad \mathit{S}\quad \ELSE\quad
\mathit{T}\quad \END$$

Na especificação acima, $\mathit{S}$ e $\mathit{T}$ são substituições quaisquer.
Elas tem as suas aplicações condicionadas pela expressão lógica $\mathit{E}$, que
pode conter variáveis da máquina e parâmetros de entrada. Com isso, caso
$\mathit{E}$ seja satisfeita a substituição $\mathit{S}$ é realizada e, caso
contrário, a substituição $\mathit{T}$ é executada. Assim, uma
substituição condicional pode ser interpretada da seguinte forma:

$$[\IF \quad \mathit{E} \quad \THEN \quad \mathit{S} \quad \ELSE
\quad \mathit{T}\quad \END] \mathit{P} \quad = \quad (\mathit{E} \Longrightarrow
[\mathit{S}] P )\land (\neg\mathit{E} \Longrightarrow [\mathit{T}]
\mathit{P})$$.

Nessa interpretação, se $\mathit{E}$ for verdadeiro a substituição $\mathit{S}$ é
aplicada ao predicado $\mathit{P}$. Caso contrário, a substituição $\mathit{T}$ é
aplicada ao predicado $\mathit{P}$.

Um exemplo simples da utilização dessa substituição pode ser visto na
figura~\ref{fig:query_task}. Nela, a expressão $\mathit{task} \in
\mathit{TASK}$ é primeiramente analisada para decidir qual substituição simples deve ser
executada. Caso o resultado da expressão seja afirmativo $\mathit{ans} :=
\mathit{yes}$ é executada e, caso a expressão seja negativa, $\mathit{ans} :=
\mathit{no}$ é executada.
 
\subsubsection{Substituição não determinística $\ANY$}

As substituições vistas até agora seguem uma metodologia determinística, ou seja,
são substituições que possuem um comportamento previsível, levam a apenas um
resultado final pré-determinado. Entretanto, as máquinas abstratas em B são
utilizadas para fazer especificações iniciais de sistemas ou componentes e, na
maioria das vezes, no início de uma especificação, o comportamento do sistema não
é totalmente conhecido. Assim, para especificar o indeterminismo inicial de um
sistema, a notação de máquina abstrata disponibiliza um tipo especial de
substituições denominadas de substituições não determinísticas.

Substituições não determinísticas são substituições que introduzem escolhas
aleatórias no corpo da operação, levando-a a um conjunto de estados finais
diferentes a cada execução. Em uma substituição não determinística, a
especificação define apenas o conjunto sobre o qual deve ser feita a escolha,
abstraindo assim informações de como tal escolha deve ser realizada. Em outras
palavras, em uma substituição não determinística existe um conjunto de estados
finais possíveis, que podem ser alcançados a cada execução da substituição.

Uma substituição não determinística definida na AMN é a substituição $\ANY$.
Essa substituição possui o seguinte formato:
  
$$\ANY\quad\mathit{x}\quad\WHERE \quad\mathit{Q}\quad\THEN\quad\mathit{T}\quad\END$$

Através da definição acima, percebe-se que a substituição $\ANY$ é formada por
três elementos:

\begin{description}
\item[$\mathit{x}$] é uma lista de variáveis que serão utilizadas no
corpo da substituição. Para essa variáveis serão atribuidos
valores abstratos delimitados pelo o predicado $\mathit{Q}$;
\item[$\mathit{Q}$] são os predicados que delimitam o conjunto de opções para as
variáveis $\mathit{x}$. Nessa parte, as variáveis $\mathit{x}$ devem
obrigatoriamente serem tipificadas; e
\item[$\mathit{T}$] é uma substituição que utiliza-se das variáveis
$\mathit{x}$ para atualizar estados ou atribuir valores para os parâmetros de
saída da operação.
\end{description}

Um exemplo da substituição $\ANY$ pode ser visto na operação da
figura~\ref{fig:random_create}. Nela, uma tarefa é aleatoriamente adicionada na
máquina $\mathit{Kernel}$. Para isso, primeiramente a variável $\mathit{task}$ é
criada para representar um valor aleatório. Em seguida, o tipo e a restrição
sobre $\mathit{task}$ são definidos, conjunto da escolha aleatória. Por último, a
variável $\mathit{task}$ é adicionada ao conjunto $\mathit{tasks}$. Assim, um
comportamento não determinístico é atribuído à operação, pois para cada execução
da operação a variável $\mathit{task}$ pode assumir um valor aleatório de um
conjunto definido.
 

\begin{figure}[!ht]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
\mathit{random\_create}=\\
\PRE\\
\quad\card(\mathit{tasks})<9 \\
\THEN\\
\quad \ANY \\
\quad\quad \mathit{task}\\
\quad \WHERE \\
\quad\quad \mathit{task}\in \mathit{TASK} \land\\
\quad\quad \mathit{task} \not\in \mathit{tasks}\\
\quad \THEN\\
\quad\quad \mathit{tasks}:=\{\mathit{tasks}\}\cap \mathit{task}\\
\quad \END\\


\END
\end{array}
\end{array}
$$
\end{small}
\caption{Operação que cria uma tarefa aleatória na máquina
$\mathit{Kernel}$}
\label{fig:random_create}
\end{figure}

Uma definição para a substituição $\ANY$ seria: 

$$\ANY\quad\mathit{x}\quad\WHERE
\quad\mathit{Q}\quad\THEN\quad\mathit{T}\quad\END \Rightarrow \forall
\mathit{x}.(\mathit{Q} \Rightarrow [\mathit{T}]\mathit{P})$$

Indicando que, para todo valor que for escolhido para o conjunto de variável
$\mathit{x}$ que satisfaça $\mathit{Q}$, as substituições $\mathit{T}$ devem ser
aplicadas ao predicado $\mathit{P}$.

\section{Obrigações de Prova}\label{subsec:obrigacao_de_prova}

Após a criação de uma máquina abstrata utilizando o método B, ela deve ser
avaliada estaticamente para saber se a mesma é coerente e passível de
implementação. Para realizar tal avaliação, o método B dispõe de um conjunto de
obrigações de prova, que são expressões lógicas geradas a partir de uma
especificação em B.

Resumidamente, a análise estática de uma máquina abstrata, através das obrigações
de prova, avalia primeiramente se a máquina possui estados válidos, ou seja, se
pelo menos uma combinação dos estados é alcançada pela máquina. Caso a máquina
possua estados válidos, é avaliado se estes são alcançados na inicialização da
máquina e ao final de cada operação. Com isso, as principais obrigações de
prova gerada em uma máquina abstrata são: consistência do invariante, Obrigação
de prova da inicialização e obrigação de prova das operações. A seguir, tem-se
em maior detalhe cada uma dessas obrigações de prova e como elas são geradas.

\subsection{Consistência do Invariante}

Nessa obrigação de prova, é analisado se o invariante da máquina possui pelo
menos uma combinação que todas variáveis tenham valores válidos, ou seja, a
máquina possui pelo menos um estado válido. Essa obrigação de prova é definida da
seguinte maneira:
 
$$\exists\mathit{v}.\mathit{I}$$

Onde $\mathit{v}$ indica o vetor de todos as variáveis da máquina e $\mathit{I}$
representa o invariante da máquina. Com isso, a definição acima pode ser
entendida como: deve existir pelo menos um valor para o vetor de variáveis
$\mathit{v}$ que satisfaça o invariante $\mathit{I}$.

Um exemplo da aplicação dessa obrigação de prova na máquina da
figura~\ref{fig:maquina_kernel} seria: 

$$\exists\mathit{tasks}.(\mathit{tasks} \in \mathit{TASK} \cap
\card(\mathit{tasks})\leq 10)$$

O que pode ser provado como verdadeiro instanciando $\mathit{tasks}$ com
$\emptyset $.


\subsection{Obrigação de prova da inicialização}

Outra obrigação de prova necessária na analise estática da máquina abstrata é a
obrigação de prova da inicialização. Nela, analisa-se se os estados iniciais da
máquina satisfazem seu invariante. Isso significa verificar se os estados
iniciais da máquina são estados válidos. Assim, essa obrigação de prova é
definida da seguinte maneira:

$$[\mathit{T}]\mathit{I}$$

Nela, $[\mathit{T}]$ indica as substituições realizadas na inicialização da
máquina e $\mathit{I}$ indica as restrições definidas no invariante. Com isso, a
obrigação de prova da inicialização da máquina da figura~\ref{fig:maquina_kernel}
é:

$$[\mathit{task}:= \emptyset] (\mathit{tasks} \in \pow(\mathit{TASK}) \cap
\card(\mathit{tasks})\leq 10) \quad \Rightarrow\quad \emptyset \in
\pow(\mathit{TASK}) \cap \card(\emptyset)\leq 10$$

O que pode ser facilmente provado como válido.

\subsection{Obrigação de prova das operações}

Na obrigação de prova das operações deve ser analisado se, quando satisfeita a
sua pré-condição, a execução da operação, a partir de um estado válido, levará a
máquina a um estado válido. Assim a definição dessa obrigação de prova pode ser
vista da seguinte maneira:

$$\mathit{I} \land \mathit{P} \Rightarrow [\mathit{S}]I$$

Na definição acima, $\mathit{I}$ representa o invariante da máquina,
$\mathit{P}$ representa a pré-condição da operação analisada e $\mathit{S}$ indica as
substituições realizadas no corpo da operação. Uma explicação mais precisa
dessa definição seria: quando a máquina estiver em um estado válido e a
pré-condição da operação for satisfeita, a execução da operação deve manter a
máquina em um estado válido. Nota-se com isso, que esta obrigação de prova não
é necessária nas operações que não alteram o estado da máquina, chamadas de
operações de consulta, como a da figura~\ref{fig:query_task}, pois, nessas
operações, apenas o valor do parâmetro de retorno é alterado.

Um exemplo de uma obrigação de prova da operação $\mathit{add\_task}$ da máquina
da figura~\ref{fig:task_states} pode ser visto a seguir:

$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
(\mathit{tasks} \in \pow(\mathit{TASK}) \land
\card(\mathit{tasks})\leq 10) \land 
(\mathit{task}\in \mathit{TASK} \land \mathit{task}\not\in \mathit{tasks})
\Rightarrow \\
([\mathit{tasks}:=\mathit{task}\cap\mathit{task}]((\mathit{tasks}
\in \pow(\mathit{TASK}) \cap \card(\mathit{tasks})\leq 10))))
\end{array}
\end{array}
$$
 

\section{Refinamento}
\label{sec:refinamento}
A linguagem abstrata demonstrada até agora é usada principalmente para criar uma
modelagem funcional de sistemas e componentes. Nela, o principal objetivo é
descrever o comportamento do sistema sem se preocupar com detalhes de como tal
comportamento será implementado ou de como os dados serão manipuladas pelo
computador. Entretanto, para realizar uma modelagem mais concreta e passível de
implementação, é necessário que notações matemáticas abstratas utilizadas na
modelagem do sistema, como conjuntos e substituições não determinística, sejam
descritas de forma mais concreta, o que é possível através do refinamento. Além
disso, o refinamento pode ser usado para construir um modelo abstrato de forma
incremental com da adição sucessivas de formalizaçoes dos
requisitos\cite{schneider06}.

Através da técnica de refinamento, o método B possibilita um desenvolvimento
gradativo do sistema. Nele, um sistema é especificado em estágios que vão da
modelagem abstrata até um nível algoritmo denominado de implementação. Entre
esses níveis de abstração existem modelos intermediários chamados de
refinamentos, que combina especificações abstratas com detalhes de
implementação.

Mais precisamente, refinamentos são decisões de projeto, nas quais estruturas
abstratas são detalhadas em um nível mais concreto. Com isso, um refinamento deve
obrigatoriamente estar ligado a um modelo abstrato anterior e possuir seu
comportamento delimitado pelo modelo a qual está relacionado. Para garantir que
essa relação entre módulo seja feita de forma coerente, existem mecanismos de
análise estática denominados obrigações de prova do refinamento, os quais serão
detalhados na seção~\ref{subsec:obrigacao_de_prova_refinamento}.

A construção de um refinamento é muito parecida com a construção de uma máquina
abstrata. Ele, assim como a máquina abstrata, é dividido em seções onde são
especificadas as informações do sistema. Um refinamento possui basicamente as
mesmas seções de uma máquina abstrata, a diferença está nas seções, $\REFINEMENT$
e $\REFINES$, onde são colocados respectivamente o nome do refinamento e o módulo
que será refinado.

Como ocorreu na seção de máquina abstrata \ref{sec:maquina_abstrata}, para um 
melhor entendimento, a especificação de um refinamento será dividida basicamente 
em duas partes principais: refinamento do estado da máquina abstrata e 
refinamento das operações da máquina abstrata. Em seguida, tem-se o delineamento
dessas duas partes principais.

\subsection{Refinamento do Estado}

No refinamento de dados, como é reconhecido o refinamento do estado, tem-se o
objetivo de especificar o estado de uma máquina em uma forma mais concreta, ou
seja, mais próxima à utilizada pelo computador. Para isso, estruturas abstratas,
como conjuntos e relações, são substituídas por mecanismo mais implementáveis
como vetores e seqüências.

Como foi dito anteriormente, um refinamento necessita estar relacionado com um
nível abstrato ligeiramente acima dele. No refinamento de dados, essa relação é
feita através de um mecanismo denominado \textit{relação de refinamento}. Assim,
a \textit{relação de refinamento} nada mais é do que conjunções lógicas que ligam
o estado do refinamento ao estado do módulo refinado por ele.

Um exemplo de refinamento de dados pode ser visto na
figura~\ref{fig:refinamento_kernelR}. Nela, é feito o refinamento da máquina
$\mathit{Kernel}$ (figura~\ref{fig:maquina_kernel}), a qual possui o estado
$\mathit{task}$ especificado como sendo um conjunto de tarefas. Entretanto,
conjuntos são representações abstratas de dados. Assim, no refinamento
$\mathit{KernelR}$, o estado $\mathit{task}$ é refinado por $\mathit{taskR}$,
uma seqüência de tarefas, estrutura mais concreta que um conjunto. A relação de
refinamento entre os dois estados é feita através da igualdade
$\mathbf{ran}(\mathit{tasks\_r})=\mathit{tasks}$.



\begin{figure}[!ht]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathbf{REFINEMENT}\\
\quad \mathit{Kernel\_r}\\
   
\REFINES\\
\quad \mathit{Kernel}\\
   
\VARIABLES\\
\quad \mathit{tasks\_r}\\
\end{array}

    

\begin{array}[t]{l}
\INVARIANT\\
\quad \mathit{tasks\_r} \in \mathbf{seq}(\mathit{TASK}) \land \\
\quad \mathbf{ran}(\mathit{tasks\_r})=\mathit{tasks}\\
    
\INITIALISATION\\
\quad \mathit{tasks\_r}:=[]\\
\end{array}


\begin{array}[t]{l}
\OPERATIONS\\
\mathit{task\_add}(\mathit{task}) = \\
\quad \BEGIN\\
\quad \quad \mathit{tasks\_r}:=\\
\quad\quad\quad\quad\mathit{task} \to \mathit{tasks\_r}\\
\quad \END\\
    
\END
\end{array}

\end{array}
$$
\end{small}
\caption{Refinamento da maquina abstrata de $\mathit{Kernel}$}
\label{fig:refinamento_kernelR}
\end{figure}


\subsection{Refinamento das Operações}

Após o refinamento do estado da máquina, é necessário especificar o refinamento
das suas operações. Nesse processo, as operações abstratas são reescrita de
forma mais concreta, podendo manipular os estados da máquina refinada e os novos
estados criados no refinamento. Além disso, as operações refinadas devem possuir
o mesmo comportamento das operações abstratas, garantindo assim uma coerência com
a especificação inicial.

As operações de um refinamento devem possuir a mesma assinatura das operações do
módulo relacionado à ele, ou seja, ter os mesmo nomes e parâmetros de entrada e
saída. Entretanto, nas operações de um refinamento, não é necessário a declaração
da pré condição ($\PRE$), uma vez que essa foi definida em um nível mais abstrato
e é suficiente para garantir que o tipo do parâmetro de entrada permaneça o
mesmo.

Um exemplo do refinamento de uma operação pode ser visto na operação
$\mathit{add\_task}$ do refinamento $\mathit{KernelR}$
(figura~\ref{fig:refinamento_kernelR}). Nela, percebe-se a ausência da
pré-condição e que a assinatura da operação permanece a mesma. A parte alterada
foi apenas o corpo da operação, que foi adaptada para trabalhar com o estado
$\mathit{taskR}$.


\subsection{Obrigação de prova do refinamento}
\label{subsec:obrigacao_de_prova_refinamento}
A análise estática que confere se um refinamento é consistente com o nível
abstrato acima dele é feita através de obrigações de prova e pode ser dividida em
duas partes, obrigação de prova da inicialização e obrigação de prova das
operações. Entretanto, na obrigação de prova das operações, são possíveis ainda
dois tratamentos diferentes, obrigações de prova para as operações sem parâmetros
de retorno e a obrigação de prova para as operações com parâmetros de retorno. A
seguir é demonstrado como é realizada cada uma dessas obrigações de prova do
refinamento.

\subsubsection{Obrigação de Prova da Inicialização}

Em geral, a inicialiazação da máquina abstrata, nomeada de $\mathit{T}$, e a
inicialização do refinamento, nomeada de  $\mathit{T1}$, possuem um conjunto de
execuções possíveis que levam a um conjunto de diferentes estados. Assim, em um
refinamento, é necessário que cada execução de $\mathit{T1}$ possua uma execução
correspondente em $\mathit{T}$. Em outras palavras, todo estado encontrado em
$\mathit{T1}$ deve possuir, via \textit{relação de refinamento}, denominada
$\mathit{J}$, um estado gerado por $\mathit{T}$.

A \textit{relação de refinamento} é um predicado entre variáveis abstratas e
variáveis de refinamento. Com isso, $\mathit{T}$ deve possuir pelo menos uma
transição que satisfaça esse predicado, ou seja, nem todas as transições de
$\mathit{T}$ levará $\mathit{J}$ a falsidade. Essa afirmativa pode ser traduzida
na expressão abaixo:

$$ \neg[\mathit{T}] \neg \mathit{J} $$

O predicado $\neg \mathit{J}$ indica que $\mathit{J}$ é falso e o predicado
$[\mathit{T}] \neg \mathit{J}$ representa que toda transformação de $\mathit{T}$
levará $\mathit{J}$ a um estado falso. Assim, a negação dessa afirmação
$\neg[\mathit{T}] \neg \mathit{J}$ indica quem existe uma transição de
$\mathit{T}$ que não levará $\mathit{J}$ à falsidade, ou seja, nem todas
transições de $\mathit{T}$ levará $\mathit{J}$ a falsidade.

Para encerrar a obrigação de prova da inicialização do refinamento, é
necessário que para toda transformação de $\mathit{T1}$ o predicado
$\neg[\mathit{T}] \neg \mathit{J}$ seja estabelecido. Essa afirmação pode ser
traduzida na expressão abaixo, a qual representa a obrigação de prova do
refinamento.

$$ [\mathit{T1}]\neg [\mathit{T}] \neg \mathit{J} $$

Um exemplo de uma obrigação de prova da inicialização do refinamento pode ser
visto entre as máquina $\mathit{Kernel}$ e a máquina $\mathit{KernelR}$. Nela, a
inicialização dos estados das duas máquinas gera a seguinte obrigação de prova:

$$
[\mathit{tasks\_r}:=[]]\neg[\mathit{tasks}:=\emptyset]\neg(\mathbf{ran}(\mathit{tasks\_r})=\mathit{tasks})
$$

\subsubsection{Obrigação de prova da operação sem parâmetro de retorno}
Geralmente, uma operação é definida como $\PRE \mathit{P} \THEN \mathit{S} \END$,
sendo o seu refinamento $\PRE \mathit{P1} \THEN \mathit{S1} \END$, onde ,na
maioria da vezes, $\mathit{P1}$ é verdadeiro. Com isso, do mesmo modo que na
inicialização, tem-se que as transições geradas por $\mathit{S1}$ devem estar
relacionadas com alguma transição de $\mathit{S}$, o que é definido pela
expressão abaixo:
 
$$[\mathit{S1}] \neg [\mathit{S}] \neg \mathit{J}$$

Entretanto, diferente da inicialização, a execução de uma operação deve levar em
consideração o estado da máquina anterior à sua execução. Assim, o estado da
máquina abstrata junto com o estado do seu refinamento devem ser estados válidos.
Uma relevante ligação entre esse estados é o invariante $\mathit{I}$ é a sua
relação de refinamento $\mathit{J}$. Além disso, para a correta execução da
operação, a pré-condição da mesma deve ser estabelecida. Assim, levando em
consideração que uma operação só pode ser executada corretamente quando a máquina
estiver em um estado válido e quando a sua pré-condição for estabelecida, a
obrigação de prova de uma operação é feita da seguinte forma:

$$\mathit{I} \land \mathit{J} \land \mathit{P} \Rightarrow [\mathit{S1}] \neg
[\mathit{S}] \neg \mathit{J}$$

Por exemplo, a obrigação de prova do refinamento da operação $\mathit{add\_task}$
da máquina $\mathit{Kernel}$ é :


$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
(\mathit{tasks} \in \pow(\mathit{TASK}) \land \card(\mathit{tasks})\leq10)\land \\ 
\mathit{tasks\_r})=\mathit{tasks}  \land \\
\mathit{task}\in \mathit{TASK} \land \\
\mathit{task}\not\in \mathit{tasks} \land\\
\card(\mathit{tasks})<10 \Rightarrow 
[\mathit{tasks}:=\mathit{tasks}\cup \{\mathit{task}\}] \\
\neg[\mathit{tasks\_r}:= \mathit{task} \to \mathit{tasks\_r}] \\
\neg (\mathit{tasks\_r})=\mathit{tasks})
\end{array}
\end{array}
$$

\subsubsection{Obrigação de prova da operação com parâmetro de saída}

No refinamento de uma operação com saídas, cada saída do refinamento da operação
deve estar ligada a uma saída da operação refinada, sendo necessário assim que a
operação do refinamento tenha a mesma quantidade de parâmetro de saída da
operação refinada.  Além disso, renomeando $\mathit{out'}$ como o conjunto de
parâmetros de saída do refinamento e deixando $\mathit{out}$ como o conjunto
dos parâmetros de saída da operação refinada, cada valor de $\mathit{out'}$ deve
possuir um correspondente em $\mathit{out}$. Em outra palavra, cada execução de
$\mathit{S1}$ deve encontrar uma execução $\mathit{S}$, na qual $\mathit{out'}$
produzido por $\mathit{S1}$ seja igual ao $\mathit{out}$ produzido por
$\mathit{S}$.

Além da ligação entre os parâmetros de saída, no refinamento de uma operação com
retorno, devem-se obedecer todas as restrições impostas no refinamento das
operações sem parâmetro de saída, ficando obrigação de prova para as operações
com retorno da seguinte forma:

$$\mathit{I} \land \mathit{J} \land \mathit{P} \Rightarrow
\mathit{S1}[\mathit{out'}/\mathit{out}] \neg \mathit{S} \neg (\mathit{J} \land
\mathit{out'} = \mathit{out})$$

Nela, $\mathit{S1}[\mathit{out'} / \mathit{out}]$ significa que, nas atribuições
de $\mathit{S1}$, cada ocorrência de $\mathit{out}$ deve ser substituída por
$\mathit{out'}$ e, antes dessa substuição, a máquina deve possuir um estado
válido e sua pré-condição deve ser alcançada, $\mathit{I} \land \mathit{J} \land
\mathit{P}$. As demais verificações são similares à obrigações de prova das
operações sem parâmetros de saída.



%\begin{itemize}
%  \item Explicar o que é o método B
%  \item Explicar a base teórica de B (AMN e as substituições)
%  \item Explicar como é especificado um sistema em B (como é criado um módulo)
%  \item Falar das obrigações de prova
%  \item Falar dos mecânismo de composição e refinamento
%  \item Dizer que o refinamento pode chegar em um nível concreto que pode ser
%  sintetizado para algumas linguagens de programação.
%  \item Falar do uso de ferramentas
%  \item Falar do projeto B2ASM
%\end{itemize}

\chapter{Primeiro passo da Modelagem}\label{cap:primeiros_passos}

Toda longa caminhada começa com o primeiro passo. Como primeiro passo desse
trabalho, foi desenvolvida, de forma planejada, uma modelagem funcional do
FreeRTOS, na qual apenas alguns de seus requisitos foram especificados. Para o
planejamento dessa modelagem, levaram-se em consideração principalmente as
técnicas de modularização e desenvolvimento incremental, proporcionadas pelo
método B, as quais estão descritas a seguir:

\begin{enumerate}
\item Parte dos requisitos funcionais do sistema podem ser abstraídos em sua
modelagem inicial. Assim, tais requisitos são tratados posteriormente através de
refinamentos horizontais ou extensões da especificação, o que proporciona uma
especificação incremental do sistema. O planejamento incremental dessa
especificação será explicado nas seções~\ref{sec:model_task} e
~\ref{sec:model_queue}.
\item Quando os requisitos do sistema não apresentarem dependências entre si,
eles podem ser especificados em diferentes módulos. Esses módulos comunicam-se
entre si utilizando os mecanismos de composição proporcionados pelo método B
(visão, inclusão, etc). A divisão da especificação em módulos será detalhada
na seção~\ref{sec:modelagem}.
\end{enumerate}

Sabe-se, através do capítulo~\ref{cap:freertos}, que as principais entidades do
FreeRTOS são tarefas, fila de mensagens, co-rotinas, semáforos, mutex e
escalonador. Além disso, sabe-se também que semáforo e mutex são estruturas
baseadas na entidade fila de mensagens, sendo esta necessária em qualquer
modelagem inicial. Assim, nesse primeiro passo, devido às suas utilidades, as
estruturas escolhidas para serem formalizadas, junto com algumas de suas
funcionalidades, foram: tarefa, fila de mensagens e escalonador\footnote{As
funcionalidades e propriedades do escalonador serão tratadas dentro da entidade
tarefa }.


\section{Tarefa}\label{sec:model_task}
Nesse ponta pé inicial, para tornar-se possível a criação da modelagem funcional,
muitas propriedades da entidade tarefa foram abstraídas. Resumidamente, apenas a
propriedade de estado de uma tarefa foi formalizada inicialmente. Através dessa
formalização, requisitos importantes do sistema poderam ser especificados, são
eles: somente uma tarefa deve estar em execução em um terminado instante e uma
tarefa só pode possuir um estado ao mesmo tempo.

A especificação da entidade tarefa foi planejada de forma incremental.
Previamente, foram criados os estados necessários para modelar tal entidade no
nível de abstração sugerido. Após isso, algumas das funcionalidades do sistema,
relacionadas a essa entidade, foram formalizadas a cada etapa de criação do
modelo. Ao final, as seguintes funcionalidades foram abrangidas de forma abstrata
por essa especificação inicial:

\begin{itemize}
  \item Criação de tarefas: \textit{xTaskHandle}, \textit{xTaskCreate},
  \textit{vTaskDelete}.
  \item Controle de tarefas:  \textit{vTaskDelay}, \textit{vTaskDelayUntil},
  \textit{uxTaskPriorityGet}, \textit{vTaskPrioritySet}, \textit{vTaskSuspend},
  \textit{vTaskResume}.
  \item Utilitários de tarefas:\textit{xTaskGetCurrentTaskHandle},
  \textit{uxTaskGetNumberOfTasks},
  \textit{xTaskGetTickCount},
  \textit{xTaskGetSchedulerState}.
  \item Controle do escalonador: \textit{vTaskStartScheduler},
  \textit{vTaskEndScheduler}, \textit{vTaskSuspendAll},
  \textit{xTaskResumeAll}. 
\end{itemize}
 
\section{Fila de mensagens}\label{sec:model_queue}
 
Para a entidade fila de mensagens, a principal propriedade especificada foi a
quantidade de mensagens que esta pode armazenar. Como ocorreu com a entidade
Tarefa, a formalização dessa entidade, junto com suas funcionalidades, foi
distribuída entre as várias etapas de desenvolvimento da modelagem inicial. Com
essa especificação, os seguintes requisitos de sistemas foram abrangidos pela
modelagem: bloquear a tarefa que tentar enviar uma mensagem para uma fila cheia e
bloquear a tarefa que tentar receber uma mensagem de uma fila vazia. As
funcionalidades relacionadas à fila de mensagens tratadas nessa especificação
foram: \textit{xQueueCreate}, \textit{vQueueDelete}, \textit{xQueueSend},
\textit{xQueueSendToBack}, \textit{xQueueSendToFront}, \textit{xQueueReceive},
\textit{xQueuePeek}.

\section{A modelagem funcional}\label{sec:modelagem}
A modelagem discutida nas seções anteriores foi construída e verifica utilizando
a ferramenta AtelierB 4.0\cite{clearsy09}. Nessa modelagem, foram especificadas
três entidades básicas do sistema: tarefa, fila de mensagens e escalonador. Tal
especificação foi estruturada através de sete módulos, os quais serão explicados
a seguir:

\begin{description}
  \item{\textbf{Módulo Config:}} Nesse módulo foram tratadas as configurações do
  comportamento do sistema. Por exemplo, a prioridade máxima que uma tarefa pode
  possuir é um parâmetro de configuração desse módulo.
  \item{\textbf{Módulo Types:}} Esse módulo é responsável por definir os tipos
  utilizados na especificação do FreeRTOS. Um exemplo de um tipo especificado
  nesse módulo é a prioridade de uma tarefa, que só pode assumir valores de um
  subconjunto finito dos naturais.
  \item{\textbf{Módulo Task:}} Nesse módulo são definidos os estados e operações
  responsáveis por formalizar a entidade tarefa.
  \item{\textbf{Módulo Queue:}} Esse módulo é similar ao módulo Task, só que
  nele a entidade especificada é a fila de mensagens.
  \item{\textbf{Módulo Scheduler:}} Esse módulo simplesmente mantém e manipula o
  estado do escalonador.
  \item{\textbf{Módulo FreeRTOSBasic:}} Esse módulo funciona como uma camada
  abstrata entre o módulo $\mathit{FreeRTOS}$ e os demais módulos básicos. Nele,
  as operações implementadas pelos módulos $\mathit{Task}$, $\mathit{Queue}$ e
  $\mathit{Scheduler}$ são agrupadas em funções mais abstratas, que servem como
  base para especificar as funcionalidades do $\mathit{FreeRTOS}$.
  \item{\textbf{Módulo FreeRTOS:}} Finalmente, no Módulo $\mathit{FreeRTOS}$ são
  especificadas as funcionalidades das bibliotecas do FreeRTOS.
\end{description}

A organização desses módulos pode ser vista na figura~\ref{fig:arquitetura}.
Nela, resumidamente os módulos inferiores servem de base para a especificação dos
módulos superiores, restando os módulos \textit{Config} e \textit{Types}, que
servem de apoio para toda a especificação. Nas seções seguintes tem-se em
detalhe como foi o desenvolvimento dessa especificação inicial.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.6]{../fig/class_diagram.jpg}
\caption{Esbouço da arquitetura da especificação}
\label{fig:arquitetura}
\end{figure}

\subsection{Tarefa}
Para representar o elemento tarefa existem diversas abordagens, funções de
mapeamento, seqüências e conjuntos. A abordagem escolhida nesse trabalho inicial
foi a representação através de conjuntos, o que facilita a verificação da
especificação pelo provador de teoremas. Assim, a modelagem da entidade tarefa e
suas propriedades foram feitas de acordo figura~\ref{fig:task_state}. Nela, a
variável $\mathit{active}$ informa quando o sistema está ativo. A variável
$\mathit{task}$ armazena todas as tarefas criadas no sistema. Em seguida, as
variáveis $\mathit{ready}$, $\mathit{blocked}$, $\mathit{running}$ e
$\mathit{suspended}$ armazenam as tarefas dos estados EM EXECUÇÃO, PRONTA,
BLOQUEADA e SUSPENSA, respectivamente. Por fim, a variável $\mathit{idle}$
representa a tarefa ociosa.

Um exemplo do funcionamento da especificação da figura~\ref{fig:task_state} seria
o seguinte. Enquanto o sistema estiver inativo, o valor da variável
$\mathit{active}$ deve ser falso. As novas tarefas criadas no sistema serão
armazenadas na variável $\mathit{tasks}$ e na variável de seu respectivo estado,
exceto a tarefa ociosa que é armazenada em $\mathit{idle}$. Por fim, ao
iniciar-se a execução do sistema a variável $\mathit{active}$ receberá o valor
verdadeiro.

\begin{figure}[!ht]
\begin{footnotesize}
$$
\begin{array}{l}
  \VARIABLES \\
  \quad   \mathit{active}, \tasks, \blocked, \running, \ready, \suspended, \mathit{idle} \\
  \INVARIANT \\
  \quad \mathit{active} \in \BOOL \land \tasks \in \fin(\TASK) \land \running \in \TASK \land \mathit{idle} \in \TASK \\
  \quad \land \blocked \in \fin(\TASK) \land \ready \in \fin(\TASK) \land \suspended \in \fin(\TASK)
\end{array}
  $$
\end{footnotesize}
\caption{Representação de uma tarefa pela máquina $\mathit{Task}$}
\label{fig:task_state}
\end{figure}

Estendendo um pouco mais a especificação do módulo $\mathit{Task}$, tem-se, na
figura~\ref{fig:task_invariant}, a continuação do invariante da máquina. Nele,
propriedades importantes do sistema são especificadas. São elas: uma tarefa deve
possuir somente um estado em determinado momento; Enquanto o escalonador não
estiver ativado todas as tarefas estarão no estado pronto; quando o escalonador
estiver ativo a tarefa ociosa deve estar pronta ou em execução; sempre existirá
somente uma tarefa em execução.

\begin{figure}[!ht]
\begin{footnotesize}
$$
\begin{array}[t]{l}
  \quad \blocked \subseteq \tasks \land \ready \subseteq \tasks \land  \suspended \subseteq \tasks \land \\
  \quad \ready \cap \blocked = \emptyset \land \blocked \cap \suspended = \emptyset \land \suspended \cap \ready = \emptyset \land \\
\quad (\mathit{active} = \FALSE \Rightarrow \tasks = \ready) \land \\
  \quad (\mathit{active} = \TRUE \Rightarrow
    \begin{array}[t]{l}
      (\idle = \running \lor \idle \in \ready) \land \\
      \running \not\in (\blocked \cup \ready \cup \suspended) \land \\
      \tasks = \mathit{\{running\}} \cup \suspended \cup \blocked \cup \ready)
    \end{array}
\end{array}
$$
\end{footnotesize}
\caption{Continuação do invariante da máquina $\mathit{Task}$}
\label{fig:task_invariant}
\end{figure}

Em adição a essa especificação, no módulo $\mathit{Task}$, foram criadas
operações básicas para manipular as variáveis de estado. Assim, essas operações
servem como base para a modelagem das funcionalidades do FreeRTOS relacionadas
à entidade Tarefa. Ao total, foram criadas doze operações elementares, das quais
duas são apresentadas pelas figuras~\ref{fig:t_create}
e~\ref{fig:t_startScheduler}. As demais operações e suas obrigações de prova
podem ser consultadas no repositório do projeto\footnote{Página do
repositório do projeto: http://code.google.com/p/freertosb/}.

\begin{figure}[!htb]
\begin{footnotesize}
$$
\begin{array}[t]{ccc}
  \begin{array}[t]{l}
    \mathit{result} \longleftarrow \mathit{t\_create} (\mathit{priority}) = \\
    \PRE \\
    \quad \mathit{priority} \in \mathit{PRIORITY} \land \\ 
    \quad \mathit{active} = \mathit{FALSE}\\
    \THEN \\
    \quad \ANY \task \quad \WHERE\\
    \quad\quad \task \in \TASK \land \task \not\in \tasks
  \end{array}
 &&
  \begin{array}[t]{l}
    \quad \THEN \\    	    
    \quad\quad \tasks := \{ task \} \cup \tasks \parallel\\
    \quad\quad \ready := \{ task \} \cup \ready \parallel \\
    \quad\quad \mathit{result} := \task\\
    \quad \END\\      
    \END;\\
  \end{array}
\end{array}
$$
\end{footnotesize}
\caption{Especificação da operação $\mathit{t\_create}$}
\label{fig:t_create}
\end{figure}

Na figura~\ref{fig:t_create}, tem-se a operação $\mathit{t\_create}$, que é
responsável por criar um nova tarefa. Essa operação pode ser utilizada somente
quando o escalonador não estiver acionado. Seu parâmetro de entrada,
$\mathit{priority}$, indica a prioridade da tarefa que será criada. Entretanto,
esse parâmetro só será utilizado no refinamento da operação. Como retorno da
operação tem-se a tarefa criada.

\begin{figure}[!htb]
\begin{footnotesize}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
\mathit{t\_startScheduler} = \\
\PRE \\
\quad \mathit{active} = \mathit{FALSE} \\
\THEN \\
\quad \mathit{active} := \mathit{TRUE} \parallel \\
\quad \blocked, \suspended := \emptyset, \emptyset \parallel \\
\quad \ANY \mathit{idle\_task} \WHERE\\
\quad\quad \mathit{idle\_task} \in \TASK \land \\
\quad\quad \mathit{idle\_task} \not\in \tasks \\ 
\quad \THEN \\    	    
\end{array}
& &
\begin{array}[t]{l}
\quad\quad \tasks := \{ \mathit{idle\_task} \} \cup \tasks \parallel\\
\quad\quad \mathit{idle} := \mathit{idle\_task} \parallel \\
\quad\quad \ANY \task \WHERE \\
\quad\quad\quad \task \in \ready \cup \{ \mathit{idle\_task} \} \\
\quad\quad \THEN \\
\quad\quad\quad \running := \task \parallel\\
\quad\quad\quad \ready := (\ready \cup \{\mathit{idle\_task}\}) - \{ \task \}\\
\quad \quad \END\\      
\quad \END\\      
\END;
\end{array}
\end{array}
$$
\end{footnotesize}
\caption{Especificação da operação $\mathit{t\_startScheduler}$}
\label{fig:t_startScheduler}
\end{figure}

A segunda operação a ser explicada é a $\mathit{t\_startScheduler}$,
figura~\ref{fig:t_startScheduler}, responsável por iniciar o funcionamento do
sistema. Durante a execução dessa operação, a tarefa ociosa do sistema é criada e
o escalonador escolhe uma tarefa para entrar em execução. Observa-se que, devido
à prioridade ainda não ser tratada nessa especificação, a tarefa a ser executada
é escolhida de forma aleatória, ficando tal preocupação para o refinamento da
operação.

Um exemplo da especificação de uma funcionalidade do FreeRTOS pode ser visto na
figura~\ref{fig:xTaskCreate}. Nela, a funcionalidade $\mathit{xTaskCreate}$ é
demonstrada. O seu comportamento pode ocorrer de duas formas: ou uma nova tarefa
do sistema é criada e passada como retorno da função; ou nenhuma tarefa é criada
e uma mensagem de erro é retornada. Para criar uma nova tarefa, essa
funcionalidade utiliza-se da função $\mathit{t\_create}$ demonstrada na
figura~\ref{fig:t_create}.

\begin{figure}[!ht]
\begin{footnotesize}
  $$
  \begin{array}[t]{ccc}
    \begin{array}[t]{l}
      \mathit{result}, \mathit{handle} \longleftarrow \\ 
      \quad\quad\quad \mathit{xTaskCreate} (\begin{array}[t]{l}
        \mathit{code},\mathit{name},\\
        \mathit{stackSize}, \mathit{params}, \\
        \mathit{priority}) =
      \end{array} \\
      \PRE\\ 
      \quad \mathit{code} \in \mathit{TASK\_CODE} \land \\ 
      \quad \mathit{name} \in \mathit{NAME} \land \\ 
      \quad \mathit{stackSize} \in \mathit{NATURAL} \land \\  
      \quad \mathit{params} \subset \mathit{PARAMETER} \land \\ 
      \quad \mathit{priority} \in \mathit{PRIORITY} \land \\
      \quad \mathit{scheduler} = \mathit{NOT\_STARTED} \land \\
      \THEN
    \end{array}
    & &

    \begin{array}[t]{l}
      \quad \CHOICE\\ 
      \quad \quad \mathit{handle} \leftarrow \\
      \quad \quad\quad \quad\mathbf{t\_create} (\mathit{priority}) \parallel\\ 
      \quad \quad \mathit{result} := \mathit{pdPASS}\\
      \quad	\OR \\
      \quad \quad
      \mathit{result}:=\mathit{errMEMORY} \parallel \\ 
      \quad \quad 
      \mathit{handle} :\in \TASK \\
      \quad \END\\
      \END
    \end{array}

  \end{array}
  $$
\end{footnotesize}
\caption{Especificação da operação $\mathit{xTaskCreate}$}
\label{fig:xTaskCreate}
\end{figure}


\subsection{Fila de mensagens}
Nessa seção, será demonstrada parte da especificação relacionada ao elemento fila
de mensagens. Essa especificação é feita através da máquina $\mathit{Queue}$.
Nela, são tratadas principalmente as propriedades de tamanho de uma fila e
conjunto de tarefas bloqueadas por uma fila. Aqui, os conjuntos também foram
escolhidos como técnica para formalização dessas propriedades.

A especificação do estado da máquina $\mathit{Queue}$ pode ser visto na
figura~\ref{fig:module_queue}. Nela, foram criadas as variáveis
$\mathit{queues}$, $\mathit{items}$, $\mathit{receiving}$, e $\mathit{sending}$.
A variável $\mathit{queues}$ é responsável por armazenar todas as filas de
mensagens criadas pelo sistema. A variável $\mathit{items}$ relaciona uma fila
de mensagens a um conjunto de itens (mensagens). Por último, as variáveis
$\mathit{receiving}$ e $\mathit{sending}$ relacionam respectivamente uma fila de
mensagens a um conjunto de tarefas bloqueadas aguardando a chegada de uma
mensagem na fila (fila vazia) e um conjunto de tarefas bloqueadas aguardando
para enviar uma mensagem para a fila (fila cheia).

\begin{figure}
\begin{footnotesize}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
\VARIABLES \\
\quad \mathit{queues},\\
\quad \mathit{items},\\
\quad \mathit{receiving},\\
\quad \mathit{sending}
\end{array}
&
&
\begin{array}[t]{l}
\INVARIANT \\
\quad \mathit{queues} \in \pow(\mathit{QUEUE}) \land \\
\quad \mathit{items} \in \mathit{QUEUE} \rightarrow\mkern-22mu+ \pow (\mathit{ITEM})\land  \dom(\mathit{items}) = \mathit{queues} \land \\
\quad \mathit{receiving} \in \mathit{QUEUE} \rightarrow\mkern-22mu+
\pow(\TASK) \land \dom(\mathit{receiving}) = \mathit{queues} \land \\
\quad \mathit{sending} \in \mathit{QUEUE}\rightarrow\mkern-22mu+
\pow(\TASK) \land  \dom(\mathit{sending}) = \mathit{queues} \\
\end{array}
\end{array}
$$
\end{footnotesize}
\caption{Estado da máquina $\mathit{Queue}$}
\label{fig:module_queue}
\end{figure}

Na máquina $\textit{Queue}$, também foram criadas operações básicas para
manipular os estados anteriormente descritos. Ao total seis operações foram desenvolvidas,
entre elas a operação $\mathit{sendItem}$ responsável por adicionar um item em
uma fila de mensagens, demonstrada através da  figura~\ref{fig:sendIten}. Nela,
os parâmetros de entrada $\mathit{queue}$, $\mathit{item}$ e $\mathit{task}$
representam respectivamente a fila que será manipulada, o item que será
adicionado à fila e a tarefa que será retirada do conjunto de tarefas bloqueadas
aguardando a chegada de uma mensagem na fila. Por fim, devido aos conjuntos não
possuírem posições, o parâmetro $\mathit{pos}$, que representa a posição de
entrada do item na fila (final ou começo), é declarado mas não é utilizado.

\begin{figure}
\begin{footnotesize}
$$
\begin{array}[t]{cc}
\begin{array}[t]{l}
\mathit{sendItem}( \mathit{queue}, \mathit{item}, \task,\mathit{pos}) =\\
\PRE\\ 
\quad  \mathit{queue} \in \mathit{queues} \land \\ 
\quad  \mathit{item} \in \mathit{ITEM} \land \\ 
\quad  \task \in \TASK \land \\ 
\quad  \mathit{pos} \in \mathit{COPY\_POSITION} \land\\    
\quad  \task \in \mathit{receiving}(\mathit{queue})\\
\end{array}
\hspace*{5mm}
\begin{array}[t]{l}
\THEN \\
\quad  \mathit{items}(\mathit{queue}):=\\
\quad\quad\mathit{items}(\mathit{queue}) \cup
\{\mathit{item}\}\parallel\\ 
\quad  \mathit{receiving}(\mathit{queue}) := \\
\quad\quad \mathit{receiving}(\mathit{queue}) - \{\task\} \\
\END
\end{array}
\end{array}
$$
\end{footnotesize}
\caption{Especificação da função $\mathit{sendIten}$}
\label{fig:sendIten}
\end{figure}

Prosseguindo na especificação, percebeu-se que as funcionalidades relacionadas à
entidade fila de mensagens, possuem um comportamento muito parecido. Além disso,
para a especificação dessas funcionalidades é necessário ter-se uma ligação com
a entidade tarefa e fila de mensagens, pois uma fila é capaz de bloquear e
desbloquear uma tarefa.

Nesse contexto, para especificar os comportamentos comuns das funcionalidades da
fila de mensagens e fazer a ligação dessas funcionalidades com a entidade tarefa,
foram criadas, na máquina $\mathit{FreeRTOSBasic}$, as seguinte funções
intermediárias: $\mathit{xQueueGenericSend}$ e $\mathit{xQueueGenericReceived}$.
Essas funções são responsáveis respectivamente por: enviar um elemento para fila
ou bloquear a tarefa remetente se a fila estiver vazia; receber um elemento da
fila ou bloquear a tarefa receptora se a fila estiver cheia. A seguir, tem-se a
especificação da operação $\mathit{xQueueGenericSend}$, ficando, a cargo do
leitor interessado, verificar a especificação da operação
$\mathit{xQueueGenericReceived}$ no repositório do projeto.

Na função $\mathit{xQueueGenericSend}$, apresentada na
figura~\ref{fig:xQueueGenericSend}, tem-se como parâmetros de entrada: a fila
onde será enviada a mensagem, $\mathit{q}$ ; o item que será enviado para a fila,
$\mathit{i}$ ; a quantidade de tempo que a tarefa remetente poderá ficar
esperando pela fila, $\mathit{wait}$; e a posição que o item será colocado na
fila, $\mathit{pos}$. Essa função possui dois comportamentos possíveis. No
primeiro, representando uma fila cheia, ela bloqueia a tarefa remetente, através
da operação $\mathit{t\_delayTask}$, e, com o método
$\mathit{q\_insertTaskWaitingToSend}$, coloca-a no conjunto de tarefas que
esperam para enviar um item para fila. No segundo, o item é enviado para a fila,
através do método $\mathit{q\_sendItem}$, e uma tarefa que aguarda por um item da
fila é desbloqueada com a operação $\mathit{t\_unblock}$.

\begin{figure}
\begin{footnotesize}
  $$
  \begin{array}[t]{cc}
    \begin{array}[t]{l}
      res \leftarrow \mathit{xQueueGenericSend}(q,i,wait,pos) = \\ 
      \quad \PRE \\
      \quad\quad \mathit{q} \in \mathit{queues} \land i \in \mathit{ITEM} \land  \mathit{wait} \in \mathit{TICK} \land \\
      \quad\quad \mathit{pos} \in \mathit{COPY\_POSITION} \land \\
      \quad \quad \mathit{active} = \mathit{TRUE} \land \running \neq \mathit{idle} \\
      \quad \THEN \\
      \quad \quad \CHOICE \\
      \quad \quad \quad \IF \mathit{wait} > 0 \THEN \\
      \quad \quad \quad \quad \mathit{q\_insertTaskWaitingToSend}(\mathit{q}, \running) \parallel \\
      \quad \quad \quad \quad \mathit{t\_delayTask}(\mathit{wait}) \parallel \\
      \quad \quad \quad \quad \mathit{res} := \mathit{pdTRUE} \\
      \quad \quad \quad \ELSE \\
      \quad \quad \quad \quad \mathit{res} := \mathit{errQUEUE\_FULL} \\
      \quad \quad \quad \END \\
    \end{array}
    &
    \begin{array}[t]{l}
      \quad \OR \\
      \quad \quad \ANY t \WHERE \\
      \quad \quad \quad t \in \TASK \land \\
      \quad \quad \quad t \in \blocked \land \\ 
      \quad \quad \quad t \in \mathit{receiving}(\mathit{q}) \\
      \quad \quad \THEN \\
      \quad \quad \quad \mathit{q\_sendItem}(q,i,t,\mathit{pos}) \parallel \\
      \quad \quad \quad \mathit{t\_unblock}(t) \parallel \\
      \quad \quad \quad \mathit{res} := \mathit{pdPASS} \\
      \quad \quad \END \\
      \quad \END \\
      \END
    \end{array}
  \end{array}
  $$
\end{footnotesize}
\caption{Especificação da função $\mathit{xQueueGenericSend}$}
\label{fig:xQueueGenericSend}
\end{figure}

Finalmente, para finalizar essa especificação inicial, a funcionalidade de enviar
um item para a fila de mensagens, modelada na máquina $\mathit{FreeRTOS}$, é
apresentada pela figura~\ref{fig:xQueueSend}. Nela, basicamente, ocorre uma
chamada à função $\mathit{xQueueGenericSend}$, da
figura~\ref{fig:xQueueGenericSend}.

\begin{figure}
\begin{footnotesize}
  $$
  \begin{array}[t]{c}
    \begin{array}[t]{l}  
      \mathit{res} \longleftarrow \mathit{xQueueSend}(\mathit{q},
      \mathit{i}, \mathit{w})=\\
      \PRE \\
      \quad \mathit{q}\in \mathit{queues}  \land \mathit{i} \in \mathit{ITEM}  \land \mathit{w} \in \mathit{TICK} \land\\
      \quad \mathit{active} = TRUE \land \running \neq \mathit{idle} \\
      \THEN \\
      \quad \mathit{res} \gets \mathit{xQueueGenericSend}(\mathit{q}, \mathit{i}, \mathit{w}, \mathit{queueSEND\_TO\_BACK})\\ 
      \quad \END \\
      \END
    \end{array}
  \end{array}
  $$
\end{footnotesize}
\caption{Especificação da função $\mathit{xQueueSend}$}
\label{fig:xQueueSend}
\end{figure}

\section{Refiando a especificação inicial}
Para tratar dos requisitos do FreeRTOS ligados à prioridade de uma tarefa, é
necessário acrescentar-se tal característica à modelagem inicial. Esse acréscimo
está relacionado principalmente à máquina $\mathit{Task}$ e pode ser feito de
duas formas: escrevendo uma nova versão para essa máquina ou refinando-a. Aqui,
a última forma foi escolhida como a mais adequada.

O refinamento da máquina $\mathit{Task}$ é feito pelo módulo $\mathit{Task\_r}$,
cujas variáveis e invariantes são exibidos na figura~\ref{fig:task_r_state}.
Nela, o tipo $\PRIORITY$ representa a prioridade que uma tarefa pode assumir e a
variável $\mathit{prio}$ representa a ligação de uma tarefa a sua prioridade. Com
esse refinamento, foi possível, através do seu invariante, especificar o seguinte
requisito: uma vez inicializado o escalonador, a tarefa em execução deve ter
prioridade maior ou igual a das tarefas de estado PRONTA.

\begin{figure}
\begin{footnotesize}
$$
\begin{array}[t]{cc}
\begin{array}[t]{l}
\CONSTANTS \\
\quad \mathit{MAX\_PRIO}, \mathit{IDLE\_P} \\
\PROPERTIES\\
\quad \mathit{PRIORITY} =  0..(\mathit{MAX\_PRIO-1}) \land \\
\quad \mathit{MAX\_PRIO} > 0 \land \mathit{IDLE\_P} = 0 \\
\VARIABLES \\
\quad \mathit{prio}\\
\end{array}
\begin{array}[t]{l}
\INVARIANT\\
\quad \mathit{prio} \in \TASK \pfun \mathit{PRIORITY} \land \\ 
\quad \dom(\mathit{prio})=\tasks \land \\
\quad (\mathit{active} = \mathit{TRUE} \Rightarrow \\
\quad \quad \mathit{prio}(\mathit{idle}) = \mathit{IDLE\_P} \land \\
\quad \quad \forall \mathit{t}.(\mathit{t} \in \ready \Rightarrow \mathit{prio}(t) \leq \mathit{prio}(\running)) \land\\
\quad \quad \forall \mathit{t}.(\mathit{t} \in \ready \Rightarrow \mathit{IDLE\_P} \leq \mathit{prio}(t)))
\end{array}
\end{array}
$$
\end{footnotesize}
\caption{Especificação do estado do módulo $\mathit{Task_r}$}
\label{fig:task_r_state}
\end{figure}

Feita as alterações necessárias para tratar a prioridade de uma tarefa, é
necessário agora refinar as operações da máquina $\mathit{Task}$. No entanto,
para facilitar e modularizar o refinamento dessas operações, foi criada
previamente a função auxiliar $\mathit{scheduler\_p}$, que recebe como entradas
um conjunto de tarefas e uma função que mapeia essas tarefas as suas prioridades.
Ao final, essa função auxiliar retorna a tarefa de maior prioridade. A
especificação de $\mathit{scheduler\_p}$ pode ser vista na
figura~\ref{fig:scheduler_p}.

\begin{figure}
\begin{footnotesize}
$$
\begin{array}[t]{l}
\CONSTANTS \\
\quad \mathit{schedule\_p} \\
\PROPERTIES \\
\quad \mathit{schedule\_p}: (\fin(\mathit{TASK}) \times (\mathit{TASK} \pfun \mathit{PRIORITY})) \pfun \fin(\mathit{TASK}) \land \\
\quad \mathit{schedule\_p} = \lambda (\mathit{tasks}, \mathit{prio}) \bullet \\
\quad \quad (\mathit{tasks} : \fin(\mathit{TASK}) \land \mathit{prio} : \mathit{TASK} \pfun \mathit{PRIORITY} \land
\mathit{tasks} \neq \emptyset \land \mathit{tasks} \subseteq \dom(\mathit{prio}) \\
\quad \quad \quad \mid \quad \mathit{tasks} \cap \mathit{prio}^{-1} (\max(\mathit{prio}\lbrack\mathit{tasks}\rbrack))))
\end{array}
$$
\end{footnotesize}
\caption{Especificação da função auxiliar $\mathit{schedule\_p}$}
\label{fig:scheduler_p}
\end{figure}

Finalmente, os refinamentos das operações previamente demonstradas,
$\mathit{t\_create}$ (figura~\ref{fig:t_create}) e
$\mathit{t\_startScheduler}$(figura~\ref{fig:t_startScheduler}), são exibidos,
respectivamente, pelas figuras~\ref{fig:t_create_refinament} e
\ref{fig:t_startScheduler_refinament}. Em $\mathit{t\_create}$, o parâmetro
$\mathit{priority}$ é agora utilizado para indicar a prioridade da tarefa criada.
Por fim, em $\mathit{t\_startScheduler}$, a tarefa ociosa é criada com uma
prioridade pré-definida e a escolha da tarefa que irá entrar em execução é feita
através da tarefa de maior prioridade entre as de estado pronto, utilizando a
função $\mathit{scheduler\_p}$.

\begin{figure}
\begin{footnotesize}
  $$
  	\begin{array}[t]{cc}
    \begin{array}[t]{l}
      \mathit{result} \longleftarrow \mathit{t\_create}(\mathit{priority}) = \\
      \PRE \\
      \quad \mathit{priority} \in \mathit{PRIORITY} \land \\ 
      \quad \running=\mathit{TASK\_NULL}\\
      \THEN \\
      \quad \ANY \quad \task \quad \WHERE \\
      \quad\quad \task \in \TASK \land \task \not\in \tasks
    \end{array}
    \begin{array}[t]{l}
      \quad \THEN \\    	    
      \quad\quad \tasks := \tasks \cup \{ task \} \parallel\\
      \quad\quad \mathit{prio}:= \mathit{prio} \cup
      \{\task\mapsto \mathit{priority}\}\parallel\\ 
      \quad\quad \ready := \ready \cup \{ \task \} \parallel \\ 
      \quad\quad \mathit{result} :=\task\\ 
      \quad \END\\      
      \END\\
    \end{array}
	\end{array}
  $$
\end{footnotesize}
\caption{Especificação do refinamento da operação $\mathit{t\_create}$}
\label{fig:t_create_refinament}
\end{figure}
\begin{figure}
\begin{footnotesize}
  $$
  \begin{array}[t]{cc}
    \begin{array}[t]{l}
      \mathit{t\_startScheduler} = \\
      \quad \BEGIN \\
      \quad \quad \mathit{active} := \mathit{TRUE} \parallel \\
      \quad \quad \blocked, \suspended := \emptyset, \emptyset \parallel \\
      \quad \quad \ANY \quad \mathit{i} \quad \WHERE \\
      \quad \quad \quad \mathit{i} \in \TASK \land \\ 
      \quad \quad \quad \mathit{i} \not \in \tasks \\
      \quad \quad \THEN \\
      \quad \quad  \tasks := \tasks \cup \{ \mathit{i} \} \parallel \\
      \quad \quad  \mathit{prio} := \mathit{prio} \cup \{ \mathit{i} \mapsto \mathit{IDLE\_P} \}\parallel \\
      \quad \quad \mathit{idle} := \mathit{i} \parallel
    \end{array}
    \begin{array}[t]{l}
      \quad \quad \ANY \quad t \quad \WHERE \\
      \quad \quad \quad t \in \TASK \land \\
      \quad \quad \quad (\ready = \emptyset \Rightarrow t = \mathit{i}) \land \\
      \quad \quad \quad (\ready \neq \emptyset \Rightarrow t \in \ready \land \\
      \quad \quad \quad \quad t \in \mathit{schedule\_p}(\ready, \mathit{prio}) \\
      \quad \quad \THEN \\
      \quad \quad \quad \running := t \parallel \\
      \quad \quad \quad \ready := (\ready \cup \{ \mathit{i} \}) - \{ t \} \\
      \quad \quad \END \\
      \quad \END \\
      \END
    \end{array}
  \end{array}
  $$
\end{footnotesize}
\caption{Especificação do refinamento da operação $\mathit{t\_startScheduler}$}
\label{fig:t_startScheduler_refinament}
\end{figure}


\chapter{Proposta}\label{cap:proposta}

O objetivo principal desse trabalho é especificar completamente o sistema
operacional de tempo real FreeRTOS. Entretanto, como foi demonstrado no
capítulo~\ref{cap:primeiros_passos}, parte dessa especificação já foi realizada.
Portanto, para atingir tal objetivo, é necessário modelar ainda as entidades,
funcionalidades e requisitos do sistema não tratados inicialmente.

Mais especificamente, na parte do sistema ainda não especificada tem-se: algumas
funcionalidades das entidades tarefa e fila de mensagens; as entidades semáforo,
mutex e co-rotina; e alguns requisitos do sistema que serão tratados após a
especificação das entidades, com o amadurecimento da modelagem. Nas seções
seguintes serão explicada, de forma detalhada, cada uma dessas pendências.

\section{Entidade Tarefa}
\label{sec:tarefa_proposta}

A entidade tarefa já foi parcialmente formalizada na modelagem inicial.
Entretanto, muitas das suas funcionalidades não foram tratadas nessa
especificação. Em suma, tem-se que:
\begin{itemize}
  \item Na parte de criação de tarefa (seção~\ref{sec:criacao_tarefa_api}),
  todas as suas funcionalidades foram formalizadas;
  \item Na parte de controle de tarefas (seção~\ref{sec:controle_tarefa_api}),
  apenas a funcionalidade \textit{xTaskResumeFromISR()}, utilizada pelo
  tratamento de interrupções para reativar uma tarefa suspensa, não foi
  especificada;
  \item Na parte de utilitários de tarefa
  (seção~\ref{sec:utilitarios_tarefa_api}), foram deixadas de lado as
  funcionalidades \textit{uxTaskGetStackHighWaterMark()}, que retorna a
  quantidade de espaços vazios na pilha de uma tarefa,
  \textit{vTaskSetApplicationTag()}, que associa uma função gancho a uma tarefa,
  e \textit{xTaskCallApplicationTaskHook()}, que realiza a chamada a uma função
  gancho de uma determinada tarefa; e \item Na parte de controle de escalonador
  (seção~\ref{sec:controle_escalonador_api}) faltam especificar as
  funcionalidades \textit{taskYIELD()}, funcionalidade que força a troca de
  contexto, \textit{taskENTER\_CRITICAL()}, funcionalidade que indica o início de
  uma região crítica, \textit{taskEXIT\_CRITICAL()}, funcionalidade que indica o
  final de uma região crítica, \textit{taskDISABLE\_INTERRUPTS()}, funcionalidade
  que desabilita o uso de interrupções, e \textit{taskENABLE\_INTERRUPTS()},
  funcionalidade que habilita o uso de interrupções.
\end{itemize} 

Vale ressaltar que existem funcionalidades, relacionadas à entidade tarefa, que
foram tratadas na modelagem inicial e não serão listadas como proposta desse
trabalho. Isso ocorrerá devido ao fato de que tais funcionalidades são utilizadas
apenas como funções de rastreamento do sistema, coletando informações do
funcionamento do sistema sem alterar o seu estado, sendo assim desnecessárias na
implementação dos requisitos do sistema.

\section{Entidade Fila de Mensagem}
\label{sec:fila_proposta}
A entidade fila de mensagens também foi tratada na modelagem inicial. Nela,
somente quatro de suas funcionalidades foram formalizadas, restando com isso
cinco funcionalidades para completar a biblioteca referente à fila de mensagens.
As funcionalidades pendentes são:

\begin{itemize}
  \item  \textit{uxQueueMessagesWaiting()}, funcionalidade que retorna o número
  de mensagens armazenadas em uma fila;
  \item  \textit{xQueueSendFromISR()}, funcionalidade usada, no tratamento de
  uma interrupção, para enviar uma mensagem para uma fila;
  \item  \textit{xQueueSendToBackFromISR()}, funcionalidade usada, no tratamento
  de uma interrupção, para enviar uma mensagem para o final de uma fila; 
  \item  \textit{xQueueSendToFrontFromISR()}, funcionalidade usada, no
  tratamento de uma interrupção, para enviar uma mensagem para o início de uma fila; e 
  \item  \textit{xQueueReceiveFromISR()}, funcionalidade usada, no tratamento de
  uma interrupção, para receber uma mensagem de uma fila. 
\end{itemize}
 
Assim como ocorreu com a entidade tarefa, existem funcionalidades sobre as filas
de mensagens que não serão tratadas como proposta desse trabalho. Isso devido a
essas funcionalidades serem usadas somente para captar informações do sistema,
sendo assim desnecessárias para os requisitos do FreeRTOS.

\section{Entidade Semáforo}
\label{sec:semaforo_proposta}

Após a adição das funcionalidades que faltavam às entidades especificadas
inicialmente, é necessário que as demais entidades do sistema sejam acrescentadas
ao modelo. Esse acréscimo, assim como ocorreu com as entidades já tratadas, será
feito de forma incremental, tornando com isso a especificação mais simples e
viável.

A primeira entidade a ser acrescentada ao modelo será o semáforo. Inicialmente
será especificado somente o semáforo binário, sendo o semáforo com contador
especificado através de alterações no semáforo binário. A especificação desses
elementos ocorrerá através da criação de um módulo com estados e operações
responsáveis pelas características desses elementos. Com a isso, esse módulo
servirá como base para a especificação das funcionalidades do sistema
relacionadas à entidade semáforo.

As características da entidade semáforo inicialmente tratadas nessa etapa serão:
estado de um semáforo (disponível ou indisponível); conjunto de tarefas
bloqueadas à espera do semáforo; referência para a tarefa que retém o semáforo.
Ao final dessa etapa, as seguintes funcionalidades irão enriquecer o modelo:

\begin{itemize}
  	\item vSemaphoreCreateBinary(), funcionalidade responsável por criar um
  	semáforo binário no sistema;
	\item vSemaphoreCreateCounting(), funcionalidade responsável por criar um
  	semáforo com contador no sistema; 
	\item xSemaphoreTake(), funcionalidade utilizada por uma tarefa para
 	solicitar um semáforo; 
	\item xSemaphoreGive(), funcionalidade utilizada por uma tarefa para
 	liberar um semáforo; 
	\item xSemaphoreGiveFromISR(), funcionalidade utilizada pelo tratamento de uma
	interrupção para liberar um semáforo; e 
	\item xSemaphoreTakeFromISR(), funcionalidade utilizada pelo tratamento de uma
	interrupção para solicitar um semáforo. 
\end{itemize}

  
\section{Entidade Mutex}
\label{sec:mutex_proposta}

A criação da entidade mutex (seção~\ref{sec:mutex}) ocorrerá após a especificação
do semáforo devido ao fato de o mutex ser considerado um tipo especial de
semáforo, no qual o mecanismo de herança de prioridade é implementado. Assim,
para adicionar a entidade mutex na modelagem do FreeRTOS será necessário apenas
editar o módulo semáforo para que ele trate das particularidades relacionadas a
essa entidade.

As características da entidade mutex que serão tratadas inicialmente são: o
estado de um mutex (disponível ou indisponível), o conjunto de tarefas aguardando
o mutex; referência para a tarefa que retém o mutex; e o mecanismo de herança de
prioridade. Ao final, a funcionalidade $\mathit{xSemaphoreCreateMutex()}$,
responsável por criar um mutex no sistema, será acrescentada à modelagem do
FreeRTOS.
 

\section{Entidade Co-rotina}
\label{sec:corotina_proposta}

A última entidade a ser modelada na especificação do FreeRTOS será a co-rotina
(seção~\ref{sec:corotinas}). Para formalizar essa entidade, será preciso criar-se
um novo módulo, com os estados e operações responsáveis pela especificação das
características dessa entidade. Além disso, devido a co-rotina também ser uma
unidade de execução do sistema, ela é controlada pelo escalonador, o qual deverá
ter suas funcionalidades alteradas para suportar a entidade em questão.

A característica inicialmente tratada na especificação da entidade co-rotinas
será o estado que uma co-rotina pode assumir. Com a modelagem dessa entidade,
serão adicionadas as seguintes funcionalidades à especificação:
\begin{itemize}
	\item xCoRoutineCreate(), funcionalidade responsável pela criação de uma
	co-rotina no sistema;
	\item crDELAY(), funcionalidade utilizada para bloquear uma co-rotina; 
	\item crQUEUE\_SEND(), funcionalidade utilizada por uma co-rotina para enviar
	uma mensagem para uma fila de mensagens;
	\item crQUEUE\_RECEIVE(), funcionalidade utilizada por uma co-rotina para
	receber uma tarefa de uma fila de mensagens;
	\item crQUEUE\_SEND\_FROM\_ISR(), funcionalidade utilizada pelas co-rotinas que
	tratam interruções para enviar uma mensagem para uma fila de mensagens;
	\item crQUEUE\_RECEIVE\_FROM\_ISR(), funcionalidade utilizada pelas co-rotinas que
	tratam interruções para receber uma mensagem de uma fila de mensagens; e
	\item vCoRoutineSchedule(), funcionalidade utilizada para chamar o escalonador
	responsável pelas co-rotinas.
\end{itemize}

\section{Requisitos do sistema}
\label{sec:requisitos_proposta}
Com a modelagem das entidades, parte dos requisitos do sistema serão tratados.
Entretanto, como essa modelagem será realizada de forma abstrata, vários
requisitos não poderão ser especificados logo de início. Assim, para que esses
requisitos abstraídos sejam formalizados, é necessário adicionar à especifica as
características subtraídas das entidades na modelagem inicial. Essa adição pode
ocorrer de duas formas, reformulando o modelo criado ou refinando-o.

A seguir, tem-se a lista de todos os requisitos do sistema que serão tratados
nessa fase. Uma explicação mais detalhada sobre esses requisitos será mostrada
nos parágrafos seguintes:

\begin{itemize}
	\item Compartilhar o tempo de CPU entre tarefas de iguais prioridade.
	\item Tamanho de uma fila de mensagens. 
	\item Tempo de bloqueio de uma tarefa.
	\item Tratamento de \textit{overflow} do tempo de execução.
	\item Ordenação dos itens em uma fila de mensagens.
	\item Prioridade entre tarefas nas listas de eventos.
	\item Gerenciamento de memória.
\end{itemize}

O compartilhamento do tempo de CPU entre tarefas de mesma prioridade será o
primeiro requisito especificado nessa etapa da modelagem. Para tratar tal
exigência, serão necessárias algumas alterações no módulo responsável pelo a
entidade tarefa. Essas alterações tornarão esse módulo capaz de controlar o tempo
de execução entre as tarefas de estado PRONTA e com prioridades iguais a tarefa
em execução. Isso é importante porque evita que tarefas de maiores prioridades
nunca sejam escalonadas. Ao final, a funcionalidade \textit{incrementTick} deve
ser alterada para compartilhar o tempo de execução entre tarefas de mesma
prioridade.

A característica de tamanho de uma fila de mensagens define uma capacidade máxima
para uma fila de mensagens. Esse requisito será tratado com o refinamento do
módulo de fila de mensagens, adicionando a ele estados e operações capazes de
controlar o tamanho de uma fila. Após isso, as funcionalidades que estão
relacionadas a essa característica serão refinadas para tratar tal exigência.

Outra particularidade do sistema não tratada nas demais etapas é a característica
de uma tarefa possuir um tempo máximo de bloqueio\footnote{Na modelagem inicial
da entidade tarefa foi tratada apenas a característica de uma tarefa possuir o
estado BLOQUEADA e não o tempo que essa tarefa deve permanecer nesse estado}.
Para tratar dessas características será adicionado, no módulo de tarefas, um
estado para controlar o tempo de bloqueio das tarefas. Com isso, as
funcionalidades relacionadas a essa característica devem ser alteradas para
tratar tal particularidade.

O estouro do tempo de execução acontece devido às limitações da máquina utilizada
pelo sistema. Esse fato ocorre quando o tempo de execução do sistema ultrapassa o
limite máximo do tipo que o representa. Para tratar esse acontecimento, o sistema
basicamente maneja as tarefas bloqueadas atualizando o seu tempo de desbloqueio a
cada estouro. Com isso, a especificação dessa exigência será feita através de
alterações no módulo de tarefa e, consequentemente, nas funcionalidades
relacionadas a essa entidade, além do refinamento do modulo que preocupa-se com o
tempo do escalonador.

Ordenar os itens em um fila de mensagens é implementar, na fila de mensagens, uma
estrutura, na qual cada item tem sua posição. Essa característica será adicionada
ao modelo através do refinamento do módulo de fila, proporcionando uma estrutura
ordenada para os itens de uma fila. Após isso, algumas funcionalidades que
cuidam dessa entidade serão refinadas.

O requisito tratar a prioridade das tarefas em uma fila de evento significa que,
no momento de desbloquear uma tarefa localizada em uma fila de eventos, será
levando em consideração a prioridade das tarefas localizadas nela. Basicamente,
as tarefas com maiores prioridades serão desbloqueadas primeiro do que as tarefas
de menores prioridades. Esse requisito será especificado através de alterações
nas funções que trabalham com fila de evento, como é o caso das
funcionalidades que enviam e recebem uma tarefa para uma fila de mensagens, pois
são nessas funcionalidades que as tarefas bloqueadas aguardando pela fila são
desbloqueadas e retiradas das filas de evento.

Por fim, o requisito de tratamento de memória deve ser incorporado ao sistema.
Assim, no momento da criação de cada entidade, a especificação poderá decidir se
há, ou não, memória suficiente para a criação da entidade, retirando com isso o
indeterminismo existente nas funcionalidades de criação de uma entidade.


\section{Atividades e Etapas}\label{cap:cronograma}
Para o melhor entendimento do cronograma do projeto, que será apresentado na
seção~\ref{sec:cronograma}, as atividades discutidas nas seções anteriores foram
resumidamente elencadas em etapas a serem realizadas nesta seção. Através desse
trabalho obteve-se a seguinte lista:
\begin{enumerate}
\item Especificar, em um nível abstrato, as funcionalidades restantes das
entidades tarefa e fila de mensagens.\label{etapa:funcionalidades}
\begin{itemize}
  \item Nessa etapa, serão desenvolvidas as funcionalidades restantes
  relacionadas às entidades tarefa e fila de mensagens, especificadas
  inicialmente.
\end{itemize}

\item Modelagem abstrata da entidade semáforo.\label{etapa:semaforo}
\begin{itemize}
  \item Nessa etapa, a entidade semáforo (seção~\ref{sec:semaforo}) será
  especificada de forma abstrata, junto com as funcionalidades relacionadas a
  essa entidade.
\end{itemize} 

\item Modelagem abstrata da entidade mutex. \label{etapa:mutex}
\begin{itemize}
  \item Nessa parte do trabalho será especificado,
  de forma abstrata, a entidade mutex (seção~\ref{sec:mutex}), assim como as 
  funcionalidades que estão relacionadas a essa entidade.
\end{itemize}

\item Modelagem abstrata da entidade co-rotina. \label{etapa:corotina}
\begin{itemize}
  \item Essa fase do trabalho encerra a especificação abstrata das entidades do
  FreeRTOS. Nela, a entidade co-rotina(seção~\ref{sec:corotinas}) será modelada,
  em um nível abstrato, junto com suas funcionalidades. 
\end{itemize}

\item Refinamento da entidade tarefa.\label{etapa:refinamento_tarefa}
\begin{itemize}
  \item Nessa etapa, a entidade tarefa, especificada inicialmente, será refinada.
  Parte dessa etapa já foi iniciada nos primeiros passos desse
  trabalho(capítulo~\ref{cap:primeiros_passos}). Assim, resta apenas especificar
  as características de tempo bloqueio de uma tarefa, controle da execução de
  duas tarefas com a mesma prioridade, controle do estouro do tempo de execução e
  refinar as estruturas abstratas usada na especificação dessa entidade para uma
  forma mais concreta.
\end{itemize}
 
\item Refinamento da entidade fila de mensagens.\label{etapa:refinamento_fila}
\begin{itemize}
  \item Como a entidade fila de mensagens foi especificada de forma abstrata
  inicialmente, essa etapa será responsável por realizar uma modelagem mais
  concreta dessa entidade. Nessa etapa, serão tratadas as características de
  posição das mensagens e prioridade das tarefas em uma fila de evento.
  %, especificando mecânismo de modelagem utilizados, como o conjunto,
  %de uma forma mais próxima da implementação.  
\end{itemize}

\item Refinamento da entidade co-rotina.\label{etapa:refinamento_corotina}
\begin{itemize}
  \item Nessa fase ocorrerá o refinamento da entidade co-rotina, especificando as
  características de prioridade de uma co-rotina e tempo máximo de bloqueio de
  uma co-rotina.
%, tornando a sua modelagem mais concreta detalhada.
\end{itemize} 

\item Refinamento da entidade semáforo.\label{etapa:refinamento_semaforo}
\begin{itemize}
  \item Nessa parte do trabalho, a entidade semáforo será refinada. Através desse
  refinamento serão tratados os requisitos ligados ao semáforo com contador.
\end{itemize}
  
\item Refinamento da entidade mutex.\label{etapa:refinamento_mutex}
\begin{itemize}
  \item Essa etapa encerra a especificação do FreeRTOS com o refinamento da
  entidade semáforo. Nela o tratamento de herança de prioridade será acrescentado
  à especificação.
\end{itemize}

%\item Prova a especificação.\label{etapa:prova}
%\begin{itemize}
%  \item Essa é fase mais importante e demorada do trabalho. Nela são geradas
%  obrigações de prova que demonstram o correto funcionamento da especificação.
%  As suas atividades são difundidas por quase todas as etapas do projeto. Isso,
%  é devido ao fato que, no final de cada fase de especificação, obrigações 
%  de prova são geradas para validar as atividades desenvolvidas em cada etapa.
%  Com isso, o tempo dessa fase será dividido entre as demais etapas do projeto,
%  sendo que, no final do projeto, um tempo e destinado as obrigações de provas
%  não resolvidas durante as fases de desenvolvimento da especificação.
%\end{itemize}

\item Preparar dissertação e defesa\label{etapa:dissertacao}
\begin{itemize}
  \item Depois do desenvolvido do trabalho proposto, é hora de preparar a
  dissertação e finalmente o material para a defesa , sendo este o trabalho dessa etapa.
\end{itemize}\item

\end{enumerate}

\section{Cronograma}\label{sec:cronograma}
Para planejar o desenvolvimento das etapas elencadas acima, foi preparado o
cronograma da tabela~\ref{tab:cronograma}, que prevê a finalização do projeto em
3 meses após a qualificação. Nele, as etapas de especificação abstratas das
entidades e o refinamento da entidade tarefa são realizadas até o final do mês de
novembro, restando o mês de dezembro para as demais atividades de refinamento. Em
janeiro, a dissertação, junto com sua defesa, será elaborada, finalizando o
projeto.

\begin{table}[htb]

\centering
\begin{tabular}{|l|p{5cm}|p{5cm}|p{3cm}|}
\hline
\textbf{Etapas} &  \textbf{Novembro} & \textbf{Dezembro} & \textbf{Janeiro}\\
\hline
\hline
Etapa~\ref{etapa:funcionalidades}  & \rule{5mm}{3mm} &  &  \\
\hline
Etapa~\ref{etapa:semaforo} &\hspace{4mm} \rule{10mm}{3mm} &  &  \\
\hline
Etapa~\ref{etapa:mutex} & \hspace{15mm}\rule{10mm}{3mm} &  &  \\
\hline
Etapa~\ref{etapa:corotina} &\hspace{24mm} \rule{10mm}{3mm} &  &  \\
\hline
Etapa~\ref{etapa:refinamento_tarefa} & \hspace{34mm} \rule{14mm}{3mm}& &\\

\hline
Etapa~\ref{etapa:refinamento_fila} & &\rule{12mm}{3mm} &  \\
\hline
Etapa~\ref{etapa:refinamento_corotina} & &\hspace{11mm} \rule{12mm}{3mm} &  \\
\hline
Etapa~\ref{etapa:refinamento_semaforo} & &\hspace{24mm} \rule{12mm}{3mm} &  \\
\hline
Etapa~\ref{etapa:refinamento_mutex} & &\hspace{36mm} \rule{12mm}{3mm} &  \\



\hline
Etapa~\ref{etapa:dissertacao} & & &\rule{30mm}{3mm}   \\



\hline
\end{tabular}
\caption{Cronogramas de etapas do projeto}
\label{tab:cronograma}
\end{table}
\newpage

\chapter{Conclusão}\label{cap:conclusao}

Esse trabalho baseia-se em dois grandes desafios da computação, o desenvolvimento
de sistemas fidedignos e, principalmente, o projeto do software verificado, no
qual se encontra a proposta de especificar formalmente o sistema operacional
de tempo real FreeRTOS, objetivo principal desse trabalho. Com essa especificação,
será possível provar o correto funcionamento das funcionalidades que constituem
esse sistema e assim garantir uma maior confiabilidade para as aplicações
desenvolvidas a partir dele.

A escolha do FreeRTOS como sistema a ser especificado ocorreu devido as suas
características. Primeiramente ele é um sistema simples e enxuto, o que
facilita a sua formalização. Em segundo, ele possui uma grande popularidade,
portabilidade e apresenta, em seu código fonte, conceitos comuns à maioria dos
sistemas atuais, o que torna a sua especificação uma grande ajuda para a
comunidade da computação.

O formalismo escolhido para realizar tal especificação foi o método B, que
proporciona uma modelagem incremental e modular. Assim, essa especificação será
realizada por etapas, nas quais serão gerados modulos abstratos com tarefas bem
definidas, responsáveis por partes da especificação. Em seguida, utilizando o
mecanismo de refinamento, os módulos criados serão especificados de forma mais
concreta, tornando assim a especificação mais completa e próxima à realidade.
  
Para provar a viabilidade desse trabalho, foi desenvolvido, como etapa inicial,
uma modelagem abstrata de alguns dos principais conceitos do FreeRTOS. Nessa
etapa, os conceitos de tarefa e fila de mensagens foram especificados de forma
abstrata e, em seguida, refinados. O resultado dessa etapa foi uma especificação
simples, mas com várias características do FreeRTOS provadas. Como fruto desse
trabalho foi publicado o seguinte artigo \cite{david09}.

Outra utilidade da especificação do FreeRTOS será a criação de uma documentação
do sistema na perspectiva formal, o que servirá para um melhor entendimento do
sistema. Além disso, essa especificação formal poderá ser usada para verificar a
implementação atual usando ferramentas como FRAMA-C\cite{framac} ou
VCC\cite{vcc}. Por fim, essa modelagem formal poderá servir como entrada para a
criação de testes de sistema a nível de codificação, criando-se assim mais uma
forma de verificação do correto funcionamento do FreeRTOS.

Por último, como continuidade desse trabalho tem-se, através das ferramentas
disponibilizadas pelo método B, a possibilidade da geração de código a partir da
especificação criada. Para isso será necessário realizar-se refinamentos mais
concretos a nível de linguagem algorítmicas e em seguida a adaptar tal modelagem
para o uso das ferramentas, que geralmente não aceitam determinados tipos de
construção da especificação em B.



%Em suma, esse trabalho procura agregar esforços na resolução de dois grandes
%problemas da computação, a construção de software fidedigno e o projeto do
%software verificado. Para isso, será desenvolvida, utilizando-se o método B,
%uma especificação formal do sistema operacional de tempo real FreeRTOS. Tal
%especificação tem o objetivo de provar o correto funcionamento desse sistema,
%tornando-o mais confiável e as aplicações desenvolvidas com ele mais
%fidedignas. Além disso, essa especificação servirá como uma iniciativa para a
%verificação formal de sistemas complexos, já que o FreeRTOS possui conceitos
%comuns a maioria dos sistemas atuais. Por fim, com a modelagem do FreeRTOS,
%será criada uma documentação do mesmo na perspectiva formal, a qual servirá
%também como entrada para métodos de criação de testes do correto funcionamento
%do sistema.

\bibliographystyle{abnt-num}
%\bibliographystyle{abnt-alf}
\bibliography{quali}

\anexo


\end{document}

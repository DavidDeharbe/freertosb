%% LyX 1.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[brazil,ruledheader]{abnt}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}

\input{commands}

\makeatletter
\usepackage{babel}

\makeatother
\begin{document}

\autor{Stephenson de S. L. Galvão}


\titulo{Modelagem do Sistema Operacional de Tempo Real FreeRTOS}

\orientador{Prof. Dr. David Déharbe}


\comentario{Qualificação de mestrado apresentada ao programa de Pós-graduação em
Sistemas e Computação do Departamento de Informática e Matemática Aplicada da
Universidade Federal do Rio Grande do Norte, como requisito parcial para a
obtenção do grau de Mestre em Ciências da Computação.}


\instituicao{Universidade Federal do Rio Grande do Norte \par Centro de
Ciências Exatas e Da Terra \par Departamento de Informática e Matemática
Aplicada \par Programa de Pós-graduação em Sistemas e Computação}


\local{Natal - RN, Brasil}


\data{1 de junho de 2009}

\capa

\folhaderosto

%\begin{folhadeaprovacao}
%Monografia de Projeto Final de Graduação sob o título
%\textit{``\ABNTtitulodata''}, defendida por \ABNTautordata~e aprovada em
%\ABNTdatadata, em Vitória, Estado do Espírito Santo, pela banca examinadora
%constituída pelos professores: \setlength{\ABNTsignthickness}{0.4pt}

%\assinatura{Prof. Msc. Sérgio A. A. de Freitas\\ Orientador} \assinatura{Prof.
%Dr. Flávio Miguel Varejão\\ Universidade Federal do Espírito Santo}
%\assinatura{Prof. Dr. Raul Henriques Cardoso Lopes\\ Universidade Federal do
%Espírito Santo}
%\end{folhadeaprovacao}
%\begin{resumo}
%Escreva aqui o texto do seu resumo.
%\end{resumo}
%\begin{abstract}
%Write here the English version of your {}``Resumo''.
%\end{abstract}

%\chapter*{Dedicatória}

%Dedico este trabalho a ...


%\chapter*{Agradecimentos}

%Agradeço a ...

\tableofcontents{}\listoffigures



\listoftables


\chapter{Introdução\label{cap:introducao}}

Falar dos grandes desafios (SBC) e do desafio do compilador ``Verifiging
compile'', ``Verified Software repository'' desafio de Jim Woodcock

\section{Objetivos}
Falar do objetivo da dissertação e não só da qualificação. Itens a serem
discutidos:

\begin{itemize}
  \item Abrangência da especificação
  \item Profundidade em aspectos pelo menos da construção do software
  \item Se necessário tem a possibilidade de estessão até o nível de assemblagem
		devido aos códigos em assembler que compõem o FreeRTOS.
\end{itemize}

\section{Metodologia}
Metodologia da dissertação, no contexto do que já foi feito



%item \textbf{Assunto:}
%\begin{itemize}
%  \item Motivação do trabalho
%  \item Falar do uso dos sistemas de tempo real
%  \item Falar da importância dos sistemas de tempo real
%  \item Falar da utilização dos STRs em aplicações críticas 
%  \item Demonstrar exemplos de sistemas de tempo real
%\end{itemize}

%\item \textbf{Bibliografia ou Inspirações:}
% \begin{itemize}
%  \item Introdução do artigo do semish 2009
%  \item Introdução do Relatório Técnico
%  \item Livros de STR que falam da sua importância e utilização
%\end{itemize}



\newpage


\chapter{FreeRTOS}

O FreeRTOS é um sistema operacional de tempo real enxuto, simples e de fácil uso.
O seu código fonte, feito em \textit{C} com partes em \textit{assembly}, é aberto
e possui pouco mais de 2.200 linhas de código, que são essencialmente
distribuídas em quatro arquivos: \texttt{task.c}, \texttt{queue.c},
\texttt{croutine.c} e \texttt{list.c}. Uma outra característica marcante desse
sistema está na sua portabilidade, sendo o mesmo oficialmente disponível para 17
arquiteturas mono-processadores diferentes, entre elas a PIC, ARM e Zilog Z80,
as quais são amplamente difundidas em produtos comerciais através de sistemas
computacionais embutidos.

Como a maioria dos sistemas operacionais de tempo real, o FreeRTOS provê para os
desenvolvedores de  sistemas concorrentes de tempo-real acesso aos recursos de
\textit{hardware}, facilitando com isso o desenvolvimento dos mesmo. Assim,
FreeRTOS trabalha como na figura \ref{fig:rtos}, fornecendo uma camada de
abstração localizada entre a aplicação e o hardware, que tem como papel esconder
dos desenvolvedores de aplicações os detalhes do hardware que será utilizado.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.8]{../fig/rtos.jpg}
\caption{Camada abstrata proporcionada pelo FreeRTOS}
\label{fig:rtos}
\end{figure}

Para prover tal abstração o FreeRTOS é composto por um conjunto de bibliotecas de
tipos e funções que devem ser linkeditadas\footnote{Processo que liga o código da
aplicação ao código das funcionalidades de outras bibliotecas utilizada por ela}
com o código da aplicação a ser desenvolvida. Juntas, essas bibliotecas fornecem
para o desenvolvedor serviços como gerenciamento de tarefa, comunicação e
sincronização entre tarefas, gerenciamento de memória e controle dos dispositivos
de entrada e saída.

A criação de uma aplicação utilizando o FreeRTOS pode ser divida em duas partes.
Na primeira parte são criadas, de acordo com modelos fornecidos pelo FreeRTOS, as
tarefas e demais estruturas disponibilizadas pelo FreeRTOS que serão utilizadas
pela a aplicação. Na segunda parte é feito o cadastramento das tarefas utilizadas
pelo o sistema assim como a inicialização do mesmo. Por fim, o sistema é
transformado em uma aplicação da arquitetura desejada.

A seguir tem-se em detalhe os principais serviços providos pelo o FreeRTOS junto
com a biblioteca que os disponibilizam.

\section{Gerenciamento de Tarefas e Co-Rotinas}

\subsection{Tarefa}
\label{subsec:tarefa}
%SG->DD
% Eu devo explicar o que é contexto?
Para entender como funciona o gerenciamento de tarefas do FreeRTOS é necessário
primeiramente entender-se o conceito de tarefa. Uma tarefa é uma unidade básica
de execução, com contexto próprio, que compõem as aplicações, que geralmente são
multitarefas. Para o FreeRTOS uma tarefa é composta por :

\begin{itemize}
  \item Um estado que demonstra a atual situação da tarefa
  \item Uma prioridade que varia de zero até uma constante máxima definida pelo
  o usuário
  \item Uma pilha na qual é armazenada o ambiente de execução (estado dos
  registradores) da tarefa quando está é interrompida.
\end{itemize}

Em um sistema uma tarefa pode assumir vários estados de acordo com a sua
circunstância. Assim o FreeRTOS disponibiliza quatro tipos de estados diferentes
para uma tarefa. Os estados que uma tarefa pode assumir no FreeRTOS são:

%SG->DD
% Acho que eu deveria mudar o nome do estado em execução para executando
\begin{itemize}
  \item \textbf{Em execução}: Indica que a tarefa esta sendo executada pelo
  processado
  \item \textbf{Pronta}: Indica que a tarefa está pronta para entrar em execução
  mas não está sendo executada
  \item \textbf{Bloqueada}:Indica que a tarefa esta esperando por algum evento
  para continuar a sua execução
  \item \textbf{Suspensa}:Indica que a tarefa foi suspensa pelo kernel
  através da chamada de uma funcionalidade usada para controlar as tarefas 
\end{itemize}

A permutação que ocorre no estado de uma tarefa funciona como demonstra a figura
\ref{fig:task_states}. Nela uma tarefa com o estado ``em execução'' pode ir para
o estado pronta, bloqueado ou suspenso. Uma tarefa com o estado pronto pode ser
suspensa ou entrar em execução. E as tarefa com o estado bloqueada ou suspensa só
podem ir para o estado pronto.

Entretanto, vale enfatizar que por tratar-se de um SOTR para arquiteturas
mono-processadores o FreeRTOS não permite que mais de uma tarefa seja executada ao
mesmo tempo. Assim,em um determinado instante, apenas uma tarefa pode assumir o
estado pronto, restando as demais os outros estado. Com isso, para decidir qual
tarefa será executada o FreeRTOS possui um mecanismo denominado escalonador, o
qual será detalhado na sessão \ref{sec:escalonador}.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.6]{../fig/task_states.jpg}
\caption{Grafo de estados de uma tarefa}
\label{fig:task_states}
\end{figure}

\subsubsection{Tarefa Ociosa}
\label{subsubsection:tarefa_ociosa}
No FreeRTOS existe também uma tarefa denominada de tarefa ociosa, a qual é
executada quando nenhuma tarefa está em execução. A tarefa ociosa tem como
principal finalidade excluir da memória tarefas que não serão mais usadas pelo
sistema. Assim, quando uma aplicação informa para o sistema que uma tarefa não
será mais utilizada, esta tarefa só será excluída quando a tarefa ociosa entrar
em execução. A tarefa ociosa possui a menor prioridade dentre as tarefas que
compõem um sistema.


\subsection{Co-rotinas}
\label{subsec:corotinas}
Outro conceito importante suportado pelo FreeRTOS é o de Co-rotina. Assim como as
tarefas, co-rotinas são unidades de execução independentes que formam uma
aplicação. Por isso assim como as tarefas, uma co-rotina é formada por uma
prioridade e um estado. Entretanto, devido ao fato de co-rotinas não possuírem
contexto de execução próprio, ela não possuem uma pilha para armazenar o
contexto de execução, como ocorre nas tarefas.

Os estados que uma co-rotina pode assumir são:
\begin{itemize}
  %SG->DD: Acho que eu deveria mudar o nome do estado ``em execução'' para
  % executando
  \item \textbf{Em execução}: Quando a co-rotina está sendo executada
  \item \textbf{Pronta}: Quando a co-rotina está pronta para ser executada, mas
  não está em execução
  \item \textbf{Bloqueada}: Quando a co-rotina está bloqueada esperando por
  algum evento para continuar a sua execução. 
\end{itemize}

As transições entre os estados de uma co-rotina ocorre como demonstra a figura
\ref{fig:croutine_states}. Nela uma co-rotina em execução pode ir tanto para o
estado bloqueado como para o estado suspenso. Uma co-rotina de estado bloqueado
só pode ir para o estado pronto e uma co-rotina de estado pronto só pode ir para
o estado ``em execução''. 

\begin{figure}[!h]
\centering
\includegraphics[scale=0.6]{../fig/croutine_states.jpg}
\caption{Grafo de estados de uma co-rotina}
\label{fig:croutine_states}
\end{figure}

Assim como nas tarafes, a decisão de qual co-rotina irá entrar em execução também
é feita pelo o escalonador, que será explicado na seção \ref{sec:escalonador}

\subsection{Escalonador de Tarefas}
\label{sec:escalonador}

%SG->DD
%Não sei se esse termo ``unidade de execução'' ficou bem. Só botar
%um termo genérico para tarefas e corotinas
 
O escalonador é a parte mais importante de um sistema. É ele quem decide qual
unidade de execução\footnote{Aqui o termo ``unidade de execução'', as vezes
sitado apenas como unidade, refere-se a todas as tarefas e co-rotinas(seção
\ref{subsec:corotinas}) do sistema} irá entrar execução. Além disso, é ele que
faz a troca entre a unidade em execução e nova unidade que irá entrar em
execução. No FreeRTOS o escalonador pode funcionar de três modos diferentes:

\begin{itemize}
  \item \textbf{Preemptivo}: Quando o escalonador interrompe a unidade em
  execução, alterando assim o seu estado, e ocupa o processador com outra
  unidade
  \item \textbf{Cooperativo}: Quando o escalonador não tem permissão de
  interromper a unidade em execução, tendo que esperar a mesma interromper-se
  para que ele possa decidir qual será a próxima unidade a entrar em execução e,
  em seguida realizar a troca.
  \item \textbf{Híbrido}:  Quando o escalonador pode comporta-se tanto como
  preemptivo como cooperativo.
\end{itemize}

Para as tarefas o escalonador funciona de forma preemptiva, sendo que a decisão
de qual tarefa deve entrar em execução e baseada na prioridade e segue a seguinte
política: a tarefa em execução deve ter prioridade maior ou igual a tarefa de
maior prioridade com o estado ``pronta''. Assim sempre que uma tarefa, com
prioridade maior que a tarefa em execução, entrar no estado pronto, ela deve
imediatamente entrar ``em execução''. Um exemplo claro da política preemptiva
pode ser visto na figura \ref{fig:scheduler}, onde três tarefas, em ordem
crescente de prioridade, disputam a execução do processador.

%SG->DD
%Queria adcionar o texto à figura. É melhor que fazer isso pelo latex ou fazer
% quando for criar uma figura em português

\begin{figure}[!h]
\centering
\includegraphics[scale=0.4]{../fig/scheduler.jpg}
\small{
\begin{enumerate}
  \item Tarefa 1 entra no estado pronto, como não há nenhuma tarefa em execução
  esta assume controle do processador entrando em execução
  \item Tarefa 2 entra no estado pronto, como está tem prioridade maior do que
  a tarefa 1  ela entra em execução passando a tarefa 1 para o estado pronto
  \item Tarefa 3 entra no estado pronto, como está tem prioridade maior do que
  a tarefa 2  ela entra em execução passando a tarefa 2 para o estado pronto
  \item Tarefa 3 encerra a sua execução, sendo a tarefa 2 escolhida para entrar
  em execução por ser a tarefa de maior prioridade no estado pronto
  \item Tarefa 2 encerra a sua execução e o funcionamento do escalonador é
  passado para a tarefa 1
\end{enumerate}
}

\caption{Funcionamento de um escalonador preemptivo baseado na prioridade}
\label{fig:scheduler}
\end{figure}

Para as co-rotinas o escalonador funciona de forma cooperativa e baseada na
prioridade. Com isso, a co-rotina em execução é quem decide o momento de sua
interrupção, sendo que a próxima co-rotina a entrar em execução será a de maior
prioridade entre as co-rotinas com o estado pronto


\subsection{Bibliotecas}
\label{subsection:api_tarefas_corotinas}

Para disponibilizar as caraterísticas discutidas nesta seção o FreeRTOS dispõe
das seguintes bibliotecas: Criação de Tarefas, Controle de Tarefas, Utilidades de
Tarefas, Controle do Kernel e Co-rotinas. A seguir tem-se em detalhe a descrição
de cada uma dessas bibliotecas junto com as funcionalidades que as compõem

\subsubsection{Criação de Tarefas}
Essa biblioteca é responsável pelo conceito de tarefa. Nela estão presente, um
tipo, responsável por representar uma tarefa do sistema, e duas funcionalidades,
uma para a criação de uma tarefa e outra para a remoção de uma tarefa do sistema.
Em seguida, tem-se a lista de todos os tipos e funcionalidades disponibilizados
por essa biblioteca.

\begin{itemize}
  \item \textbf{xTaskHandle} - Tipo pelo qual uma tarefa e referenciada. Por
  exemplo, quando uma tarefa é criada através do método \textit{xTaskCreate},
  este retorna uma referência para nova tarefa através do tipo
  \textit{xTaskHandle}
  
  \item \textbf{xTaskCreate} - Funcionalidade usada para criar uma nova tarefa
  para o sistema.
  
  \item \textbf{vTaskDelete} - Funcionalidade usada para indicar ao sistema que
  uma tarefa deve ser removida\footnote{A remoção de uma tarefa do
  sistema só é feita pela tarefa ociosa \ref{subsubsection:tarefa_ociosa}, nesse
  método é apenas indicado para o sistema quais as tarefas que devem ser
  removidas}
\end{itemize}

\subsubsection{Controle de tarefas}
\label{subsubsec:controle_tarefa}
A biblioteca de controle de tarefas realiza operações sobre as tarefas do
sistema. Ela disponibiliza funcionalidades capazes de bloquear, suspender e
retornar uma tarefa do estado suspenso.Além dessas ela também possui
funcionalidades capazes de alterar e informar a prioridade de uma determinada
tarefa. A lista das principais funcionalidades presentes nessa biblioteca pode
ser vista a seguir:

\begin{itemize}
  \item \textbf{vTaskDelay} - Método usada para suspender uma tarefa por um
  determinado tempo. Nesse método, para calcular qual será o tempo que a tarefa
  deve retornar, é levando em consideração o tempo relativo, ou seja, o tempo
  que o método foi chamado. E por isso, é uma método não indicado para a criação de
  tarefas cíclicas, pois o tempo que o método é chamado pode variar em cada
  execução da tarefa devido as interrupções que a mesma pode sofrer.
  \item \textbf{vTaskDelayUntil} - Método usado para suspender uma tarefa por
  um determinado tempo. Esse método difere do \textit{vTaskDelay} pelo o
  fato de que tempo em que a tarefa deve retornar é calculado com base no tempo
  do último retorno da tarefa. Assim, se ocorrer uma interrupção o tempo que a
  tarefa foi retornada não ira mudar, o que torna esse método recomendável para
  tarefas cíclicas
  \item \textbf{uxTaskPriorityGet} - Método usado para informar a prioridade de
  uma determinada tarefa
  \item \textbf{vTaskPrioritySet} - Método usado mudar a prioridade de uma
  determinada tarefa
  \item \textbf{vTaskSuspend} - Método usado para suspender uma determinada
  tarefa
  \item \textbf{vTaskResume} - Método usado retornar uma tarefa
\end{itemize}

\subsubsection{Utilitários de tarefas}
É através dessa biblioteca que o FreeRTOS disponibiliza para o usuário informações
importantes a respeito das tarefas e do escalonador do sistema . Nela estão
presentes funcionalidades com a de retornar uma referência para a atual tarefa
em execução, retornar o tempo de funcionamento e o estado do escalonador e
retornar o número e a lista das tarefas que estão sendo gerenciadas pelo sistema.
Uma listagem das principais funcionalidades dessa biblioteca é encontrada a
seguir:

\begin{itemize}
  \item \textbf{xTaskGetCurrentTaskHandle} - Retorna a uma referência para
  atual tarefa em execução
  \item \textbf{xTaskGetTickCount} - Retorna o tempo decorrido desde a
  inicialização do escalonador
  \item \textbf{xTaskGetSchedulerState} - Retorna o estado do escalonador 
  \item \textbf{uxTaskGetNumberOfTasks} - Retorna o número de tarefas do sistema
  \item \textbf{vTaskList} - Retorna uma lista de tarefas do sistema
\end{itemize}

\subsubsection{Controle do Escalonador}
Nessa biblioteca estão presentes as funcionalidades responsáveis por controlar as
atividades do escalonador do sistema. Nela encontramos funcionalidades que
iniciam e finalizam as atividades do escalonador, e também, suspendem e retornam
a atividades do mesmo. As principais funcionalidades presente nessa biblioteca
são :

\begin{itemize}
  \item \textbf{vTaskStartScheduler} - Método que inicia as atividades do
  escalonador. Usado para a inicialização do sistema
  \item \textbf{vTaskEndScheduler} - Método que termina as atividades do
  escalonador. Usado para a finalização das atividades do sistema também 
  \item \textbf{vTaskSuspendAll} - Método que suspende as atividades do
  escalonador
  \item \textbf{xTaskResumeAll} - Método que retorna as atividades de uma
  escalonador suspenso
\end{itemize}

\section{Comunicação e sincronização entre tarefa}
Frequentemente tarefas necessitam se comunicar um com as outras. Por exemplo a
tarefa ``A'' depende da leitura do teclado feito pela tarefa ``B''. Com isso, a
uma necessidade de que está comunicação seja feita de maneira bem estruturada e sem
interrupções. 

A maioria dos sistemas operacionais oferecem vários tipos de comunicação entre as
tarefas. Que podem ocorrer da seguinte forma: uma tarefa deseja passar
informações para outra, duas ou mais tarefas querem utilizar o mesmo recurso e
uma tarefa dependo do resultado produzido por outra tarefa.

No FreeRTOS assim como nos demais sistemas operacionais os mecanismos
responsáveis pela a comunicação entre as tarefas são a fila de mensagem, o
semáforo e o mutex (\textit{Mutal Exclusion}). Para entender melhor como
funciona a comunicação entre tarefas no FreeRTOS, cada um desses mecanismo serão
detalhados a seguir

\subsection{Fila de Mensagens}

Filas de mensagens são estruturas primitivas de comunicação entre tarefas. Elas
funcionam como, demonstra a figura \ref{fig:fila_de_mensagens}, um túnel no qual
tarefas enviam e recebem mensagem. Assim, quando uma tarefa necessita
comunicar-se com outra primeiramente ela envia uma mensagem para o túnel para que
a outra tarefa, possa ler a mensagem.
 

\begin{figure}[!h] \centering
\includegraphics[scale=0.7]{../fig/queue.jpg}
\caption{Funcionamento de uma fila de mensagens}
\label{fig:fila_de_mensagens}
\end{figure} 
 
 
No FreeRTOS, uma fila de mensagens é formada por uma lista de tamanho fixo que
armazena as mensagens,também de tamanhos fixos, enviadas para a lista. Assim,
quando uma mensagem é envida para uma fila, uma cópia dela é armazenada na lista
de mensagens para que outra tarefa possa utiliza-lá. Entretanto, no lugar de copiar
toda mensagem para a lista de mensagens, é possível também armazenar-se apenas
uma referência para a mesma, o que torna mais complicado um trabalho do
desenvolvedor, pois assim o acesso à mensagem ficará compartilhado entre as
tarefas, necessitando com isso de uma estrutura de sincronização para coordenar a
utilização da mensagem pelas tarefas. Na maioria da aplicação a troca de
mensagens é feita por cópia.

Além da lista de mensagens uma fila de mensagens é composta por mais duas
outras lista, uma para armazenar as tarefas que estão aguardando enviar uma
mensagens para a fila e outra para armazenar as tarefas que estão aguardando
receber uma mensagem da fila. Assim, quando uma tarefa tenta enviar uma
mensagem para uma fila cheia a tarefa é bloqueada e colocada na lista de tarefa
aguardam para enviar uma mensagem para fila até que um lugar na fila seja
liberado. O mesmo acontece quando uma tarefa tenta ler uma mensagem de uma fila
vazia, sendo que nesse caso, ela vai para a lista de tarefas aguardando por uma
mensagem da fila.

No FreeRTOS, é possíveis definir o tempo máximo que uma tarefa pode ficará
bloqueada esperado por uma fila (liberação de espaço ou chega de mensagem). E
quando existirem mais de uma tarefa bloqueadas aguardando por um evento de uma
fila, as tarefas de maior prioridade têm preferência sobre as demais.

\subsection{Semáforo}

Semáforos são mecanismos usados na sincronização entre tarefas. Eles funcionam
como uma chave que libera, ou não, o uso de um determinado recurso compartilhado.
Assim, quando uma tarefa deseja acessar um recurso compartilhado, ela
primeiramente deve solicitar o semáforo que coordena o uso do recurso, caso o
semáforo esteja livre, a tarefa tem a permissão de utilizar o recurso e, em
seguida, libera o semáforo, caso contrário, a tarefa é bloqueada até que o
semáforo seja liberado.

O FreeRTOS disponibiliza dois tipo de semáforos: os semáforo binário e o semáforo
com contador. A diferença entre os dois está apenas no número de tarefas que
podem reter o semáforo ao mesmo tempo. No semáforo binário apenas uma tarefa
pode reter o semáforo e acessar o recurso compartilhado. E no semáforo com
contador existe um número fixo de tarefa, determinado por um contador, que podem
reter o semáforo. Assim, no semáforo com contador, para cada tarefa que retêm o
semáforo, o contador é decrementado de ``um'', e para cada tarefa que libera o
semáforo, o contador é incrementado de ``um''. O semáforo torna-se indisponível
quando o contador for igual a zero e disponível caso contrário.

No FreeRTOS o semáforo binário funciona como uma fila de mensagens com um único
item. Assim, quando a fila estiver vazia, indica que o semáforo está sendo usado
e, quando a fila estiver cheia, indica que o semáforo está liberado. O mesmo
ocorre para o semáforo com contador, só que nesse caso, o tamanho da fila será a
quantidade de tarefas que podem reter o semáforo ao mesmo tempo, ou seja, o
tamanho inicial do contador

\subsection{Mutex}

Mutexes são parecidos com os semáforos binário. A única diferença entre os dois é
que o mutex implementa um mecanismo de herança de prioridade, o qual impede que
uma tarefa de maior prioridade fique bloqueada a espera de um semáforo ocupado
por uma tarefa de menor prioridade, causando uma inversão de prioridade.

O mecanismo de herança de prioridade funciona da seguinte forma, quando uma
tarefa solicita o semáforo ele verifica se a tarefa solicitante possui prioridade
maior que a tarefa com o semáforo. Caso afirmativo, a tarefa que retém o semáforo
tem, momentaneamente, a sua prioridade elevada, para que assim ela possa realizar
a suas funções sem interrupções e, conseqüentemente, liberar mais rapidamente o
semáforo.

\subsection{Bibliotecas}
A característica de comunicação e sincronização entre tarefas está dividida em
duas bibliotecas, Gerenciamento de fila de mensagens e Semáforo/Mutex. A seguir
tem-se a explicação de cada uma dessas bibliotecas.

\subsubsection{Gerencialmente de fila de Mensagens}
A biblioteca gerenciamento de fila de mensagens é responsável pela criação e
utilização da estrutura fila de mensagens. Ela é composta por funcionalidades que
instanciam e removem filas de mensagens do sistema e pelas funcionalidades que
enviam/recebem mensagens para/de uma fila de mensagens desejada. Abaixo tem-se
uma lista com as principais funcionalidades dessas biblioteca.

\begin{itemize}
  \item \textbf{xQueueCreate} - Cria uma nova instância de uma fila de
  mensagens.
  \item \textbf{vQueueDelete} - Remove uma fila de mensagem do sistema.
  \item \textbf{xQueueSend} - Envia um mensagem para a fila. 
  \item \textbf{xQueueSendToBack} - Envia uma mensagem para o fim da fila.  
  \item \textbf{xQueueSendToFront} - Envia uma mensagem para o início da fila.
  \item \textbf{xQueueReceive} - Lê e remove uma mensagem da fila .
  \item \textbf{xQueuePeek} - Apenas lê uma mensagem da fila, sem remove-lá.
\end{itemize}

\subsubsection{Semáforo/Mutex}
Na biblioteca de semáforo e mutex são implementadas as características de
sincronização entre tarefas (semáforo e mutex) junto com as suas operações. Assim
nesta biblioteca estão presentes funcionalidades que criam e removem semáforos e
mutex, além das funcionalidades que solicitam e liberam os semáforos e os mutex.
As principais funcionalidades desta biblioteca pode ser vista a seguir.


\begin{itemize}
  \item \textbf{vSemaphoreCreateBinary} - Cria um semáforo binário
  \item \textbf{vSemaphoreCreateCounting} - Cria um semáforo com contador 
  \item \textbf{xSemaphoreCreateMutex} - Cria um mutex 
  \item \textbf{xSemaphoreTake} - Solicita a retensão de um semáforo ou de um
  mutex
  \item \textbf{xSemaphoreGive} - Libera um semáforo ou um mutex retido
\end{itemize}


\section{Criação de uma aplicação utilizando o FreeRTOS}

Para construir uma aplicação de tempo real utilizando o FreeRTOS o desenvolvedor
deve seguir determinadas restrições imposta pelo sistema operacional. A maioria
destas restrições são parâmetros de configuração e modelos para a criação de
tarefas, rotinas, filas de mensagens e demais estruturas disponibilizadas pelo
FreeRTOS. Assim, com o intuído de ajudar o desenvolvedor a criar suas primeiras
aplicações O FreeRTOS disponibilizou em seu código fonte aplicações exemplos
organizadas de acordo com as plataformas alvo que o FreeRTOS suporta.

Entretanto, a criação e analise de uma nova aplicação no FreeRTOS é uma atividade
que necessita de maior conhecimento sobre o funcionamento de suas
funcionalidades, fugindo assim do objetivo geral desse capitulo que é
proporcionar uma breve introdução ao FreeRTOS, demonstrando a suas principais
funcionalidades. Com isso, para efeito de exemplificação de como são utilizadas
as funcionalidades apresentadas neste capítulo, será demonstrado de forma
abstrata nessa seção com é criada uma aplicação no FreeRTOS, abordando
principalmente a criação e utilização de tarefas, filas de mensagens e semáforos.

   
 
\subsection{Criação de tarefas}
\label{subsec:criacao_tarefa}

A tarefa é a parte mais importante de uma aplicação. É nela que são colocadas as
rotinas que realizam as atividades de uma aplicação. No FreeRTOS a rotina que
compõem uma tarefa devem seguir a estrutura demonstrada pela
figura~\ref{fig:estruta_rotina_tarefa}. Nele tem-se inicialmente o nome da
rotina, \textit{functionName}, seguido da lista de parâmetros utilizados ela,
\textit{vParameters}. O código que realiza as finalidades da tarefa é colocado
dentro de um laço infinito, forçando assim que a tarefa só finalize a sua
execução quando for excluída pelo sistema\footnote{A execução além de ser
finalizada pelo sistema pode também ser suspensa ou bloqueada como demonstrado
na seção \ref{subsec:tarefa}}.
 
\begin{figure}[!h] \centering
\begin{small}
\begin{verbatim}
void functionName( void *vParameters ) 
{
      for( ;; )
      {
          -- Task application code here. --
      }
}
\end{verbatim}
\end{small}
\caption{Estrutura da rotina de uma tarefa}
\label{fig:estruta_rotina_tarefa}
\end{figure}

Um exemplo concreto da criação de uma rotina pode ser visto na figura
\ref{fig:app_tarefa_ciclica}. Nela tem-se a rotina \textit{cyclicalTasks}, que
utiliza-se da funcionalidade \textit{vTaskDelayUntil} (seção
\ref{subsubsec:controle_tarefa}) para bloquear a execução da tarefa em intervalos
cíclicos de tempo. Essa funcionalidade possui como parâmetros, respectivamente, o
último tempo que a tarefa foi retornada e o período que a tarefa deve permanecer
bloqueada.

Entretanto o desenvolvimento de uma rotina é apenas um dos passos para a criação
de uma tarefa. É necessário ainda que a tarefa seja cadastrada no sistema junto
com sua prioridade e pilha de contexto. Essa função é feito através do método
\textit{xTaskCreate}, demonstrado na figura~\ref{fig:app_tarefa_ciclica} que
possui como parâmetros os seguintes argumentos:

\begin{description}
\item[cyclicalTasks]: Ponteiro para a rotina que deve ser executada
pela função
\item[``cyclicalTasks'']: Nome da função utilizados nos arquivos de log
do sistema
\item[STACK\_SIZE]: Tamanho da pilha de execução da função especificado
de acordo com o número de variável declaradas na rotina da função
\item[pvParameters]: Lista de valores dos parâmetros da rotina da
função.
\item[TASK\_PRIORITY]: Prioridade da tarefa
\item[cyclicalTasksHandle]: Gancho de retorno da tarefa criada
\end{description}

\begin{figure}[!h] \centering
\begin{small}

\begin{verbatim}
void cyclicalTasks( void * pvParameters ){
    portTickType xLastWakeTime;
    const portTickType xFrequency = 10;
    // Initialise the xLastWakeTime variable with the current time.
    xLastWakeTime = xTaskGetTickCount();
    for( ;; ){
        // Wait for the next cycle.
        vTaskDelayUntil( &xLastWakeTime, xFrequency );
        // Perform action here.
    }
}

xTaskHandle cyclicalTasksHandle;

xTaskCreate( cyclicalTask, "cyclicalTasks", STACK_SIZE, 
                 ( void * ) pvParameters, TASK_PRIORITY, &cyclicalTasksHandle);

vTaskStartScheduler();

\end{verbatim}
\end{small}
\caption{Aplicação formada por uma tarefa cíclica}
\label{fig:app_tarefa_ciclica}
\end{figure}

Após ser criada a tarefa que irá realizar a funcionalidade da aplicação, para
finalizar o desenvolvimento de uma aplicação, resta apenas que o escalonador do
sistema seja iniciado, iniciando assim as tarefas da aplicação. Essa operação é
feita pela a funcionalidade \textit{vTaskStartScheduler()}, presente no final
da aplicação demonstrada pela figura~\ref{fig:app_tarefa_ciclica}.


\subsection{Utilização da fila de mensagens}

A utilização de uma fila de mensagens é resumidamente demonstra na aplicação da
figura~\ref{fig:app_fila_de_mensagens}. Nela inicialmente tem-se que a estrutura
\textit{AMessage} define o tipo da mensagem que será utilizada. Em seguida,
através do método \textit{xQueueCreate} é criada uma fila de mensagens que será
referenciada pela variável \textit{xQueue}, do tipo \textit{xQueueHandle}, tipo
usado para referenciar fila de mensagem. Para isso o método create recebe como
parâmetros, respectivamente, a quantidade de mensagens que a fila pode armazenar
e o tamanho da mensagens manuseadas por ela, atributos necessários para um fila
de mensagens.


\begin{figure}[!h] \centering
\begin{small}

\begin{verbatim}
struct AMessage { 
    portCHAR ucMessageID; 
    portCHAR ucData[ 20 ]; 
}xMessage;

xQueueHandle xQueue;
//Create a queue capable of containing 10 pointers to AMessage structures.
xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
// Task to create a queue and post a value. 
void sendTask( void *pvParameters ) { 
struct AMessage *pxMessage;
	 
    if( xQueue == 0 ) { 
        // Failed to create the queue. 
    }else{
        // Send a pointer to a struct AMessage object. Don't block if the 
        // queue is already full. 
        pxMessage = & xMessage; 
        xQueueSend( xQueue, ( void * ) &pxMessage, ( portTickType ) 0 );
    }
// ... Rest of task code.
 
}

// Task to receive from the queue. 
void reciveTask( void *pvParameters ) { 
struct AMessage *pxRxedMessage;

    if( xQueue != 0 ) { 
        // Receive a message on the created queue. Block for 10 ticks if a 
        // message is not immediately available. 
        if( xQueueReceive( xQueue, &( pxRxedMessage ), ( portTickType ) 10 ) ) {
            // pcRxedMessage now points to the struct AMessage variable posted 
            // by vATask. 
        } 
    }
    // ... Rest of task code. 
} 

\end{verbatim}
\end{small}
\caption{Aplicação que utiliza uma fila de mensagens}
\label{fig:app_fila_de_mensagens}
\end{figure}
  

Estabelecida a fila de mensagens, é necessário agora, definir-se as tarefas que
irão enviar e receber mensagens da mesma. Na
figura~\ref{fig:app_fila_de_mensagens} estão presentes apenas as rotinas de cada uma dessa tarefas, sendo que a explicação completa de como é criar uma tarefa foi
demonstrada na seção~\ref{subsec:criacao_tarefa}. 

Para criar a tarefa que enviará mensagens para a fila, a rotina da tarefa
\textit{sendTask} é desenvolvida. Nela esse trabalho é feita através da operação
\textit{xQueueSend} , que possui como parâmetros a fila para qual a mensagem
será enviada, a mensagem que será enviada para a fila e tempo máximo que a tarefa
poderá ficar bloqueada aguardando para enviar uma mensagem para fila, caso ela
esteja cheia.

Por último, na figura~\ref{fig:app_fila_de_mensagens} a rotina da tarefa
responsável por receber mensagens da fila, é criada. Ela é denominada de
\textit{sendTask}. Para receber as mensagens enviadas para a fila,
\textit{sendTask} utiliza a operação \textit{xQueueReceive}, a qual possui como
argumentos, respectivamente, a fila de onde será recebida a mensagem, o local que
irá armazenar a mensagem e o tempo máximo que a tarefa pode ficar esperando pela
fila, caso está esteja vazia.


\subsection{Utilização do semáforo}

Semáforos são estruturas de sincronização entre tarefas. Eles são utilizados para
coordenar o uso de recurso compartilhado por uma ou mais tarefas. Assim, código
da tarefa responsável por acessar o recurso compartilhado deve ser protegido para
que a sua execução só ocorra quando o semáforo for retido pela tarefa.

A construção de uma aplicação que utiliza-se do mecanismo de semáforo, são
necessário basicamente três funcionalidades da biblioteca de semáforos,
\textit{vSemaphoreCreateBinary}, \textit{xSemaphoreTake} e
\textit{xSemaphoreGive}. A primeira funcionalidade cria o semáforo e as demais
solicitam e liberam o semáforo respectivamente.

O exemplo de uma aplicação que utiliza-se de um semáforo para controlar o acesso
a um recurso compartilhado pode ser visto na figura~\ref{fig:app_semaforo}. Nela
inicialmente é criada a variável \textit{xSemaphore} para armazenar uma
referência para o novo semáforo. Em seguida, o método
\textit{vSemaphoreCreateBinary} é usado para criar o novo semáforo e retornar uma
referência para o mesmo.

\begin{figure}[!h] \centering
\begin{small}

\begin{verbatim}

xSemaphoreHandle xSemaphore = NULL;


// Create the semaphore to guard a shared resource. As we are using 
// the semaphore for mutual exclusion we create a mutex semaphore 
// rather than a binary semaphore. 
xSemaphore = xvSemaphoreCreateBinary();

// A task that uses the semaphore. 
void semaphoreTask( void * pvParameters ) { 
    // ... Do other things.
    if( xSemaphore != NULL ) {
        // See if we can obtain the semaphore. If the semaphore is not available 
        // wait 10 ticks to see if it becomes free. 
        if( xSemaphoreTake( xSemaphore, ( portTickType ) 10 ) == pdTRUE ) { 
            // We were able to obtain the semaphore and can now access the 
            // shared resource.
            // We have finished accessing the shared resource. Release the 
            // semaphore. 
            xSemaphoreGive( xSemaphore ); 
        } else
            // We could not obtain the semaphore and can therefore not access 
            // the shared resource safely 
       { 
    } 
} 
\end{verbatim}
\end{small}
\caption{Aplicação que demonstra a utilização de um semáforo}
\label{fig:app_semaforo}
\end{figure}

Após a criação do semáforo, a rotina da tarefa que utilizará o recurso
compartilhado é desenvolvida. Nela o código que acessará tal recurso está
protegido pelo segundo \textit{if}, o qual recebe o retorno do método
\textit{xSemaphoreTake}, informando se o semáforo foi retido ou não. Ao final da
rotina, o semáforo é liberado pelo método \textit{xSemaphoreGive}, permitindo que
outra tarefa possa reté-lo e usar o recurso compartilhado.


A utilização do mutex é bem parecida com a do semáforo binário. A diferença para
o usuário entre os dois mecanismo está apenas no método de criação,
\textit{vSemaphoreCreateBinary} no semáforo binário, que será
\textit{xSemaphoreCreateMutex}. As formas e os métodos para solicitação do mutex
é semelhante ao semáforo binário, sendo \textit{xSemaphoreTake} informando o
mutex e o tempo máximo de bloqueio e \textit{xSemaphoreGive} informando o mutex
que será liberado. Com isso para transformar a aplicação da
figura~\ref{fig:app_semaforo} de semáforo pra mutex basta apenas trocar o método
\textit{vSemaphoreCreateBinary} por \textit{xSemaphoreCreateMutex}.


\chapter{Método B}

Métodos Formais trata-se de uma abordagem formal para a especificação e
construção de sistemas computacionais. Eles utilizam-se de conceitos matemáticos
sólidos como lógica de primeira ordem e teorias dos conjuntos para a criação e
verificação de sistemas consistentes, seguros e sem ambiguidades. Devido aos seus
rigorosos métodos de construção a sua principal utilização, embora timidamente,
tem sido na criação de sistemas críticos para as indústrias de aeronáutica,
viação férrea e de equipamentos médicos, além de empresas que movimentam grandes
quantidade monetárias como os bancos.

%SG->DD:
% Talvez seja melhor retirar o parágrafo abaixo, mas acho que ele da uma
% atrativo a mais para a utilização de métodos formais
% A base teórica dele esta em
% www51.honeywell.com/aero/technology/common/documents/formal-methods.pdf
% Não sei se é uma fonte bibligráfica válida

Segundo a Honeywell \cite{honeywell},uma empresa que desenvolve sistemas para
aeronaves, a utilização de métodos formais no processo de desenvolvimento prover
várias vantagens, entre eles estão: a produção mensurada pela corretude, métodos
formais prove uma forma objetiva de mensura a corretude do sistema; antecipação
na detecção de erros, métodos formais são previamente usados em projetos de
artefatos do sistema, permitindo assim uma detecção antecipada de erros; e
garantia da corretude, através mecanismo de verificação é possível provar que
sistema funcionará de forma coerente com a sua especificação inicial.

O método B\cite{Abrial J.} trata-se de uma abordagem formal usado para
especificar e construir sistema computacionais seguros. Seu criado Jean-Raymond
Abrial, junto com a colaboração de outros pesquisadores da universidade de
Oxford, procuraram reunir no método B várias qualidades presentes nos demais
método formais como pré e pós condições\footnote{Pré e Pós condições são\ldots},
refinamento\footnote{Refinamento trata-se de um técnica de desenvolvimento de
sistema\ldots} e modularização. A seguir tem-se a etapas de desenvolvimento de
sistemas utilizando o método B.




%o método B proporciona uma criação de sistemas através de sucessiveis níveis de
%abstração, na qual inicialmente cria-se um modulo abstrato em uma linguagem de
%modelagem. Esse módulo é refinado através de vários outros módulos até chegar
%em uma linguagem algorítmica, denominada B0, que pode ser traduzida
%automaticamente em algumas linguagem de programação imperativa com C, Ada,
%Java, JavaCard e C\#.

%Cada módulo criado no desenvolvimento do sistema com o método B deve ser
%analisado estaticamente para saber se ele é implementável ou consistente, ou
%seja, que sua execução não leve a um estado não permitido pela especificação.
%Assim como também cada nível de abstração deve ser analisado estaticamente para
%saber se ele é coerente com o nível acima.

\section{Etapas do desenvolvimento em B}

O processo de desenvolvimento através do método B inicia-se com um módulo que
define um modelo funcional de alto nível do sistema. Em B, esses módulos são
denominados de Máquina Abstrata (\textit{MACHINE}). Nessa fase de modelagem
técnicas semi-formais como UML podem ser utilizadas e em seguidas transformadas
para a notação formal do método B. Após a criação dos módulos, eles são
analisados estaticamente para verificar se a sua especificação é coerente e
implementável.

Uma vez estabelecido um modelo abstrato inicial do sistema, o método B permite que
seja construídos módulos mais concretos do sistema denominados refinamentos. Mais
especificamente refinamentos tratam-se de uma decisão de projetos na qual partes da
especificação abstrata do sistema devem ser especificadas em um nível mais
concreto. Assim um refinamento deve necessariamente estar relacionado com o
módulo mais abstrato ligeiramente anterior. E, como ocorre na criação da máquinas
abstratas, um refinamento também e passível uma análise estática, na qual é
verificada a relação entre refinamento com seu nível abstrato anterior.

Devido a técnica de refinamentos, o desenvolvimento de sistemas utilizando o
método B pode chegar a um nível de abstração semelhante aos das linguagens de
programação. Para isso sucessíveis refinamentos devem ser desenvolvidos até a
especificação chegar em um último nível de refinamento denominado implementação
(\textit{IMPLEMENTATION}). Nesse nível a linguagem utilizada para a
especificação, B0, trata-se de um formalismo algorítmico, capaz de ser
sintetizados para linguagens de programação com C, Java e JavaCard.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.9]{../fig/desenvolvimento_b.jpg}
\caption{Etapas de desenvolvimento de sistema através do método B}
\label{fig:desenvolvimento_b}
\end{figure}

Assim o desenvolvimento de sistemas utilizando o método B é feito como demonstra
a figura~\ref{fig:desenvolvimento_b}. Nela os requisitos do sistema são
especificados inicialmente em um alto nível abstrato e após sucessivos
refinamentos um nível concreto e algorítmico do sistema é alcançado. Em seguida é
feita a síntese da especificação para o código de linguagem de programação, sendo
possível a partir da especificação funcional inicial gerar teste para o sistema
desenvolvido.

Atualmente o desenvolvimento de sistemas utilizando o método B pode ser apoiado
por diversas ferramentas que vão desde a análise estática da especificação até a
geração de código em linguagens de programação. Fator que isentivou, o método B a
ultrapassar o mundo acadêmica e passar a ser usado também industrialmente. 

Um exemplo de sistemas desenvolvidos através da abordagem de B é o controle
de porta do metrô de paris, desenvolvido pela Clearsy\cite{clearsy}, empresa
especialista em sistemas críticos. Esse sistema impede que o trem saída da
estação quando a porta inda estiver aberta, evitando assim possíveis acidentes 

\section{Máquina Abstrata}

A base do método B está na notação de máquina abstrata(em inglês:
\textit{Abstract Machine Notation} - AMN) a qual disponibiliza um framework comum
para a especificação e construção e verificação estática de sistemas. Em outra
palavras, a AMN trata-se de uma linguagem de especificação de sistemas formada
por módulos básicos de construção chamados de Máquina Abstrata ou simplesmente
Máquina.

Cada Máquina Abstrata é composta por diferentes seções, sendo que cada seção é
responsável por definir um aspecto da especificação do sistema como: parâmetros,
tipos, constantes, variáveis de estado, estados iniciais e transições do sistema.
Por exemplo, a figura~\ref{fig:maquina_kernel} contém uma Máquina Abstrata,
chamada \textit{Kernel}, a qual especifica um sistema que permite incluir e
excluir tarefas até o limite de 10 tarefas e possui as seguintes seções:


\begin{description}
\item[MACHINE] Nessa seção inicia-se
o código da máquina abstrata. Ela identifica a natureza e o nome do módulo,
seguido opcionalmente por um ou mais parâmetros separados por vírgula e
limitados por parenteses
\item[SETS] introduz um novo tipo de entidade, no exemplo é
  $\mathit{TASK}$. Nesse momento, nenhum detalhe é fornecido quanto à
  maneira como essa entidade será implementada.
\item[VARIABLES] informa o nome das diferentes variáveis que compõem o estado.
No exemplo, apenas há uma variável de estado: $\mathit{tasks}$.
\item[INVARIANT] especifica o tipo das variáveis de estado assim
  também como os estados válidos do sistema. Aqui, $\mathit{tasks}$ é
  um conjunto de até 10 elementos do tipo $\mathit{TASK}$. A
  caracterização lógica do conjunto dos estados válidos é uma das
  atividades mais importantes da especificação.
\item[INITIALISATION] identifica quais são os possíveis estados
  iniciais do sistema. No caso, $\mathit{tasks}$ é o conjunto vazio.
\item[OPERATIONS] determina os diferentes tipo de eventos que o
  sistema pode sofrer. No nosso exemplo, temos operações para
  adicionar e eliminar um elemento de $\mathit{tasks}$. Uma operação
  pode ter parâmetros, resultados e pode alterar o valor de variáveis
  de estado. Um ponto importante encontrados nas operações são as pré-condições,
  a quais são condições que devem ser satisfeitas para que a operação seja
  realizada
\end{description}  
\begin{figure}[!ht]
\begin{small}

$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\MACHINE\\
\quad \mathit{Kernel}\\
    
\SETS\\
\quad \mathit{TASK}\\
    
\VARIABLES\\
\quad \mathit{tasks}\\
    
\INVARIANT\\
\quad \mathit{tasks} \in \pow(\mathit{TASK}) \land \\
\quad \card(\mathit{tasks})\leq 10\\
    
\INITIALISATION\\
\quad \mathit{tasks}:=\emptyset\\
    
\end{array}
\begin{array}[t]{l}
\OPERATIONS\\\\
\mathit{task\_add}(\mathit{task}) = \\
\quad \PRE \\
\quad\quad \mathit{task}\in \mathit{TASK} \land \\
\quad\quad \mathit{task}\not\in \mathit{tasks} \land\\
\quad\quad \card(\mathit{tasks})<10\\
\quad \THEN\\
\quad\quad \mathit{tasks}:=\mathit{tasks}\cup \{\mathit{task}\}\\
\quad   \END;\\

\end{array}

\begin{array}[t]{l}
\ldots\\
\mathit{task\_delete}(\mathit{task})=\\
\quad \PRE\\
\quad \quad \mathit{task}\in \mathit{tasks}\\
\quad \THEN\\
\quad \quad \mathit{tasks}:=\mathit{tasks}-\{\mathit{task}\}\\
\quad \END\\
	
\END\\
\end{array}
\end{array}
$$
\end{small}
\caption{Maquina abstrata de tarefas}
\label{fig:maquina_kernel}
\end{figure}

Para uma melhor compreensão a especificação de sistemas através das maquinas
abstratas será resumidamente dividida em duas partes principais. Na primeira
parte serão colocadas informação a respeito dos estados da máquina, suas variáveis e
restrições. Na segunda parte, será especificado o comportamento da máquina, ou
seja a sua parte dinâmica com a inicialização e operações. Essas duas partes
serão melhores discutidas a seguir.

\subsection{Especificação do estado da máquina}

Na parte do estado de uma máquina são colocados os estado que a máquina pode
assumir.Este é definido através de suas variáveis e do seu invariante. Nas
variável são colocados os nomes dos estados das máquinas e no invariantes suas
restrições, sendo que uma especificação só pode garantir o correto funcionamento
da máquina quando esta encontra-se em um estado válido, nada podendo afirmar para
os demias estados.

O estado de uma máquina é especifica, por meio de calculo de predicados, da
teoria do conjunto e relações entre conjuntos, permitindo com isso a análise
estática da máquina através de lógica matemática.No exemplo da
figura~\ref{fig:maquina_kernel} o estado da máquina \textit{kernel} foi
especificado como sendo a variável $\mathit{tasks}$ e seu predicados
$\mathit{tasks} \in \pow(\mathit{TASK})$ e $ \card(\mathit{tasks})\leq 10$, os
quais definem que $\mathit{tasks}$ deve ser um conjunto de $\mathit{TASK}$ e
que o tamanho máximo permitido para o conjunto é de dez elementos.

\subsection{Especificação das operações da máquina}

Nas operações da máquina é especificado o comportamento dinâmico do sistema. É
através das operações que o estado da máquina é alterado, respeitando sempre as
suas restrições. Mais especificamente as condições declaradas no invariante dá
máquina deve ser sempre satisfeita no final da operação, levando assim a
máquina a um estado válido.

O cabeçalho de uma operação é composto por um nome, uma lista de parâmetro de
entra e uma lista de parâmetro de saída \footnote{A notação de máquina abstrata
permite que uma operação retorne mais de um parâmetro}, sendo que os parâmetro de
entrada e os parâmetros de saída são argumentos opcionais. Assim o exemplo de um
operação com parâmetros de entrada e saída pode ser visto na
figura~\ref{fig:query_task}, na qual o nome da operação é $\mathit{query\_task}$,
o parâmetro de entrada é $\mathit{task}$ e o parâmetro de saída é
$\mathit{belong}$.

A operação propriamente dita é formada por pré-condição e corpo da operação. Na
pré-condição, são colocadas as informações sobre todos os parâmetros de entrada e
as condições que devem ser satisfeitas para que a operações seja executada. Com
isso, a pré condição funciona como uma premissa que deve ser suprida para que a
operação funcione corretamente.

Por exemplo, na figura~\ref{fig:maquina_kernel} para que a operação
$\mathit(add_task)$ funcione corretamente e não leve a máquina para um estado
inválido as pré-condições $\mathit{task}\in \mathit{TASK}$, $\mathit{task}\not\in
\mathit{tasks}$ e $\card(\mathit{tasks})<10$ devem ser obedecidas.

\begin{figure}[!ht]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
\mathit{ans}\leftarrow \mathit{query\_task}(\mathit{task}) =\\
\PRE
\quad \mathit{task} \in \mathit{TASK}\\
\THEN\\
\quad\quad \IF \quad \mathit{task} \in \mathit{TASK} \\
\quad\quad \THEN \quad ans := yes\\
\quad\quad \ELSE \quad ans:=no\\
\END
\end{array}
\end{array}
$$
\end{small}
\caption{Operação que consulta se uma tarefa pertence a máquina
$\mathit{Kernel}$}
\label{fig:query_task}
\end{figure}

No corpo da operação é especificado o seu comportamento. Nele os parâmetros saída
devem ser obrigatoriamente valorados e os estados da máquina são alterados ou
consultados. Assim, para realizar as atualizações de estadas e definições de
parâmetros de saída de modo formal, a notação de máquina abstrata possui um
conjunto de atribuições abstratas, denominadas substituições, que possuem regras
de como tal atribuições é realizada, permitindo assim uma analise estática da
operações em relação a consistência da máquina. A seguir são demonstradas
algumas das principais substituições da AMN.


\subsubsection{Substituição Simples}

A substituição simples é definida da seguinte forma: $$\mathit{x}:= \mathit{E}$$
Nela $\mathit{x}$ trata-se da variável da máquina ou parâmetro de saída, para o
qual será atribuído o valor da expressão $\mathit{E}$. Mais precisamente uma
substituição é interpreta da seguinte maneira:

$$[\mathit{x}:=\mathit{E}]\mathit{P}$$ 

Assim tem-se que o predicado $\mathit{P}$ deve ser mantido quando a variável
$\mathit{x}$ for substituída por $\mathit{E}$. Por exemplo na operação
$\mathit{add_task}$ a substituição $\mathit{tasks}:=\mathit{tasks}\cup
\{\mathit{task}\}$ pode ser vista como $[\mathit{tasks}:=\mathit{tasks}\cup
\{\mathit{task}\}] \card(\mathit{tasks})<10$, Na qual $\card(\mathit{tasks})<10$
é o predicado, no caso o invariante da máquina, que deve ser obedecido quando a
substituição for realizada, ficando ao final $\mathit{tasks}\cup
\{\mathit{task}\}<10$.

\subsubsection{Substituição Múltipla}

A substituição múltipla trata-se de uma generalização da substituição simples. Ela
permite que várias variáveis seja atribuídas simultaneamente. Assim uma
substituição múltipla utilizando duas variável tem a seguinte forma:

$$\mathit{x},\mathit{y}:=\mathit{E},\mathit{F}$$ 

Na definição acima as variáveis $\mathit{x}$ e $\mathit{y}$ são atribuído os
valores das expressões $\mathit{E}$ e $\mathit{F}$, respectivamente. Assim da
mesma forma que a substituição simples, a múltipla substituição é definida da
seguinte maneira: $$[\mathit{x}:=\mathit{E},\mathit{y}:=\mathit{F}]\mathit{P}$$
Na qual $\mathit{P}$ é o predicado que deve ser verdadeiro quando suas variáveis
$\mathit{x}$ e $\mathit{y}$ forem substituídas por $\mathit{E}$ e $\mathit{F}$,
respectivamente. Por exemplo, uma máquina que possui o predicado
$\mathit{x}<\mathit{y}$ e possui a seguinte substituição $\mathit{x},\mathit{y}
:=\mathit{x}+10,\mathit{y}+5$ é reduzida a seguinte forma $[\mathit{x},\mathit{y}
:=x+10,y+5]\mathit{x}<\mathit{y}$, o que resulta em $\mathit{x}+10<\mathit{y}+5$

\subsubsection{Substituição Condicional}

As substituições simples e múltiplas permitem somente uma opção de especificação
onde uma atribuições é sempre feitas de maneira uniforme sem opções e sem levar
consideração os estados iniciais da operação. Entretanto, as linguagens de
programação convencionais disponibilizam um tipo condicional de atribuição na
qual é permitido caminhos diferente de acordo com expressões lógicas que utilizam
o valores iniciais das variáveis do sistema. Esse tipo de atribuição é
feita através da formação $\IF$ $\THEN$ $\ELSE$.

Como nas linguagens de programação, a notação de máquina abstrata também permite
a construção de atribuições condicionais, as quais são feitas através da
substituição condicional. Com isso, uma substituição condicional funciona da
mesma forma que nas linguagens de programação, não qual uma expressão lógica é
avaliada para saber qual caminha a estrutura deve seguir, e qual atribuição deve
ser realizada. A forma como é especificada uma substituição condicional na ANM
pode ser visto a seguir:

$$\IF \quad \mathit{E}\quad \THEN\quad \mathit{S}\quad \ELSE\quad \mathit{T}$$

Na especificação acima $\mathit{S}$ e $\mathit{T}$ são substituições de qualquer
tipo e tem as suas execuções condicionadas pela expressão lógica $\mathit{E}$,
na qual pode conter variáveis da máquina como também os parâmetros de entrada da
operação. Com isso, caso $\mathit{E}$ seja afirmativo a substituição $\mathit{S}$
é realizada e caso ele seja negativo a substituição $\mathit{T}$ é executada.
Assim uma substituição condicional pode ser interpretada da seguinte forma:

$$[\IF \quad \mathit{E} \quad \THEN \quad \mathit{S} \quad \ELSE
\quad \mathit{T}] \mathit{P} \quad = \quad (\mathit{E} \Longrightarrow
[\mathit{S}] P )\land (\neg\mathit{E} \Longrightarrow [\mathit{T}]
\mathit{P})$$.

Nessa interpretação se é for verdadeiro a substituição $\mathit{S}$ deve
satisfazer o predicado $\mathit{P}$. E caso o valor de $\mathit{E}$ seja negativo
a substituição $\mathit{T}$ deve satisfazer o predicado $\mathit{P}$.

Um exemplo simples da utilização dessa substituição pode ser visto na
figura~\ref{fig:query_task}. Nela a expressão $\mathit{task} \in \mathit{TASK}$ é
primeiramente analisada para decidir qual substituição simples deve ser
executada. Caso a o resultado da expressão seja afirmativo $\mathit{ans} :=
\mathit{yes}$ é executada e caso a expressão seja negativa $\mathit{ans} :=
\mathit{no}$ é executada.
 
\subsubsection{Substituição não determinística $\ANY$}

As substituições vistas até agora seguem uma metodologia determinística, ou seja,
são substituições que possuem um comportamento previsível, que levam a apenas um
resultado final é pré-determinado. Entretanto, as máquinas abstratas em B são
utilizadas para fazer especificações iniciais de sistemas ou componentes e,
maioria das vezes, no início de uma especificação o comportamento do sistema não
é totalmente conhecido. Assim, para especificar o indeterminismo inicial de um
sistema a notação de máquina abstrata disponibiliza um tipo
especial de substituições determinadas como substituições não determinísticas.

As substituições não determinísticas são substituições que introduzem escolhas
aleatórias no corpo das operações, levando a mesma não mais para um estado final
previsível e sim para um conjunto de estados finais diferentes para cada execução
da operação. Assim em uma substituição não determinística a especificação define
apenas o conjunto sobre o qual deve ser feita a escolha abstraindo assim
informações de como tal escolha deve ser realizada. Em outras palavras, em uma
substituição não determinística existem o conjunto de estado finais possíveis que
podem ser alcançados a cada execução da substituição.

Uma substituição não determinística definida na AMN é a substituição $\ANY$.
Essa substituição possui o seguinte formato:
  
$$\ANY\quad\mathit{x}\quad\WHERE \quad\mathit{Q}\quad\THEN\quad\mathit{T}\quad\END$$

Através da definição acima percebe-se que a substituição $\ANY$ é formada por
três elementos:

\begin{description}
\item[$\mathit{x}$]trata-se de uma lista de variável que será utilizada no
corpo da substituição e para as quais serão escolhidos valores abstratos
delimitados pelo o predicado $\mathit{Q}$.
\item[$\mathit{Q}$] são predicados que delimitam o conjunto de opções para as
variáveis $\mathit{x}$. Nessa parte as variáveis $\mathit{x}$ devem
obrigatoriamente serem tipificadas.
\item[$\mathit{T}$] é denominado corpo da substituição. Nele são colocados
atribuições que utilizam-se das variáveis $\mathit{x}$ para atualizar estados
ou atribuir valores para os parâmetros de saída de uma operação
\end{description}

Um exemplo da substituição $\ANY$ pode ser visto na operação da
figura~\ref{fig:random_create}. Nela uma tarefa é aleatoriamente adicionada na
máquina $\mathit{Kernel}$. Primeiramente a variável $\mathit{task}$ é criada para
armazenar um valor aleatório. Em seguida, o tipo e a restrição sobre
$\mathit{task}$ é definida, conjunto da escolha aleatória. Por último, a variável
$\mathit{task}$ é adicionada ao conjunto $\mathit{tasks}$. Assim um comportamento
não determinístico é atribuído a operação, pois para cada execução da operação a
variável $\mathit{task}$ pode assumir um valor aleatório.
 

\begin{figure}[!ht]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
\mathit{random\_create}=\\
\PRE\\
\quad\card(\mathit{tasks})<9 \\
\THEN\\
\quad \ANY \\
\quad\quad \mathit{task}\\
\quad \WHERE \\
\quad\quad \mathit{task}\in \mathit{TASK} \land\\
\quad\quad \mathit{task} \not\in \mathit{tasks}\\
\quad \THEN\\
\quad\quad \mathit{tasks}:=\mathit(tasks)\cap \mathit{task}\\
\quad \END\\


\END
\end{array}
\end{array}
$$
\end{small}
\caption{Operação que cria uma tarefa aleatória na máquina
$\mathit{Kernel}$}
\label{fig:random_create}
\end{figure}

Uma definição para a substituição $\ANY$ seria: 

$$\forall \mathit{x}.(\mathit{Q} \Rightarrow [\mathit{T}]\mathit{P})$$ 

Indicando que para todo valor que for escolhido para o conjunto de variável
$\mathit{x}$ as substituições $\mathit{T}$ devem garantir o predicado
$\mathit{P}$.

\section{Obrigação de Prova}

Após a criação de uma máquina abstrata utilizando o método B ela deve ser
avaliada estaticamente para saber se a mesma é coerente e passível de
implementação. Para realizar tal avaliação o método B dispõe de um conjunto de
obrigações de prova, expressões lógica, geradas a partir de uma especificação em
B.

Resumidamente, a análise estática de uma máquina abstrata, através das
obrigações de prova, avalia primeiramente se a máquina possui estados válidos, ou
seja, se pelo menos uma combinação de estados é alcançada pela máquina. Caso a
máquina possua estados válidos, é avaliada se estes são alcançados ao final de
cada operações e na inicialização da máquina. Com isso as principais obrigações
de prova gerada em uma máquina abstrata são: Consistência do invariante,
Obrigação de prova da inicialização e Obrigação de prova das operações. A seguir
tem-se em maior detalhe cada uma dessa obrigações de prova e como elas são
geradas.

\subsection{Consistência do Invariante}

Nessa obrigação de prova é analisado se o invariante da máquina possui pelo menos
uma combinação em que todos os estados são válidos, ou seja, possui pelo menos um
estado válido. Assim essa obrigação de prova é definida da seguinte maneira :
 
$$\exists\mathit{v}.\mathit{I}$$

Onde $\mathit{v}$ indica o vetor de todos as variáveis da máquina e $\mathit{I}$
representa o Invariante da máquina. Com isso, a definição acima pode ser
entendida como: Deve existir pelo menos um valor para o vetor de variáveis
$\mathit{v}$ que satisfaça o invariante $\mathit{I}$

Um exemplo da aplicação desse obrigação de prova na máquina da
figura~\ref{fig:maquina_kernel} seria: 

$$\exists\mathit{tasks}.(\mathit{tasks} \in \mathit{TASK} \cap
\card(\mathit{tasks})\leq 10)$$

O que pode ser provador como verdadeiro para $\mathit{tasks} = \emptyset $


\subsection{Obrigação de prova da inicialização}

Outra obrigação de prova necessária para uma máquina abstrata é saber se seu
estado inicial satisfaz o invariante. Isso significa, verificar se o estado
inicial da máquina é um estado válido. Assim, essa obrigação de prova é definida
da seguinte maneira : 

$$[\mathit{T}]\mathit{I}$$

Nela $[\mathit{T}]$ indica as substituições realizadas na inicialização da
máquina e $\mathit{I}$ indica as restrições definidas no invariante. Com isso, a
obrigação de prova da inicialização da máquina da figura~\ref{fig:maquina_kernel}
pode ser definida como sendo:

$$[\mathit{task}:= \emptyset] (\mathit{tasks} \in \mathit{TASK} \cap
\card(\mathit{tasks})\leq 10) \quad \Rightarrow\quad \emptyset \in \mathit{TASK}
\cap \card(\emptyset)\leq 10$$

O que pode ser facilmente deduzido como uma verdade.

\subsection{Obrigação de prova das Operações}

Na obrigação de prova das operações deve ser analisado se, quando satisfeita a
sua pré-condição, a execução da operação levará a máquina a um estado válido.
Assim a definição dessa obrigação de prova pode ser vista da seguinte maneira:

$$\mathit{I} \land \mathit{P} \Rightarrow [\mathit{S}]I$$

Na definição acima $\mathit{I}$ representa o invariante da máquina, $\mathit{P}$
representa a pré-condição da operação analisada e $\mathit{S}$ indica as
substituições realizadas no corpo da operação. Assim, uma explicação mais precisa
dessa definição seria: quando a máquina estiver em um estado válido e a
pré-condição da operação for satisfeita, a execução da operação deve manter a
máquina em um estado válido. Nota-se assim que esta obrigação de prova não
torna-se necessária as operações que não alteram o estado da máquina, chamada de
operações de consulta, como a da figura~\ref{fig:query_task} onde apenas o
valor da parâmetro de retorno é alterado, pois nelas nenhum estado da máquina
é alterado.

Um exemplo de uma obrigação de prova da operação $\mathit{add_task}$ da máquina
da figura~\ref{fig:task_states} pode ser visto a seguir:

$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
(\mathit{tasks} \in \mathit{TASK} \land
\card(\mathit{tasks})\leq 10) \land 
(\mathit{task}\in \mathit{TASK} \land \mathit{task}\not\in \mathit{tasks})
\Rightarrow \\
([\mathit{tasks}:=\mathit{task}\cap\mathit{task}]((\mathit{tasks}
\in \mathit{TASK} \cap \card(\mathit{tasks})\leq 10))))
\end{array}
\end{array}
$$
 

\section{Refinamento}

A linguagem abstrata demonstratada até agora é usada principalmente para criar
uma modelagem funcional de sistemas e componentes. Nela o principal objetivo é
descrever o comportamento do sistema sem se preocupar com detalhes de como tal
comportamento será implementado ou de como os dados serão manipuladas pelo
computador. Entretanto, para realizar uma modelagem mais concrete e passível de
implementação é necessário que notações matemáticas abstratas utilizadas na
modelagem do sistema, como conjuntos e substituições não determinística, sejam
descritas de forma mais concreta.

Através da técnica de refinamento o método B possibilita um desenvolvimento
gradativo do sistema. Nele um sistema é especificado em estágios que vão da
modelagem abstrata até um nível algoritmo denominada de implementação. Entre esse
níveis de abstração existem um modelos intermediário chamados de refinamentos,
que combina especificações de construção e detalhes de implementação.

Mais precisamente, refinamentos são decisões de projeto nas quais estruturas
abstratas são detalhadas em um nível mais concreto. Com isso, um refinamento deve
obrigatoriamente está ligado a um modelo abstrato anterior e possui um
comportamento delimitado pelo o modelo a qual está relacionado. Para garantir
que essa relação entre módulo seja feita de forma coerente existem mecanismo de
análise estática denominados obrigações de prova do refinamento, o qual será
detalhado na seção~\ref{subsec:obrigacao_de_prova_refinamento}.

A construção de um refinamento é muito parecida com a construção de uma máquina
abstrata. Ele, assim como a máquina abstrata, é dividido em seções onde são
especificadas as informações do sistema, possuindo basicamente as mesma seção de
uma máquina abstrata. A diferença de um refinamento para os demais módulos está
na seção $\REFINEMENT$ e $\REFINES$ na seção, onde são colocados respectivamente
o nome do refinamento e o módulo que será refinado. 

 Como ocorreu na seção da máquina abstrata \ref{s}, para uma melhor entendimento
 e analogia à construção de uma máquina abstrata, a especificação de um
 refinamento basicamente em duas parte principais especificação do refinamento
 dos estados e especificação do refinamento das operações. Em seguida tem-se
 o delineamento dessas duas partes principais.

\subsection{Refinamento do Estado}

No refinamento de dados, como é reconhecido o refinamento do estado, tem-se o
objetivo de especificar o estado de uma máquina em uma forma mais concreta, ou
seja mais próxima a utilizada pelo computador. Para isso estruturas abstratas
como conjuntos e relações são substituídas por mecanismo mais implementáveis
como vetores e sequências.

Como foi dito anteriormente, um refinamento necessita estar relacionado com um
nível abstrato ligeiramente acima dele. No refinamento de dados essa relação é
feita através de um mecanismo denominado \textit{relação de refinamento}.
Assim, a \textit{relação de refinamento} nada mais é do que conjunções lógicas
que ligam o estado do refinamento ao estado do módulo refinado por ele.

Um exemplo de refinamento de dados pode ser visto na
figura~\ref{fig:refinamento_kernelR}. Nela é feito o refinamento da máquina
$\mathit{Kernel}$ (figura~\ref{fig:maquina_kernel}), qual possui o estado
$\mathit{task}$ especificado como sendo um conjunto de tarefa. Entretanto, conjunto
são representações abstrata de dados. Assim no refinamento $\mathit{KernelR}$ o
estado $\mathit{task}$ é refinado por $\mathit{taskR}$, que trata-se de um
sequência de tarefas, estrutura mais concreta que um conjunto. A relação de
refinamento entre os dois estado é feita através da igualdade
$\mathbf{ran}(\mathit{tasks\_r})=\mathit{tasks}$.


\begin{figure}[!ht]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathbf{REFINEMENT}\\
\quad \mathit{Kernel\_r}\\
   
\REFINES\\
\quad \mathit{Kernel}\\
   
\VARIABLES\\
\quad \mathit{tasks\_r}\\
\end{array}

    

\begin{array}[t]{l}
\INVARIANT\\
\quad \mathit{tasks\_r} \in \mathbf{seq}(\mathit{TASK}) \land \\
\quad \mathbf{ran}(\mathit{tasks\_r})=\mathit{tasks}\\
    
\INITIALISATION\\
\quad \mathit{tasks\_r}:=[]\\
\end{array}


\begin{array}[t]{l}
\OPERATIONS\\
\mathit{task\_add}(\mathit{task}) = \\
\quad \BEGIN\\
\quad \quad \mathit{tasks\_r}:=\\
\quad\quad\quad\quad\mathit{task} \to \mathit{tasks\_r}\\
\quad \END\\
    
\END
\end{array}

\end{array}
$$
\end{small}
\caption{Refinamento da maquina abstrata de $\mathit{Kernel}$}
\label{fig:refinamento_kernelR}
\end{figure}


\subsection{Refinamento das Operações}

Após feito o refinamento do estado da máquina é necessário agora especificar o
refinamento das suas operações. O refinamento das operações de uma máquina deve
garantir que está possua os mesmo comportamentos que suas operações abstratas,
podem até fazer menos ações que as operações refinadas, sendo proibido apenas as
ações adicionais.

As operações de um refinamento devem possuir a mesma assinaturas das operações do
módulo relacionado à ele, mesmo nomes e parâmetros de entrada e saída.
Entretanto, nas operações de um refinamento não é necessário a declaração da pré
condição ($\PRE$), uma vez que essa foi definida em um nível mais abstrato e são
suficientes para garantir que o tipo do parâmetro de entrada permaneça o mesmo e
que o invariante da máquina seja mantido quando a operação for executada.

Um exemplo do refinamento de uma operação pode ser visto na operação
$\mathit{add\_task}$ do refinamento $\mathit{KernelR}$
(figura~\ref{fig:refinamento_kernelR}). Nela percebe-se a ausência da pré
condição e que a assinatura da operação permanece a mesma. A parte alterada foi
apenas o corpo da operação que foi adaptada para trabalhar com o estado
$\mathit{taskR}$.


\subsection{Obrigação de Prova do refinamento}
\label{subsec:obrigacao_de_prova_refinamento}
A analise estática para saber se um refinamento e consistente com o nível
abstrato acima dele é feita através de obrigações de prova e pode ser dividida em
duas partes, obrigação de prova da inicialização e obrigação de prova das
operações. Entretanto, na obrigação de prova das operações são possíveis dois
tratamento diferentes, obrigações de prova para as operações sem parâmetro de
retorno e a obrigação de prova para as operações com parâmetro de retorno. A
seguir é demonstrada como é realizada cadas umas dessas obrigações de prova.

\subsubsection{Obrigação de Prova da Inicialização}

Em um refinamento, a ligação entre os estados da máquina abstrata e o refinamento
é feito através da \textit{relação de refinamento} a qual será denominada de
$\mathit{J}$. Assim necessariamente a inicialização da máquina abstrata deve
possuir algum estado que satisfaça essa ligação, ou, melhor dizendo, $\mathit{J}$
deve possuir algum estado especificado pela inicialização de máquina abstrata,
denominada $\mathit{T}$. Isso gera a seguinte asserção:

$$ \neg[\mathit{T}] \neg \mathit{J} $$ 

Na expressão acima tem-se que  $\mathit{T}$ deve possuir algum estado válido em
$\mathit{J}$, ou que, $\mathit{J}$ possui algum estado que satisfaça a
inicialização $\mathit{T}$.

Além disso é necessário também que a inicialização do refinamento denominado de
$\mathit{T1}$ esteja liga a esse conjunto de estados válidos definidos por
$\mathit{J}$ e $\mathit{T}$. Essa ligação ocorre da seguinte forma: todo estado
gerado na inicialização de $\mathit{T1}$ deve possuir um correspondente válido
de $\mathit{T}$.O que gera a seguinte definição:

$$ [\mathit{T1}]\neg [\mathit{T}] \neg \mathit{J} $$

Assim a obrigação de prova entre as máquina $\mathit{Kernel}$ e a máquina
$\mathit{KernelR}$ fica como demonstra a asserção abaixo:

$$
[\mathit{tasks\_r}:=[]]\neg[\mathit{tasks}:=\emptyset]\neg(\mathbf{ran}(\mathit{tasks\_r})=\mathit{tasks})
$$

\subsubsection{Obrigação de prova da operação sem parâmetro de retorno}
Geralmente uma operação é definida como $\PRE \mathit{P} \THEN \mathit{S} \END$,
sendo o seu refinamento $\PRE \mathit{P1} \THEN \mathit{S1} \END$, onde na
maioria da vezes $\mathit{P1}$ é abstraído. Com isso, do mesmo modo que na
inicialização, tem-se que os estado gerados em $\mathit{S1}$ devem estar
relacionado com alguma execução $\mathit{S}$, o que é definido na expressão
abaixo:
 
$$\mathit{S1} \neg \mathit{S} \neg \mathit{J}$$

Entretanto, diferente da inicialização, a execução de uma operação deve levar em
consideração o estado da máquina anterior à sua execução. Com isso o estado da
máquina abstrata junto com o seu refinamento devem ser um estado válido. Uma
relevante ligação entre esse estados e o invariante $\mathit{I}$ e a sua relação
de refinamento $\mathit{J}$. Além disso, para a correta execução da operação a pré
condição da mesma deve ser estabelecido. Assim, unido que uma operação só pode
ser executada corretamente quando houver uma ligação válida entre os estado da
máquina e a sua pré condição for estabelecida, a obrigação de prova de uma operação é
feita da seguinte forma:

$$\mathit{I} \land \mathit{J} \land \mathit{P} \Rightarrow \mathit{S1} \neg
\mathit{S} \neg \mathit{J}$$

Por exemplo, a obrigação de prova do refinamento da operação $\mathit{add_task}$
da máquina $\mathit{Kernel}$ é estabelecida como de acordo com a preposição
abaixo:


$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
(\mathit{tasks} \in \pow(\mathit{TASK}) \land \card(\mathit{tasks})\leq10)\land \\ 
\mathit{tasks\_r})=\mathit{tasks}  \land \\
\mathit{task}\in \mathit{TASK} \land \\
\mathit{task}\not\in \mathit{tasks} \land\\
\card(\mathit{tasks})<10 \Rightarrow 
[\mathit{tasks}:=\mathit{tasks}\cup \{\mathit{task}\}] \\
\neg[\mathit{tasks\_r}:= \mathit{task} \to \mathit{tasks\_r}] \\
\neg (\mathit{tasks\_r})=\mathit{tasks})
\end{array}
\end{array}
$$

\subsubsection{Obrigação de prova da operação com parâmetro de saída}

Devido uma obrigação do refinamento das operações, a qual obriga que cada saída
possível para o refinamento de uma operação deve está ligada a uma saída da
operação especificada, as operações com parâmetro de saída necessitam de uma
atenção especial . Assim denominando $\mathit{out'}$ como sendo os parâmetros de
saída do refinamento e $\mathit{out}$ os parâmetros de saída da especificação
tem-se que cada valor de $\mathit{out'}$ deve possuir um correspondente em
$\mathit{out}$. Em outra palavra, cada execução de $\mathit{S1}$ deve encontrar
uma execução $\mathit{S}$, na qual $\mathit{out'}$ produzido por $\mathit{S1}$
seja igual ao $\mathit{out}$ produzido por $\mathit{S}$.

Além da ligação entre o parâmetros de saída, no refinamento de uma operação com
retorno, deve-se obedecer todas as restrições impostas para o refinamento das
operações sem parâmetro de saída, ficando da seguinte maneira a obrigação de
prova das operações com retorno estabelecida da seguinte maneira:

$$\mathit{I} \land \mathit{J} \land \mathit{P} \Rightarrow
\mathit{S1}[\mathit{out'}/\mathit{out}] \neg \mathit{S} \neg \mathit{J}$$

Nela $[\mathit{out'}\mathit{out}]$ significa que na atribuições de $\mathit{S1}$
os valores de $\mathit{out}$ devem ser substituídos por $\mathit{out'}$ e manter
verdadeira a preposição, garantindo que cada produção de $\mathit{out}$ de
$\mathit{S1}$ tenha uma correspondente no conjunto $\mathit{out}$.



%\begin{itemize}
%  \item Explicar o que é o método B
%  \item Explicar a base teórica de B (AMN e as substituições)
%  \item Explicar como é especificado um sistema em B (como é criado um módulo)
%  \item Falar das obrigações de prova
%  \item Falar dos mecânismo de composição e refinamento
%  \item Dizer que o refinamento pode chegar em um nível concreto que pode ser
%  sintetizado para algumas linguagens de programação.
%  \item Falar do uso de ferramentas
%  \item Falar do projeto B2ASM
%\end{itemize}

\chapter{Revisão Literária}

 \begin{itemize}
  \item Enumerar Projetos
  \item Desafio de software verificado    
 \end{itemize}







\chapter{Proposta}

\begin{itemize}
  \item Como será feita a modelagem do FreeRTOS
  \item Falar do estudo do FreeRTOS e identificação dos seus principais
  conceitos e funcionalidades
  \item O desenvolvimento progressivo acrescentando novas funcionalidades a cada
  refinamento
  \item Ligar a abordagem do compilador verificável ao FreeRTOS
  \item Dizer como será ou deve feita a união do FreeRTOS para o compilador
  verificável
\end{itemize}

\chapter{Atividades e Etapas}

\newpage

\bibliographystyle{abnt-alf}
\bibliography{quali}

\anexo

\end{document}


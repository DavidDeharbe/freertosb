\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}

\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}  

\usepackage{amsmath}
\usepackage{amssymb}

\input{commands}

\sloppy

\title{Modelagem do Sistema Operacional de Tempo Real FreeRTOS para um
Desenvolvimento de Sistemas de Tempo Real Fidedignos}

\author{S. Galvão, D. Déharbe}


\address{Departamento de Informática e Matemática Aplicada\\
  Programa de Pós-graduação em Sistemas e Computação\\
  Universidade Federal do Rio Grande do Norte\\
  Campo Universitário, Lagoa Nova\\
  59078-970, Natal, RN, Brasil \\
  \email{\{stepgalvao,david\}@consiste.dimap.ufrn.br}
}

\begin{document} 

\maketitle

\begin{abstract}
  This meta-paper describes the style to be used in articles and short papers
  for SBC conferences. For papers in English, you should add just an abstract
  while for the papers in Portuguese, we also ask for an abstract in
  Portuguese (``resumo''). In both cases, abstracts should not have more than
  10 lines and must be in the first page of the paper.
\end{abstract}
     
\begin{resumo} 
  Este meta-artigo descreve o estilo a ser usado na confecção de artigos e
  resumos de artigos para publicação nos anais das conferências organizadas
  pela SBC. É solicitada a escrita de resumo e abstract apenas para os artigos
  escritos em português. Artigos em inglês deverão apresentar apenas abstract.
  Nos dois casos, o autor deve tomar cuidado para que o resumo (e o abstract)
  não ultrapassem 10 linhas cada, sendo que ambos devem estar na primeira
  página do artigo.
\end{resumo}


\section{Introdução}

%% DD: INTRODUCAO A REVER

A tecnologia da informação é uma característica intrínseca da vida quotidiana
moderna, a qual está fortemente dependente dos softwares presentes em quase todas
as tarefas da sociedade atual. Entretanto, para proporcionar uma maior comodidade
e segura aos seus usuários, a qualidade do sistema tornou-se um requisito
indispensável. Devido a isso, o desenvolvimento de sistemas com qualidade e
segurança deixou de ser uma ostentação para tornar-se uma necessidade na vida
moderna.

Um exemplo de sistemas presentes na sociedade atual que necessitam de um certo
grau de confiabilidade e segurança são os sistemas de tempo real. Esse tipo de
sistemas são geralmente embarcados e possuem como sua principal característica um
rigoroso tempo de resposta aos eventos externos do ambiente controlado por ele
\cite{li:03}. Devido isso e a sua facilidade de trabalhar em ambientes com uma
limitada quantidade de recursos, esses sistemas possuem uma larga utilização
podendo a sua funcionalidade varia do controle de eletrodomésticos até a
realização de operações críticas como o controle de aparelhos hospitalares e o
controle de transportes (aeronaves, trens e automóveis).

Foi devida essa grande necessidade do desenvolvimento de sistemas com qualidade
que a sociedade brasileira de computação, com a finalidade de intensificar as
pesquisar nessa área, classificou como um dos cinco grandes desafios da
computação ``o desenvolvimento tecnológico de qualidade'', no qual está presente
o tópico de ``desenvolvimento e adaptação de tecnologia e instrumento em geral de
apoio para à implementação e à avaliação de software fidedigno por
construção''\cite{sbc:2006}.

Ligado a esse tópico está também o desafio proposto pelo o pesquisador britânico
Jim, em \cite{jim:sbmf}, de especificar formalmente o sistema operacional de
tempo real FreeRTOS\cite{freertos:2008},o qual serve como uma ferramenta base
para o desenvolvimento de sistemas de tempo real. Assim, através da especificação
dessa ferramenta será possível proporcionar a mesma toda a segurança,
confiabilidade e coerência dos métodos formais, e com isso transformando essa
ferramenta em uma base para o desenvolvimento de sistemas de tempo real fidedigno.

Entretanto, a especificação de um sistema operacional de tempo real é uma tarefa
árdua e praticamente impossível de ser realizada em um único trabalho, pois os
formalismos existentes possuem muitas restrições o que impede a especificação de
sistemas complexos, principalmente, os que possuem alocação dinâmica de memória.
Assim, o esforço relatado nesse trabalho pretende apenas inicializar a resolução
dos desafios comentados acima, os quais teram sua completa solução formada pela
união de esforços de vários trabalhos.

Para essa inicialização, foi criada, utilizando-se o método B
\cite{schn:01}\cite{abrial:96}, uma modelagem abstrata do sistema, na qual,
algumas das suas principais propriedades são especificadas e comprovadas. O
método B servirá assim, como a abordagem utilizada para o rigoroso
desenvolvimento da ferramenta, pois ele inspirado em técnicas de especificação,
como VDM e Z, e na teoria de refinamento proporciona um rígido desenvolvimento de
sistemas, que se inicia na modelagem abstrata de um sistema vai até o nível de
algoritmo, podendo este último ser estendido para o nível de assemblagem do
microprocessador alvo \cite{semish:08}.

Assim para iniciar essa especificação, primeiramente foi desenvolvido um projeto
de modelagem com a finalidade de estudar o sistema e identificar os seus
principais comportamentos e características. Esse estudo foi feito através do
material de apoio do sistema junto com a verificação do seu código fonte, onde
foi averiguado o comportamento interno dos seus estados. Após esse estudo, foram
escolhidas estrategicamente algumas das principais funcionalidades e
características do sistema para serem especificadas nessa modelagem inicial,
sendo as demais abstraídas para serem tratados em futuros refinamento da
especificação.

Com isso, esse trabalho prossegue demonstrado como é realizada a modelagem aqui
proposta e como ela pretende iniciar a resolução do desafio de especificar
formalmente o sistema operacional de tempo real FreeRTOS contribuindo assim para
criação de uma ferramenta capaz de construir sistemas de tempo real mais
fidedignos.

Para cumprir o seu objetivo, esse artigo foi dividido da seguinte forma.
inicialmente tem-se com uma pequena introdução ao FreeRTOS onde são comentados
alguns conceitos relevantes para esse trabalho. Em seguida, na sessão
\ref{sec:metodob} o método B é rapidamente comentado. Após isso tem-se uma sessão
explicando como foi feito o projeto da modelagem aqui descrita. E por fim, na
sessão \ref{sec:modelagem} é relatada como foi feita essa modelagem inicial do
sistema e na sessão \ref{sec:conclusoes} tem-se as conclusões e possíveis
continuações desse trabalho.


\section{FreeRTOS} \label{sec:freertos}

O FreeRTOS é um sistema operacional de tempo real enxuto, simples e de
fácil uso. O seu código fonte, feito em \textit{C} com partes em
\textit{assembly}, é aberto e possui pouco mais de 2.200 linhas de
código, que são essencialmente distribuídas em quatro arquivos:
\texttt{task.c}, \texttt{queue.c}, \texttt{croutine.c} e
\texttt{list.c}. Uma outra característica marcante desse sistema está
na sua portabilidade, sendo o mesmo oficialmente disponível para 17
arquiteturas diferentes, entre elas a PIC, ARM e Zilog Z80, as quais
são amplamente difundidas em produtos comerciais através de sistemas
computacionais embutidos.

O FreeRTOS provê acesso a recursos de \textit{hardware}, permitindo o
desenvolvimento de sistemas concorrentes de tempo-real. Assim, o FreeRTOS
fornece uma camada de abstração, que tem como papel esconder dos
desenvolvedores de aplicações os detalhes do hardware que será
utilizado. Mais precisamente, o FreeRTOS fornece para os seus usuários
serviços de gerenciamento de tarefa, de comunicação e sincronização
entre tarefas, de memória, de tempo-real e de controle dos
dispositivos de entrada e saída. Vale salientar que o FreeRTOS assume
que a arquitetura alvo possui um único processador.

O FreeRTOS disponibiliza esses serviços sob a forma de uma biblioteca
de tipos e funções que deve ser linkeditada com o código da aplicação
a ser desenvolvida. Tipicamente esse código é divido em duas partes: a
primeira contem o código das tarefas que serão executadas durante a
operação do sistema, e a segunda o código responsável pela
inicialização do sistema, o qual deverá cadastrar as tarefas e então
dar início ao escalonador.

Em seguida, são detalhados os principais serviços disponibilizados
pelo FreeRTOS que serão relevantes para a continuidade do trabalho,
sendo que. Maiores informações sobre os demais podem ser encontradas
em \cite{freertos:2008}.

\subsection{Gerenciamento de Tarefa}
\label{subsec:gerenciamento_tarefa}

No FreeRTOS, tarefas são unidades básicas de computação que são
compostas para construir um sistema multitarefa. Assim, uma tarefa é
formada por: 
\begin{itemize}
\item um estado, que demonstra a atual situação da tarefa, podendo a
  mesma estar em execução, pronta, suspensa ou bloqueada.
\item uma prioridade que varia de zero até uma constante de prioridade
  máxima definida pelo o usuário e serve para indicar a importância da
  tarefa para o sistema; e
\item a pilha de execução, na qual também é armazeno o ambiente de
  execução da tarefa (estados dos registradores) quando está é
  interrompida.
\end{itemize}

O FreeRTOS, além de permitir a execução de aplicações multitarefa, dá suporte a
três tipos de configurações diferentes de gerenciamento de tarefas: preemptivo,
cooperativo ou híbrido.

Na configuração preemptiva, a tarefa em execução pode ser interrompida
a qualquer momento pelo escalonador e consequentemente substituída por
uma outra tarefa de acordo com a política de escalonamento, a qual é
baseada em prioridades. Na configuração cooperativa, a tarefa em
execução não é interrompida pelo escalonador, pois ela própria decide
o momento de sua pausa seguida da sua substituição, que será feita de
acordo com a política de escalonamento. E por fim, na configuração
híbrida, o escalonador funciona hora como preemptivo e hora como
cooperativo, sendo que um grupo de tarefas faz o escalonamento
cooperativo entre si e as demais realizam o gerenciamento preemptivo.

%% DD->SG: QUAL A RELACAO COM CO-ROTINAS?



A política de escalonamento do FreeRTOS, assim como a maioria dos sistemas
operacionais de tempo real, é baseada na prioridade. Isso indica que tarefas com
maiores prioridades têm sempre a preferência sobre as tarefas de menores
prioridades do mesmo estado.  Uma conseqüência direta dessa política é que a
tarefa em execução deve possuir prioridade maior ou igual a das tarefas
de estado pronto, pois a tarefa em execução nada mais é do que a tarefa que tem
a preferência de entrar em execução entre as tarefas de estado pronto.

Uma outra característica importante do escalonador é que ele distribui igualmento
o tempo de processamento entre tarefas de mesma propridade. Com isso, se houver
duas, ou mais, tarefas prontas e com a prioridade máxima, elas irão dividir o
tempo de processamento igualmente.

\subsection{Comunicação e sincronização entre tarefas}

A comunicação entre tarefas no FreeRTOS é feita através de filas de mensagens.
Tarefas podem enviar mensagens a uma fila ou ler mensagens de uma fila. No
FreeRTOS, as filas de mensagens possuem uma capacidade limitada e fixa,
determinada na criação da fila pelo o tamanho e quantidade das mensagens da fila.

Para as tarefas, o acesso às filas de mensagens é bloqueador: quando uma tarefa
envia uma mensagem para uma fila, e está não estiver cheia, a mensagem é inserida
na fila, caso contrário, a tarefa permanece bloqueada até que seja liberado um
lugar na fila. O mesmo ocorre quando uma tarefa deseja ler uma mensagem da fila.
Se a fila possuir pelo menos uma mensagem, a leitura é realizada (retornando para
a tarefa a mensagem mais antiga na fila). Entretanto, se a fila estiver vazia, a
tarefa será bloquada até que uma mensagem seja inserida na fila.

No FreeRTOS, os semáforos formam o principal serviço de sincronização para o
acesso a recursos compartilhados. Eles são implementados como uma fila de
mensagens com um único item. Por convenção, o semáforo está em uso, quando a fila
estiver vazia e livre quando esta estiver cheia. No caso de filas implementando
semáforos, o conteúdo das mensagens não é relevante, apenas o estado da fila.

Exite também, no FreeRTOS, uma segunda primitiva de sincronização, chamada mutex,
a qual disponibiliza o conceito de herança de prioridade. Assim um mutex nada
mais é que um semáforo com uma prioridade associada, sendo está igual à da tarefa
que usa o mutex no momento (ou zero, se não houver). Na solicitação a um mutex
ocupado, se a tarefa solicitante tiver prioridade maior que a prioridade
associada ao mutex, a tarefa proprietária do mutex tem momentaneamente a sua
prioridade elevada (herda) ao nível da tarefa solicitante. Essa tarefa,
momentaneamente promovida, tem assim acesso ao processodor facilitado, o que pode
garantir uma liberação mais rápida do mutex. Esse mecanismo permite evitar o
fenômeno de intertravamento de tarefas chamado de inversão de
prioridade\cite{li:03}.

\section{O método B} \label{sec:metodob}

O método B é uma abordagem orientada a modelos para o projeto de
componentes de \textit{softwares}. Através dele é possível desenvolver
implementações que comprovadamente realizam as funcionalidades
descritas em sua especificação. Esse desenvolvimento é realizado da
seguinte forma: uma especificação do sistema é desenvolvida. Essa
especificação leva o nome de \emph{máquina} em B. Uma análise estática
da especificação permite determinar que ela é implementável e que
nenhuma execução leva a um estado inválido.  Uma vez realizada a
especificação, deve-se efetuar etapas de \emph{refinamento}. Em um
refinamento, cria-se um novo módulo que deve ser compatível com o
módulo imediatamente anterior mas que introduz detalhes de
implementação adicionais. Essa compatibilidade também é determinada
usando análise estática. Finalmente as diferentes etapas de
refinamento devem levar a um módulo expresso em uma linguagem
algorítmica que pode ser traduzida automaticamente em alguma linguagem
de programação imperativa. No caso do método B, existe tradutores para
as linguagens C, Ada, Java, JavaCard e C\#.

Os fundamentos teóricos do método B são relativamente simples: lógica
da primeira ordem, aritmética inteira, teoria dos conjuntos, cálculo
de substituições e teoria do refinamento.

Os módulos utilizados no desenvolvimento com B são construidos utilizando-se uma
linguagem denominada \emph{notação de máquina abstrata}. Nela cada módulo é
composto de diferentes seções, sendo cada seção responsável por definir um
aspecto da especificação do sistema como: parâmetros, tipos, constantes,
variáveis de estado, estados iniciais e transições do sistema. Como exemplo, a
figura~\ref{fig:tarefas_maquina} contém um módulo, chamado \textit{Kernel}, o
qual especifica um sistema que permite incluir e excluir tarefas até o limite de
10 tarefas. As seções desse módulo são:
\begin{description}
\item[MACHINE] identifica a natureza e o nome do módulo.
\item[SETS] introduz um novo tipo de entidade, aqui
  $\mathit{TASK}$. Nesse momento, nenhum detalhe é fornecido quanto à
  maneira como essa entidade será implementada.
\item[VARIABLES] informa o nome das diferentes variáveis de estado. No
  exemplo, apenas há uma variável de estado: $\mathit{tasks}$.
\item[INVARIANT] especifica o tipo das variáveis de estado assim
  também como os estados válidos do sistema. Aqui, $\mathit{tasks}$ é
  um conjunto de até 10 elementos do tipo $\mathit{TASK}$. A
  caracterização lógica do conjunto dos estados válidos é uma das
  atividades mais importantes da especificação.
\item[INITIALISATION] identifica quais são os possíveis estados
  iniciais do sistema. No caso, $\mathit{tasks}$ é o conjunto vazio.
\item[OPERATIONS] determina os diferentes tipo de eventos que o
  sistema pode sofrer. No nosso exemplo, temos operações para
  adicionar e eliminar um elemento de $\mathit{tasks}$. Uma operação
  pode ter parâmetros, resultados e pode alterar o valor de variáveis
  de estado.
\end{description}

\begin{figure}[!ht]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\MACHINE\\
\quad \mathit{Kernel}\\
    
\SETS\\
\quad \mathit{TASK}\\
    
\VARIABLES\\
\quad \mathit{tasks}\\
    
\INVARIANT\\
\quad \mathit{tasks} \in \pow(\mathit{TASK}) \land \\
\quad \card(\mathit{tasks})\leq 10\\
    
\INITIALISATION\\
\quad \mathit{tasks}:=\emptyset\\
    
\end{array}
\begin{array}[t]{l}
\OPERATIONS\\\\
\mathit{task\_add}(\mathit{task}) = \\
\quad \PRE \\
\quad\quad \mathit{task}\in \mathit{TASK} \land \\
\quad\quad \mathit{task}\not\in \mathit{tasks} \land\\
\quad\quad \card(\mathit{tasks})<10\\
\quad \THEN\\
\quad\quad \mathit{tasks}:=\mathit{tasks}\cup \{\mathit{task}\}\\
\quad   \END;\\

\end{array}

\begin{array}[t]{l}
\ldots\\
\mathit{task\_delete}(\mathit{task})=\\
\quad \PRE\\
\quad \quad \mathit{task}\in \mathit{tasks}\\
\quad \THEN\\
\quad \quad \mathit{tasks}:=\mathit{tasks}-\{\mathit{task}\}\\
\quad \END\\
	
\END\\
\end{array}
\end{array}
$$
\end{small}
\caption{Maquina abstrata de tarefas}
\label{fig:tarefas_maquina}
\end{figure}

A análise estática dessa máquina demanda que seja verificado que ela é
implementável (ou seja que existe alguma solução para ela) e que todos
os estados alcançáveis sejam estados válidos. Essa análise estática
é feita através da verificação de condições lógicas. No método B, essas
condições são expressas como fórmulas em lógica da primeira ordem e o
usuário necessita provar que essas fórmulas são válidas. Para o exemplo
exposto na figura~\ref{fig:tarefas_maquina}, uma das condições a
verificar é que a operação $\mathit{task\_add}$ deve preservar o
invariante (ou seja, se a operação é efetuada em um estado válido, e
que a pré-condição da operação seja satisfeita, então ela deve levar a
um estado válido). A formulação lógica dessa propriedade é:
\begin{small}
$$
\begin{array}[t]{ccc}
\mathit{tasks} \in \pow(\mathit{TASK}) \land 
\card(\mathit{tasks})\leq 10 \land \\
\quad \mathit{task}\in \mathit{tasks} \Rightarrow \\
(\mathbf{\mathit{tasks}\cup \{\mathit{task}\}}) \in \pow(\mathit{TASK}) \land 
\card(\mathbf{\mathit{tasks}\cup \{\mathit{task}\}})\leq 10
\end{array}
$$
\end{small}

Para dar suporte a essa análise estática, foram desenvolvidos
provadores automáticos de teoremas e assistentes de
prova. Tipicamente, o desenvolvedor aplica o provador automático de
teoremas às condições de verificação e consegue eliminar uma parte
significativa delas. As condições de verificação restantes devem então
ser provadas interativamente pelo desenvolvedor usando o assistente de
prova. Normalmente, para os sistemas mais complexos, percebe-se então
que algumas condições de verificação não são válidas, o que indica que
a especificação tem incoerências e que precisa ser corrigida. Após
algumas iterações, deve-se convergir para uma especificação coerente
do sistema a ser desenvolvido. Essa especificação fornece o ponto
inicial do desenvolvimento baseado em refinamentos. Caso o
desenvolvedor optar por um desenvolvimento diretamente em alguma
linguagem de programação, o modelo inicial também pode ser usado para
gerar testes da implementação.

Entretanto, modelos abstratos nem sempre possuem detalhes suficientes
para serem transformados em código fonte executáveis. No método B, os
refinamentos permitem ou complementar uma especificação, ou
especificar como implementar determinadas construções não diretamente
implementáveis (conjuntos, não determinismo, etc.). 

Um exemplo de refinamento é apresentado na figura
\ref{fig:tarefas_maquina_r}. Nela, a variável de tarefas
$\mathit{tasks}$ representada por $\mathit{tasksR}$, não é mais
tratada como um conjunto de tarefa, e sim como uma sequência de
tarefas, estrutura mais fácil de ser implementada do que um
conjunto. No método B, também há obrigações de prova associadas aos
refinamentos.  Estabelecer a validade das condições associadas a um
refinamento permite garantir que o refinamento não introduz nenhum
comportamento incompatível com o especificado no módulo refinado.

\begin{figure}[!ht]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathbf{REFINEMENT}\\
\quad \mathit{Kernel\_r}\\
   
\REFINES\\
\quad \mathit{Kernel}\\
   
\VARIABLES\\
\quad \mathit{tasks\_r}\\
\end{array}

    

\begin{array}[t]{l}
\INVARIANT\\
\quad \mathit{tasks\_r} \in \mathbf{seq}(\mathit{TASK}) \land \\
\quad \mathbf{ran}(\mathit{tasks\_r})=\mathit{tasks}\\
    
\INITIALISATION\\
\quad \mathit{tasks\_r}:=[]\\
\end{array}


\begin{array}[t]{l}
\OPERATIONS\\
\mathit{task\_add}(\mathit{task}) = \\
\quad \BEGIN\\
\quad \quad \mathit{tasks\_r}:=\\
\quad\quad\quad\quad\mathit{task} \to \mathit{tasks\_r}\\
\quad \END\\
    
\END
\end{array}

\end{array}
$$
\end{small}
\caption{Refinamento da maquina abstrata de tarefas}
\label{fig:tarefas_maquina_r}
\end{figure}

É seguindo esse raciocínio que o método B permite construir sistemas
de uma forma mais segura e coerente. Ele será o formalismo utilizado
para desenvolver uma especificação formal do FreeRTOS. O modelo assim
obtido poderá ser usado das seguintes formas:
\begin{itemize}
\item ser o ponto inicial para o desenvolvimento rigoroso de uma
  implementação das funcionalidades do FreeRTOS.
\item ser o suporte para a geração de testes para verificar
  implementações existentes do FreeRTOS.
\item ser usado como componente no desenvolvimento formal de
  aplicações de tempo-real usando o FreeRTOS.
\end{itemize}

\section{Projeto da modelagem}\label{sec:projeto}

A modelagem de um sistema complexo com o método B pode ser facilitada
se usamos táticas como: 
\begin{enumerate}
\item Partes dos requisitos podem ser abstraídos da especificação
  inicial. Os requisitos assim abstraídos podem ser especificados
  ulteriormente através de refinamentos. Para implantar essa tática,
  devemos identificar uma seqüência de etapas de modelagem, tendo em
  cada etapa modelado um número cada vez maior de entidades e
  funcionalidades do FreeRTOS. Essas diferentes etapas estão descritas
  no resto dessa seção.
\item Se não há uma interdependência entre requisitos, eles podem ser
  especificados em módulos distintos. Esses módulos são então
  relacionados usando mecanismos de composição do método B (como
  inclusão, visão, etc.) A estrutura modular da modelagem é
  apresentada na seção~\ref{sec:modelagem}.
\end{enumerate}

Em geral, especificações formais são realizadas nas etapas
preliminares de um projeto. No caso reportado neste artigo, o sistema
já existe, as funcionalidades já foram elencadas e implementadas. O
modelo a ser produzido portanto é uma engenharia reversa de um sistema
existente. Para efetuar essa engenharia reversa, duas fontes de
informação estavam disponíveis: a documentação do FreeRTOS, em
linguagem natural, e o próprio código fonte, já que o sistema é
distribuído de forma aberta.

A modelagem formal do FreeRTOS foi então precedida de uma etapa de
estudo visando ganhar familiaridade com o sistema. Nessa etapa,
observou-se que a estruturação dos tipos e funções da biblioteca
permitiria um desenvolvimento incremental dessa modelagem.

As principais entidades do FreeRTOS são: tarefa, fila de mensagens,
co-rotina, semáforo e mutex. Cada uma dessas entidades possui uma gama
de funções associadas. No entanto, através do estudo da documentação e
do código fonte do FreeRTOS, observamos que semáforo e mutex nada mais
são que casos particulares de filas de mensagens e que tarefa é a
entidade fundamental do sistema



Assim, para elaborar um primeiro modelo formal do FreeRTOS, foram
elencadas duas entidades apenas: tarefas e filas de mensagens. Vale
salientar que a composição dessas duas entidades já resulta em um
núcleo completo do sistema operacional. De fato, a entidade ``tarefa''
é essencial, pois ela é responsável pela execução do código da
aplicação. Em complemento, a entidade ``fila de mensagens'' permite
não só a comunicação entre tarefas, mas também a sua sincronização no
acesso a recursos compartilhados.

\subsection{Tarefa}

Dois tipos de funções manipulam a entidade tarefas: gerenciamento de
tarefa e controle do escalonador. A seguir tem-se a listagem e
descrição de cada uma das funcionalidades desses grupos escolhidas
para fazerem parte da modelagem inicial.


\subsubsection*{Gerenciamento de tarefa}
\begin{description}  
\item{\textbf{xTaskCreate:}} cria uma nova tarefa;
\item{\textbf{xTaskDelete:}} remove uma tarefa do FreeRTOS;
\item{\textbf{uxTaskPriorityGet:}} informa a prioridade de uma tarefa;
\item{\textbf{vTaskSuspend:}} coloca uma tarefa no estado ``suspenso'';
\item{\textbf{vTaskResume:}} retorna uma tarefa suspensa colocando-a no estado
  pronto;
\item{\textbf{vTaskPrioritySet:}} altera a prioridade de uma tarefa;
\item{\textbf{vTaskDelay:}} bloqueia uma tarefa por uma determinada
  quantidade de tempo, levando em consideração o instante em que o método foi
  chamada;
\item{\textbf{vTaskDelayUntil:}} bloqueia uma tarefa por uma determinada
  quantidade de tempo, levando em consideração o instante em que essa
  foi desbloqueada.
\end{description}

\subsubsection*{Controle do escalonador}
\begin{description}
\item{\textbf{xTaskGetCurrentTaskHandle:}} retorna uma referência para a
  tarefa em execução;
\item{\textbf{xTaskGetSchedulerState:}} informa o atual estado do escalonador
  (executando, suspenso ou não inicializado);
\item{\textbf{uxTaskGetNumberOfTasks:}} informa a atual quantidade de tarefas
  tarefas do FreeRTOS;
\item{\textbf{xTaskGetTickCount:}} informa o tempo decorrido apartir da
  inicialização do escalonador;
\item{\textbf{vTaskStartScheduler:}} esse método primeiramente cria a tarefa
  ociosa e, em seguida, inicia as atividades do escalonador;
\item{\textbf{vTaskEndScheduler:}} finaliza as atividades do escalonador
  colocando-o no estado não inicializado; para isso, ele primeiramente
  exclui todas as estruturas (tarefas, filas de mensagens, co-rotinas,
  etc) criadas no FreeRTOS e em seguida finaliza o escalonador;
\item{\textbf{vTaskSuspendAll:}} suspende temporariamente as atividades do
  escalonador colocando-o no estado suspenso;
\item{\textbf{xTaskResumeAll:}} retorna todas as atividades do escalonador
  quando este encontra-se no estado suspenso.
\end{description}

\subsection{Fila de mensagens}

Para a manipulação da entidade de fila de mensagens, o FreeRTOS
disponibiliza as seguintes funções:

\begin{description}
  \item{\textbf{xQueueCreate:}} cria uma nova fila de mensagem;
  \item{\textbf{xQueueSend:}} enviar uma mensagem para uma fila de mensagens;
  \item{\textbf{xQueueSendToBack:}} envia uma mensagem para o final de uma
  fila de uma fila de mensagens.;
  \item{\textbf{xQueueSendToFront:}} envia uma mensagem para o início de uma
  fila de mensagem;
  \item{\textbf{xQueueReceive:}} ler e retirar a mensagem localizada no início
  da fila de mensagens;
  \item{\textbf{xQueuePeek:}} ler sem retirar a mensagem localizada no início da
  fila de mensagens;
  \item{\textbf{vQueueDelete}} Exclui uma fila de mensagens do FreeRTOS.
\end{description}

\subsection{Níveis de abstração e Próximas funcionalidades}

Uma vez determinadas as funcionalidades básicas do sistema, foram
definidos os vários níveis de abstração em que essas podem ser
especificadas. Assim para uma modelagem progressiva e gerenciável do
FreeRTOS, os níveis de abstração foram organizados da seguinte
maneira:

\begin{enumerate}

\item \textbf{Estado de tarefa:} Nesse nível é levado em consideração
  principalmente o comportamento das funcionalidades em relação ao
  estado de uma tarefa. Nele também são especificados os estados do
  escalonador assim como o conceito de tempo que, no FreeRTOS, é 
  tratado como ``tick''.

\item \textbf{Prioridade:} Nesse segundo nível, a característica de
  prioridade é adicionada ao sistema, procurando-se notadamente em
  estabelecer a propriedade de que a tarefa em execução possui
  prioridade maior ou igual as tarefas de estado pronto.

\item \textbf{Capacidade da fila de mensagens:} Nessa abstração será
  acrescentada ao modelo o tamanho de uma fila de mensagem, podendo
  assim quando um tarefa pode ser ou não bloqueada por uma fila.

\item \textbf{Adição dos conceitos não elementares:} Semáforos e mutex
  são especializações de filas de mensagens e a modelagem das
  funcionalidades associadas será efetuada em última instância,
  devendo ela ser realizada com base a modelagem de conceitos já
  disponíveis nessa fase.

\end{enumerate}

Uma vez modeladas as diferentes entidades e funcionalidades do
FreeRTOS, passará-se à fase de construção da implementação, a qual
consistirá principalmente em mapear as variáveis de estados para
estruturas de dados concretas como vetores, listas encadeadas, etc.

\section{Modelagem}
\label{sec:modelagem}

Essa seção apresenta as duas primeiras etapas do projeto de modelagem
do FreeRTOS usando o método B: estado de tarefa e prioridade. O primeiro
nível de modelagem portanto especifica as funcionalidades elementares
relacionadas com tarefas e filas de mensagens, sem levar em conta o
aspecto da prioridade.

% No caso da modelagem do FreeRTOS, usamos ambas táticas para construir a
% especificação. Assim, essa especificação inicial foi divida em vários módulos que
% serão explicados no decorrer da modelagem, ficando a arquitetra básica dessas
% modelagem inicial organizada como mostra a figura~\ref{fig:arquitetura_modulos}.
% Os módulos \textbf{Task\_Core} e \textbf{Queue\_Core} definem as entidades tarefa
% e fila de mensagens e operações básicas sobre essas entidades. São utilizados por
% módulos mais complexos \textbf{Task\_Basic} e \textbf{Queue\_Basic}. No primeiro
% são especificadas as função do FreeRTOS referentes a entidade tarefa. E no
% segundo as operações de \textbf{Queue\_Core} são agrupadas em operações mais
% complexa que estão presentes no comportamento da maioria das funções do grupo
% de fila de mensagens, sendo assim esse módulo utilizado pela máquina
% \textbf{Queue} para especificar tais funções. 

A modelagem inicial foi realizada de forma modular, sendo composta de diversas
máquinas que serão detalhadas no decorrer dessa seção, ficando a arquitetura
básica organizada conforme mostra a figura~\ref{fig:arquitetura_modulos}:
\begin{itemize}
\item A máquina $\mathit{Task\_Core}$ define a entidade tarefa e operações
básicas sobre essa entidade.
\item Similarmente, a máquina $\mathit{Queue\_Core}$ define a entidade fila de
mensagens e operações básicas associadas.
\item $\mathit{Task\_Basic}$ Nessa máquina são especificadas as funcões da API
do FreeRTOS escolhidas na sessão \ref{sec:projeto} que manipulam o conceito de
tarefa, ou seja, as funções dos grupo controle de tarefa e gerenciamento do
escalonador
\item $\mathit{Queue\_Basic}$ Essa máquina foi adicionada devido a observação
que nas funções da API do FreeRTOS que manipulam a entidade fila de mensagens
varias comportamentos se repentem. Assim para agrupar esses comportamentos essa
máquina intermidiária foi criada. Nela as operações básicas da máquina
$\mathit{Queue\_Core}$ foram agrupadas em operações mais complexas.

\item $\mathit{Queue}$. Nessa máquina é onde, através da utilização das
operações da máquina $\mathit{Queue\_Basic}$, são especificadas as funções da
API do FreeRTOS que manipulam o conceito de fila de mensagens.

\end{itemize}

\begin{figure}[!h]
\centering
\includegraphics[scale=0.6]{figuras/arquitetura.jpg}
\caption{Organização dos módulos da especificação}
\label{fig:arquitetura_modulos}
\end{figure}

\subsection{Tarefas}

As definições de base relacionadas com tarefas foram realizadas na
máquina $\mathit{Task\_Core}$ (veja os trechos mais relevantes na
figura~\ref{fig:tarefa_especificacao}). Nela, $\mathit{TASK}$
representa o tipo da entidade ``tarefa'' do FreeRTOS.  A variável de
estado $\mathit{tasks}$ representa o conjunto de tarefas que estão
sendo gerenciadas pelo sistema. Além disso, são identificados os
conjuntos de tarefa $\mathit{running}$, $\mathit{ready}$,
$\mathit{blocked}$ e $\mathit{suspended}$, os quais representam as
tarefas que estão respectivamente no estado executando, pronto,
bloqueado e suspenso.

\begin{figure}[!ht]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathbf{SETS}\\
\quad   \mathit{TASK};\\
\quad   \ldots \\\\
    		
\mathbf{VARIABLES}\\
\quad   \mathit{tasks},\\
\quad   \mathit{blocked},\\
\quad	\mathit{running},\\
\quad	\mathit{ready}, \\
\quad	\mathit{suspended}\\
\quad	\ldots
\end{array}
\begin{array}[t]{l}

\mathbf{INVARIANTS}\\

\quad \mathit{tasks} \in \mathbf{FIN}(\mathit{TASK}) \land \\
\quad \mathit{tasks} \neq \emptyset \land \\

\quad \mathit{blocked}	\in \mathbf{FIN}(\mathit{TASK}) \land \\
\quad \mathit{blocked} \subset \mathit{tasks} \land \\

\quad \mathit{ready} \in \mathbf{FIN}(\mathit{TASK}) \land \\
\quad \mathit{ready} \subset \mathit{tasks} \land \\	

\quad \mathit{suspended} \in \mathbf{FIN}(\mathit{TASK}) \land \\
\quad \mathit{suspended} \subset \mathit{tasks} \land \\
\quad \ldots
\end{array}

\begin{array}[t]{l}
\quad \mathit{running} \in \mathit{TASK} \land \\
\quad \mathit{running} \in \mathit{tasks} \land \\
\quad \mathit{running}  \not\in \mathit{ready} \land \\
\quad \mathit{running} \not\in  \mathit{blocked} \land \\
\quad \mathit{running} \not\in  \mathit{suspended} \land \\

\quad \mathit{ready} \cap \mathit{blocked} = \emptyset \land \\ 
\quad \mathit{blocked} \cap \mathit{suspended} = \emptyset \land \\
\quad \mathit{suspended} \cap \mathit{ready} = \emptyset \land \\

\quad \mathit{tasks} = \mathit{\{running\}} \cup \mathit{suspended} \\ 
\quad\quad\quad\quad\quad \cup \mathit{blocked} \cup \mathit{ready}

\end{array}
\end{array}
$$
\end{small}
\caption{Modelagem do conceito tarefa}
\label{fig:tarefa_especificacao}
\end{figure}

Uma tarefa deve estar em um único estado, o que é expresso no
invariante da máquina, usando uma formulação simples na teoria dos
conjuntos.

Essas definições caracterizam, de forma abstrata, a parte do estado
relacionada com as tarefas de qualquer instância do FreeRTOS. Além
disso, a máquina $\mathit{Task\_Core}$ define operações básicas
responsáveis por alterar as características de uma tarefa, acrescentar
ou eliminar uma tarefa, etc. Essas operações serão usadas para
especificar as funcionaliades do FreeRTOS relacionadas com o conceito
de tarefas. Ao todo, foram criadas 12 operações, das quais iremos
observar apenas a operação $\mathit{t\_create}$, responsável pela
criação de uma nova tarefa\footnote{O leitor interessado nas demais
  operações está convidado a visitar o repositório no endereço
  \texttt{http://code.google.com/p/freertosb}.}

A operação $\mathit{t\_create}$ é apresentada na
figura~\ref{fig:t_create}.  A operação tem como parâmetro a prioridade
da tarefa criada (embora não esteja necessário nesse nível de
abstração, esse parâmetro é presente por compatibilidade com futuros
refinamentos). A pré-condição expressa que essa operação só pode ser
aplicada quando não houver tarefa em execução. A criação é
especificada através da substituição não determinística
$\mathit{ANY}$, onde é definido que a nova tarefa, nomeada
$\mathit{task}$, é qualquer valor do tipo $\mathit{TASK}$ que não
esteja elemento do conjunto $\mathit{tasks}$. Assim garantimos que
$\mathit{task}$ não representa uma tarefa já existente no sistema.
Esse valor é resultado da operação e as variáveis de estado
$\mathit{tasks}$ e $\mathit{ready}$ são alteradas para também incluir
esse valor: no FreeRTOS, quando uma tarefa é criada, esta é
considerada pronta para ser escalonada.

\begin{figure}[!h]
\begin{small}

$$
\begin{array}[t]{cc}
\begin{array}[t]{l}
\mathit{result} \longleftarrow \mathit{t\_create}
										(\mathit{priority}) = \\
\PRE \\
\quad \mathit{priority} \in \mathit{PRIORITY} \land \\ 
\quad \mathit{running}=\mathit{TASK\_NULL}\\
\THEN \\
\quad \ANY\\
\quad\quad \mathit{task}\\
\quad \WHERE\\
\quad\quad \mathit{task} \in \mathit{TASK} \land \\
\quad\quad \mathit{task} \not\in \mathit{tasks} \\ 
\quad\ldots
\end{array}

\begin{array}[t]{l}
\quad \ldots\\
\quad \THEN \\    	    
\quad\quad \mathit{tasks} := \{ task \} \cup \mathit{tasks} \parallel\\
\quad\quad \mathit{ready} := \{ task \} \cup \mathit{ready} \parallel \\
\quad\quad \mathit{result} := \mathit{task}\\
\quad \END\\      
\END;\\
\end{array}
\end{array}
$$

\end{small}
\caption{Especificação da operação \textit{t\_create}}
\label{fig:t_create}
\end{figure} 

Uma vez especificados o conceito de tarefa no FreeRTOS assim como
operações elementares para acessar e alterar o atual conjunto de
tarefas, pode se realizar a especificação das funcionalidades que são
disponibilizados para os usuários do FreeRTOS. A especificação dessas
funcionalidades é feita através da máquina $\mathit{Task\_Core}$, na
qual estão presentes as funções de controle de tarefa, mas também do
escalonador \ref{subsubsec:tarefa_funcionalidades}. Essa seção
limita-se a apresentar a especificação da função
$\mathit{xTaskCreate}$, a qual utiliza-se da operação básica
$\mathit{t\_create}$ para criar uma nova tarefa que sera gerenciada
pelo FreeRTOS. A especificação de $\mathit{xTaskCreate}$ é apresentada
na figura \ref{fig:xTaskCreate}, onde são identificados dois
comportamentos possíveis para a função: ou a tarefa é criada através
da chamada ao método $\mathit{t\_create}$ e uma referência para a nova
tarefa é retornada, junto com a mensagem de sucesso; ou, a tarefa não
é criada e uma referência nula, junto com a mensagem de erro, é
retornada.

Os parâmetros da operação correspondem aos parâmetros da função do
FreeRTOS modelada, embora não estejam usados neste nível de abstração.
Essa inclusão é necessária para garantir compatibilidade com os
refinamentos futuros.

Um outro detalhe operacional é que, na implementação do FreeRTOS,
quando a função \texttt{xTaskCreate} é aplicada, o gancho para a
tarefa criada é obtido pelo usuário através de um parâmetro de tipo
ponteiro (técnica clássica para simular uma passagem de parâmetro por
referência). Na notação de máquina abstrata, não há ponteiros, nem
parâmetros por referência, mas as operações podem retornar múltiplos
resultados. A modelagem apresentada utiliza então esse recurso para
especificar parâmetros ponteiros de funções FreeRTOS que são usados
para retornar valores.

\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{cc}
\begin{array}[t]{l}
\mathit{result}, \mathit{handle} \longleftarrow \\ 
\quad\quad\quad \mathit{xTaskCreate} (\mathit{pvTaskCode},\mathit{pcName},\\
\quad\quad\quad
			\mathit{usStackDepth},\mathit{pvParameters}, \mathit{uxPriority}) = \\
\PRE\\ 
\quad \mathit{pvTaskCode} \in \mathit{TASK\_CODE} \land \\ 
\quad \mathit{pcName} \in \mathit{NAME} \land \\ 
\quad \mathit{usStackDepth} \in \mathit{NATURAL} \land \\  
\quad \mathit{pvParameters} \subset \mathit{PARAMETER} \land \\ 
\quad \mathit{uxPriority} \in \mathit{PRIORITY} \land \\
\THEN \\
\ldots\\
\end{array}


\begin{array}[t]{l}
\quad\ldots\\
\quad \CHOICE\\ 
\quad \quad \mathit{handle} \leftarrow \\
\quad \quad\quad \quad\mathbf{t\_create} (\mathit{uxPriority}) \parallel\\ 
\quad \quad \mathit{result} := \mathit{pdPASS}\\
\quad	\OR \\
\quad \quad
\mathit{result}:=\mathit{errMEMORY} \parallel \\ 
\quad \quad 
\mathit{handle} := \mathit{TASK\_NULL} \\
\quad \END\\
\END;
\end{array}

\end{array}
$$

\end{small}
\caption{Modelagem da funcionalidade $\mathit{xTaskCreate}$}
\label{fig:xTaskCreate}
\end{figure}

\subsection{Fila de mensagens}

Como no caso das tarefas, a especificação dos elementos do FreeRTOS
relacionados com filas de mensagens é estruturada em diversos módulos.
Na base, existe um módulo, identificado como $\mathit{QUEUE\_CORE}$, e
apresentado na figura~\ref{fig:fila_especificacao}, que agrupa a
especificação das entidades de base, dos componentes de estado do
FreeRTOS relacionados com essas entidades, e das operações elementares
para acessar e manipular esses componentes.

Nela, são declarados os tipos $\mathit{QUEUE}$ e $\mathit{ITEM}$, que
representam respectivamente filas de mensagens e suas mensagens.  A
variável de estado $\mathit{queues}$ representa o conjunto das filas
de mensagens que estão sendo gerenciadas pelo FreeRTOS. As demais
variáveis de estado representam relacionamentos entre os diferentes
tipos de entidades:
\begin{itemize}
\item $\mathit{queue\_items}$ modela o conteúdo das filas de
  mensagens. 
\item $\mathit{queue\_sending}$ e $\mathit{queue\_receiving}$ associam
  respectivamente a cada fila o conjunto de tarefas que esperam para
  enviar uma mensagem nessa fila e o conjunto de tarefas que aguardam
  para ler uma mensagem dessa fila.
\end{itemize}

\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathbf{SETS} \\
\quad   \mathit{QUEUE};\\
\quad   \mathit{ITEM};\\
\quad   \ldots \\
    		
\mathbf{VARIABLES}\\
\quad   \mathit{queues},\\
\quad\quad   \mathit{queue\_items},\\
\quad\quad   \mathit{queue\_receiving},\\
\quad\quad	 \mathit{queue\_sending}
\end{array}

\begin{array}[t]{l}

\mathbf{INVARIANTS}\\

\quad \mathit{queues} \in \mathbf{POW}(\mathit{QUEUE}) \land \\
\quad\quad \mathit{queue\_items} \in \mathit{QUEUE} \rightarrow\mkern-22mu+
\mathbf{POW}(\mathit{ITEM})\land \\

\quad\quad \mathit{queue\_receiving} \in \mathit{QUEUE} \rightarrow\mkern-22mu+
\mathbf{POW}(\mathit{TASK}) \land \\ 

\quad\quad \mathit{queue\_sending} \in \mathit{QUEUE}\rightarrow\mkern-22mu+
\mathbf{POW}(\mathit{TASK}) \land \\\\
    		
\quad \mathit{queues} = \mathbf{dom}(\mathit{queue\_items}) \land \\
\quad \mathit{queues} = \mathbf{dom}(\mathit{queue\_receiving}) \land \\
\quad \mathit{queues} = \mathbf{dom}(\mathit{queue\_sending})

\end{array}

\end{array}
$$
\end{small}
\caption{Modelagem do conceito fila de mensagem}
\label{fig:fila_especificacao}
\end{figure}

Assim como ocorreu na modelagem do conceito de tarefa, após
especificar-se o conceito de fila de mensagens foram criadas também,
na máquina $\mathit{Queue\_Core}$, algumas operações básica
responsáveis por manipular as características do conceito. 

Com isso foram implementadas o total de seis operações, nas quais são feitas as
inclusões e exclusões de mensagens e tarefas nos conjuntos que formam a entidade
fila de mensagens. Com exemplo tem-se a operação $\mathit{sendItem}$, na
figura~\ref{fig:sendItem} que é responsável por incluir uma mensagens, aqui
referenciada como $\mathit{pxItem}$, no conjunto de mensagens da fila $\mathit{pxQueue}$. E em seguida, na mesma fila,
a tarefa $\mathit{task}$ é retirada do conjunto de tarefas que aguardam pela
chegada de uma mensagem, $\mathit{queue_receiving}$, criando assim, uma operação
básica para especificar chega de uma mesagem na fila de mensagem.

\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathit{sendItem}( \mathit{pxQueue}, \mathit{pxItem}
					\mathit{task},\mathit{copy\_position}) = \\
\mathbf{PRE}\\
\quad  \mathit{pxQueue} \in \mathit{queues} \land \\ 
\quad  \mathit{pxItem} \in \mathit{ITEM} \land \\ 
\quad  \mathit{task}\in \mathit{TASK} \land \\ 
\quad  \mathit{copy\_position} \in \mathit{COPY\_POSITION} \land\\    
\quad  \mathit{task} \in \mathit{queue\_receiving}(\mathit{pxQueue})\\
\mathbf{THEN}\\
\quad  \mathit{queue\_items}(\mathit{pxQueue}):=
				\mathit{queue\_items}(\mathit{pxQueue}) \cup \{\mathit{pxItem}\}\parallel\\
\quad  \mathit{queue\_receiving}(\mathit{pxQueue}) :=
				\mathit{queue\_receiving}(\mathit{pxQueue}) - \{\mathit{task}\} \\
\mathbf{END};
\end{array}
\end{array}
$$
\end{small}
\caption{Modelagem da operação $\mathit{sendItem}$}
\label{fig:sendItem}
\end{figure}

%% SG->DD:Vou colocar aqui duas versões dessa parte para o Sr. descidir a melhor
% sendo que ná primeira versão eu do prioridade para a máquina Queue_Basic no
% lugar de Queue e na segunda e oficial a máquina Queue é preferida.

Uma particularidade presentes na funções que manipulam as entidades de fila de
mensagens é que na maioria deles podemos a repetição de dois comportamentos: um
para enviar uma mensagem para uma fila e o segundo para ler uma mensagem de uma
fila. Assim esses comportamentos foram agrupados em operações intermediárias
através da máquina $\mathbf{Queue_Core}$, resultando em duas operações principais
$\mathit{xQueueGenericSend}$ e $\mathit{xQueueGenericReceive}$. Na figura
\ref{fig:xQueueGenericSend} temos trechos da especificação da operação
$\mathit{xQueueGenericSend}$ onde ou uma mensagem $\mathit{pvItemToQueue}$ é 
passada para a fila de mensagens, causando o desbloqueio da tarefa
$\mathit{task}$, ou a tarefa que utilizou-se da operação, tarefa corrente, é
bloqueada, representando o comportamento de fila cheia, ou nenhuma mensagem é
enviada e a tarefa não é bloqueda, retornado uma mensagem de erro.

\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}   	
\ldots\\
\quad \mathbf{ANY}\\
\quad \quad \mathit{task}\\
\quad \mathbf{WHERE}\\
\quad \quad \mathit{task} \in \mathit{TASK} \land \\ 
\quad \quad \mathit{task}\in \mathit{blocked} \land \\
\quad  \quad \mathit{task}\in \mathit{queue_receiving}(\mathit{pxQueue})\\ 
\quad \mathbf{THEN}\\
\quad \quad \mathit{sendItem}(\mathit{pxQueue}
			,\mathit{pvItemToQueue},\mathit{task,copy_position})\parallel\\
\quad \quad \mathit{Unblock}(task)\parallel\\ 
\quad \quad \mathit{return}:=\mathit{pdPASS}\\
\quad \mathbf{END}\\        	
\ldots\\
\quad
\mathit{insertTaskWaitingToSend}(\mathit{pxQueue},\mathit{running})\parallel \\
\quad \mathit{DelayTask}(\mathit{xTicksToWait})\parallel\\
\quad \mathit{return}:=\mathit{pdTRUE}\\
\ldots\\
\quad \mathit{return}:=\mathit{errQUEUE\_FULL}\\
\ldots
\end{array}
\end{array}
$$
\end{small}
\caption{Comportamentos da operação $\mathit{xQueueGenericReceive}$}
\label{fig:xQueueGenericSend}
\end{figure}

Com isso, para especificar as funções que manipulam a entidade fila de
mensagens, a máquina $\mathbf{Queue}$ necessita apenas realizar chamadas às
operações da máquina $\mathbf{Queue_Basic}$, pois os comportamentos dessas
funcionalidades foram agrupados em $\mathbf{Queue_Basic}$ para facilitar a
especificação

%E para finalizar essa especificação abstrata, após a criação das operações
%básicas, as funções da API que utilizam o conceito de fila de mensagens foram
%especificadas pela máquina $\mathbf{Queue}$. Sendo que nessa especificação são
%utilizadas a operações espeficicadas pela máquina $\mathbf{Queue_Basic}$, na
%qual estão presentes as operações responsáveis por enviar um mensagem para a
%fila e ler uma mensagem da fila. Como exemplo de uma função especificada pela
%máquina $\mathbf{Queue}$ tem-se a $\mathit{xQueueSend}$, que utiliza-se da
%operação $\mathit{xQueueGenericSend}$ especificada na máquina
%$\mathbf{Queue_Basic}$ para enviar uma mensagem para a uma fila de mensagens.


%\begin{figure}[!h]
%\begin{small}
%$$
%\begin{array}[t]{ccc}
%\begin{array}[t]{l}  
%\mathit{return} \longleftarrow \mathit{xQueueSend}(\mathit{pxQueue},
%\mathit{pvItemToQueue}, \mathit{xTicksToWait})=\\
%\mathbf{PRE}\\
%\quad \mathit{pxQueue}\in \mathit{queues}  \land\\  
%\quad \mathit{pvItemToQueue} \in \mathit{ITEM}  \land\\  
%\quad \mathit{xTicksToWait}\in \mathit{TICK}\\
%\mathbf{THEN}\\
%\quad \mathbf{ANY}\\ 
%\quad\quad \mathit{copy\_position}\\
%\quad \mathbf{WHERE}\\
%\quad\quad \mathit{copy\_position} \in \mathit{COPY\_POSITION}\\
%\quad \mathbf{THEN}\\
%\quad\quad \mathit{return} \gets \mathit{xQueueGenericSend}(\mathit{pxQueue},
%\mathit{pvItemToQueue},\\
%\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad
%\mathit{xTicksToWait},\mathit{copy\_position})\\ 
%\quad \mathbf{END}\\
%\mathbf{END};
%\end{array}
%\end{array}
%$$
%\end{small}
%\caption{Operação $\mathit{xQueueSend}$}
%\label{fig:xQueueSend}
%\end{figure}
  

\subsection{Prioridades de tarefa}

Para adicionar a característica de prioridade de uma tarefa à
modelagem inicial, foi necessário apenas fazer o refinamento do
conceito de tarefa e suas operações básicas, ou seja, o refinamento da
máquina $\mathit{Task\_Core}$. Essa simplicidade é consequência direta
da modularição realizada na primeira etapa da especificação, pois as
demais máquinas que utilizam o conceito de tarefa fazem esse uso
através do módulo $\mathit{Task\_Core}$, sendo necessário apenas o
refinamento do mesmo para que a característica de prioridade seja
adicionada a modelagem. Esse refinamento é feito através do módulo
$\mathit{Task\_CoreR}$ no qual os estados e operações do módulo
$\mathit{Task\_Core}$ são refinados de acordo com os comportamentos
exigidos pela característica de prioridade.

A nova especificação do conceito de tarefa ficou refinada como
demonstra a figura~\ref{fig:tarefa_refinamento}. Nela foram
introduzidas:
\begin{itemize}
\item a definição do conjunto de prioridade, $\mathit{PRIORITY}$ o
  qual, no nível anterior, tinha sido deixado abstrato, 
\item uma variável $\mathit{t\_priority}$, que é uma função que
  associa a uma tarefa a sua prioridade,
\item e a restrição no invariante usado para especificar que os
  estados válidos devem garantir que, uma vez inicializado o
  escalonador, não há tarefa pronta com prioridade maior que a
  tarefa em execução.
\end{itemize}

\begin{figure}[!ht]
\begin{small}
$$
\begin{array}[t]{cc}
\begin{array}[t]{l}

\PROPERTIES\\
\quad \mathit{PRIORITY} = \\
\quad\quad\quad 0..(\mathit{configMAX\_PRIORITIES-1})\\
\quad   \ldots \\
\mathbf{VARIABLES}\\
\quad \ldots\\
\quad \mathit{t\_priority}\\
\quad \ldots
\end{array}
\begin{array}[t]{l}

\mathbf{INVARIANTS}\\
\quad \mathit{t\_priority} \in \mathit{TASK} \pfun \mathit{PRIORITY} \land \\ 
\quad \dom(\mathit{t_priority})=\mathit{tasks} \land \\
\quad \forall \mathit{tt}.(\mathit{tt} \in \mathit{ready} \land\\
\quad\quad\quad\quad\mathit{ready}\neq \emptyset \land\\
\quad\quad\quad\quad\mathit{running} \neq \mathit{TASK\_NULL} \land\\
\quad\quad\quad\quad\mathit{tt}\neq \mathit{running} \Rightarrow\\
\quad\quad\quad\quad\mathit{t\_priority}(\mathit{running})\geq
							\mathit{t\_priority}(\mathit{tt})\\ 
\quad\quad\quad)
\end{array}
\end{array}
$$
\end{small}
\caption{Refinamento do conceito tarefa}
\label{fig:tarefa_refinamento}
\end{figure}

\subsubsection{Refinamento das operações básicas}

Após o refinamento do conceito de tarefa, foi necessário fazer também
o refinamento das suas operações básicas. Assim todas as operações
presentes na máquina $\mathit{Task\_Core}$ foram refinadas na máquina
$\mathit{Task\_CoreR}$.  Um exemplo desse refinamento está na operação
$\mathit{t\_create}$ que foi refinada como demonstra a figura
~\ref{fig:t_create_refinamento}. Através dela percebe-se que ao ser
criada uma tarefa é necessita agora relacionar essa com uma
prioridade, sendo em seguida, essa relação é armazenada na variável
$\mathit{t\_priority}$. As demais operações seguem o mesmo raciocínio
e procuram adicionar o conceito de prioridade ao seu funcionamento
respeitado as restrições impostas pelo $\mathit{INVARIANT}$ da máquina
abstrata e do seu refinamento.

\begin{figure}[!h]
\begin{small}

$$
\begin{array}[t]{cc}
\begin{array}[t]{l}
\mathit{result} \longleftarrow \mathit{t\_create}
										(\mathit{priority}) = \\
\PRE \\
\quad \mathit{priority} \in \mathit{PRIORITY} \land \\ 
\quad \mathit{running}=\mathit{TASK\_NULL}\\
\THEN \\
\quad \ANY\\
\quad\quad \mathit{task}\\
\quad \WHERE\\
\quad\quad \mathit{task} \in \mathit{TASK} \land \\
\quad\quad \mathit{task} \not\in \mathit{tasks} \\ 
\quad\ldots
\end{array}

\begin{array}[t]{l}
\quad \ldots\\
\quad \THEN \\    	    
\quad\quad \mathit{tasks} := \{ task \} \cup \mathit{tasks} \parallel\\
\quad\quad \mathit{t\_priority}:= \mathit{t\_priority} \cup
\{\mathit{task}\mapsto \mathit{priority}\}\parallel\\ 
\quad\quad \mathit{ready} := \{
\mathit{task} \} \cup \mathit{ready} \parallel \\ 
\quad\quad \mathit{result} :=\mathit{task}\\ 
\quad \END\\      
\END;\\
\end{array}
\end{array}
$$

\end{small}
\caption{Refinamento da operação \textit{t\_create}}
\label{fig:t_create_refinamento}
\end{figure}

\section{Conclusões e Trabalhos futuros}
\label{sec:conclusoes}

Como conclusões desse trabalho têm-se além da inicialização do desafio
proposto por Jim de especificar formalmente o sistema operacional de
tempo real FreeRTOS, um ponta pé para a criação de uma ferramenta
capaz de construir sistemas de tempo real mais fidedigno, pois com a
especificação do FreeRTOS esse sistema terá a garantia, comprovada pro
sua especificação, que realmente cumpre as funcionalidades propostas
por ele.

Entretanto além comprovar formalmente as propriedades do FreeRTOS e
servir como base para uma modelagem formal do sistema, essa
especificação também pode ser usadas como entrada para outras técnicas
de verificação como a criação de caso de teste apartir de uma
especificação do sistema, onde a partir da especificação são gerados
casos de teste para verificar o correto funcionamento determinadas
funcionalidades do sistema.

Contudo, como esse trabalho trata-se apenas de uma introdução para uma
completa modelagem do sistema, ele possui várias vertentes para a sua
continuação, sendo a mais natural dessas vertentes o refinamento até o
nível de algoritmo dessa especificação, o que proporcionaria uma
modelagem capaz de ser sintetizada para uma alguma linguagem de
programação convencional como C.

Outra possibilidade de continuação desse trabalho seria a
especificação do sistema usando outro tipo de formalismo, no qual o
mais recomendadopara aproveitar a especificação aqui inicializada
seria o Event B, considerado como uma extensão do método B, para a
especificação com propriedades concorrentes.

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}

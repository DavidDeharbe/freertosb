% Exemplo de relatório técnico e outros documentos do DIMAp-UFRN
% com texto em português formatado com LaTeX

\documentclass[capa]{rt-dimap}
% Opções da classe rt-dimap
%   [capa]  -> Gerar a capa colorida do relatório técnico
%   [plain] -> Usar o estilo "plain" de citação bibliográfica
%\newcommand{\FreeRTOS}{\operatorname{\textit{FreeRTOS }}}

%% Keywords for the B method
\newcommand{\MACHINE}{\operatorname{\mathbf{MACHINE}}}
\newcommand{\REFINEMENT}{\operatorname{\mathbf{REFINEMENT}}}
\newcommand{\IMPLEMENTATION}{\operatorname{\mathbf{IMPLEMENTATION}}}
\newcommand{\REFINES}{\operatorname{\mathbf{REFINES}}}
\newcommand{\SEES}{\operatorname{\mathbf{SEES}}}
\newcommand{\IMPORTS}{\operatorname{\mathbf{IMPORTS}}}
\newcommand{\SETS}{\operatorname{\mathbf{SETS}}}
\newcommand{\CONSTANTS}{\operatorname{\mathbf{CONSTANTS}}}
\newcommand{\PROPERTIES}{\operatorname{\mathbf{PROPERTIES}}}
\newcommand{\VARIABLES}{\operatorname{\mathbf{VARIABLES}}}
\newcommand{\INVARIANT}{\operatorname{\mathbf{INVARIANT}}}
\newcommand{\INITIALISATION}{\operatorname{\mathbf{INITIALISATION}}}
\newcommand{\OPERATIONS}{\operatorname{\mathbf{OPERATIONS}}}
\newcommand{\BEGIN}{\operatorname{\mathbf{BEGIN}}}
\newcommand{\END}{\operatorname{\mathbf{END}}}
\newcommand{\PRE}{\operatorname{\mathbf{PRE}}}
\newcommand{\IF}{\operatorname{\mathbf{IF}}}
\newcommand{\THEN}{\operatorname{\mathbf{THEN}}}
\newcommand{\ELSE}{\operatorname{\mathbf{ELSE}}}
\newcommand{\ELSIF}{\operatorname{\mathbf{ELSIF}}}
\newcommand{\ANY}{\operatorname{\mathbf{ANY}}}
\newcommand{\WHERE}{\operatorname{\mathbf{WHERE}}}
\newcommand{\CASE}{\operatorname{\mathbf{CASE}}}
\newcommand{\OF}{\operatorname{\mathbf{OF}}}
\newcommand{\EITHER}{\operatorname{\mathbf{EITHER}}}
\newcommand{\OR}{\operatorname{\mathbf{OR}}}
\newcommand{\WHILE}{\operatorname{\mathbf{WHILE}}}
\newcommand{\DO}{\operatorname{\mathbf{DO}}}
\newcommand{\VARIANT}{\operatorname{\mathbf{VARIANT}}}

%% Commonly used math entities
\newcommand{\pow}{\operatorname{\mathbb{P}}}
\newcommand{\dom}{\operatorname{\mbox{dom}}}
\newcommand{\nat}{\operatorname{\mathbb{N}}}
\newcommand{\pfun}{\operatorname{\rightarrow\mkern-22mu+}}

\begin{document}
%---------------------------------------------------------- PAGINA DE CAPA %
% Número do relatório (para reserva, consulte "regivan@dimap.ufrn.br.br").
\TRNumber{000}

% O tipo do documento: Relatório Técnico, Relatório de Disciplina, etc.
%   \TRType{Technical Report}
%   \TRTipo{Relatório Técnico}

%\TRType{Final Year Project Proposal}
%\TRTipo{Prop. de Projeto F. de Curso}

% \TRType{Lecture Report}
% \TRTipo{Relatório de Disciplina}


% Data de publição (para a capa)
\TRYear{2009}  
\TRMonth{02} % Numérico, 01-12

% Lista de autores para capa (sem afiliações).
\TRAuthor{Stephenso Galvão, David Déharbe}

% Título para a capa (use \\ para forcar quebras de linha).
\TRTitle{Modelagem em B do \\Sistema de Tempo Real FreeRTOS}

\TRMakeCover
%---------------------------------------------------------- PAGINA DE CAPA %


%%---------------------------------------------------------- TITULO E AUTOR DA PAG 1 %
% TITULO e NOMES DOS AUTORES, completos, para a pagina 1.
% Use "\\" para quebrar linhas, "\and" para separar autores.
%
\title{\bf Modelagem em B do \\Sistema de Tempo Real FreeRTOS}

\author{Stephenson Galvão \\ {\small stepgalvao@consiste.ufrn.br}  
	 \and David Déharbe \\ {\small deharbe@consiste.ufrn.br} }
    %\thanks{Aluno do Programa de Pós-graduação em Sistemas e Computação,  UFRN}
\date{}

\maketitle
%---------------------------------------------------------- TITULO E AUTOR DA PAG 1 %


%---------------------------------------------------------- CABECALHO DAS PAGINAS %
% Nomes de autores ABREVIADOS e título ABREVIADO, para cabecalhos em cada página.
\markboth{\small Galvão, S.S.L.}{\small Modelagem do FreeRTOS}
\pagestyle{myheadings}
%---------------------------------------------------------- CABECALHO DAS PAGINAS %


%----------------------------------------------------------ABSTRACT %
\begin{abstract}
This is the abstract. 
\end{abstract}

\begin{keywords}
FreeRTOS.
\end{keywords}
%----------------------------------------------------------ABSTRACT %

%----------------------------------------------------------RESUMO %
\begin{resumo} 
Este é o resumo
\end{resumo}

\begin{palavras-chave}
FreeRTOS.
\end{palavras-chave}
%----------------------------------------------------------RESUMO %


\section{Introdução}
\label{sec:intr}


Sistemas de Tempo Real (STR) são sistemas que tem como principal característica
um rigoroso tempo de resposta aos eventos externos. Devido a isso, eles são bastante
utilizados, pelas industrias, em aplicações críticas que possuem o tempo de
respota como um fator crucial. O monitoramento de paciente em hospitais, o controle de
processos industriais e o controle de veículos (aeronaves, trens e automóveis)
são apenas alguns exemplos de aplicações dos sistemas de tempo real.

Em razão dessa  grante importância e utilização dos STR, foi proposto, por Jim,
em \cite{jim:sbmf}, como um dos grandes desafios da ciência da computação, a
especificação formal de um sistema operacional de tempo real, denominado
FreeRTOS. Para assim, proporcionar ao mesmo a segurança, confiabilidade e
coerência que uma especificação formal oferece, tornando-no mais fidedigno

O FreeRTOS é um sistema operacional de tempo real bastanten simple. Aprova disso
está em seu código fonte, que é aberto e composto aproximadamente 2.242 linhas de
código, número bastante pequeno para um sistema operacional. Além disso, ele é
capaz de trabalhar em ambientes com quantidade de recursos limitada, como os
microprocessadore, sendo, oficialmente\footnote{Existem também portas do FreeRTOS
não oficias, disponibilizada pelos usuários, para várias outras arquiteturas
diferentes}, portável para 17 arquiteturas de microprocessadores diferentes,
entre ela as \textit{PIC}, \textit{ARM}, \textit{Zilog 80} e \textit{Cygnal
8051}, arquiteturas bastante usada pelas industrias de microeletrónica
\cite{freertos}.

Seguindo esse contexto, o presente relatório tem como principal objetivo
descrever uma modelagem inicial em B, do STR FreeRTOS e, com isso, iniciar a
resolução do desafio proposto pelo Jim. Entretanto, por trata-se de uma
especificação inicial, alguns conceitos desse sistema de tempo real foram
brevemente abstraídos da modelagem, sendo que os mesmo serão tratados em futuros
refinamento. 
%Assim, primordialmente foram especificados, em um alto nível de
%abstração, somente os conceitos e funcionalidades de tarefas e filas de
%mensagens, dando ênfase principalemente à caracteristica de estado de um
%tarefa e suas trocas.

Para cumprir o seu objetivo, esse relatório foi divido da seguinte forma:
primeiramente tem-se uma introdução ao FreeRTOS, demonstrado as suas principais
características e conceitos fundamentais; em seguinda, é apresentado o plano de
modelagem seguido na realização da especificação, nele estão presente, junto com
suas descrições, as funcionalidades e os conceitos das API escolhidos para serem
desenvolvidos nessa modelagem inicial; após isso, na sessão \ref{sec:Modelling},
é demonstrado como foi feita a modelagem do FreeRTOS, suas máquinas com seus
estados e operações; e para encerrar, tem-se as considerações finais, onde
estão as conclusões do trabalho, e os trabalhos futuros, falando como será
feita a continuação desta modelagem.




%Para ser aceito para publicação, um Relatório Técnico deve ser avalisado por,
%pelo menos um professor do INF. No caso de um professor ser autor ou co-autor
%do relatório, poderá solicitar que um outro professor faça a avaliação do
%mesmo. Neste caso, o nome deste professor avaliador deverá constar na seção de
%agradecimentos (Seção \ref{sec:agrad}).



\section{FreeRTOS}
\label{sec:freertos}
% [Uma introdução ao FreeRTOS demonstrando as suas funcionalidades (casos no qual
% o FreeRTOS é utilizado), características(portabilidade, pouco código,ect) e
% conceitos(tarefa,co-rotina, fila de mensagem, mutex, ect)]
 
O \textit{FreeRTOS} é um sistemas de tempo real projetado para ser pequeno,
simples e fácil de usar. O seu código fonte é aberto e possui aproximadamente
2.242 linhas de código, que estão basicamente distribuidas em três arquivos
(task.c, queue.c e list.c), nos quais são implementados seus principais conceitos
e funcionalidades. Além disso, outra característica importante desse STR é a sua
portabilidade, sendo oficialmente portável para 17 arquiteturas diferentes, entre
elas a PIC, ARM, Zilog Z80 e PC, bastantes usadas pelas industrias de
microeletrônica.

O seu \textit{kernel}, além de ser multiprocesso, suporta três tipo diferentes de
configurações: preemptivo, cooperativo e híbrido. No tipo preemptivo, a processo
em execução pode ser enterrompido a qualquer momento pelo escalonador, sendo em
seguida substituido por outro processo. Diferentimente, no tipo cooperativo, o
processo em execução é quem descide o momento de sua pausa, seguida da sua
substituição. E por fim, no tipo híbrido, o escalonador funciona hora como
preemptivo e hora como cooperativo.

Os conceitos fundamentais implementado pelo FreeRTOS e presente na maioria dos
sistemas de tempo real são tarefa, co-rotina, fila de mensagem, semáforo e mutex.
Eles junto com suas funcionalidades formam todo o núcleo do FreeRTOS, restanto
para o usuário apenas a utilização dos mesmo para a criação de novos sistemas. A
seguir, detalharemos as características e utilização de cada um desses conceitos.

\subsection{Tarefa}
\label{subsec:tarefa}
Tarefas são unidades de trabalho independentes que compoem um sistema
multitarefas. No FreeRTOS, uma tarefa é composta por: um pilha de contexto, que
serve para armazenar o contexto de execução (estados dos registradores)  no
momento que uma tarefa é interrompida; uma prioridade que serve para indicar a
sua importância da tarefa para o sistema; um estado que desmonstra a atual
situação da tarefa; e uma função que é executado quando a tarefa assume o
controle do processado \cite{Li:2003}.

Os estados que uma tarefa pode assumir no FreeRTOS são: executando, pronto,
bloqueado e suspenso. O estado ``executando'' informa que a tarefa está em
execução, ou sejá, possui, atualmente, o controle do processador. Somente uma
tarefa pode possuir o estado executando no FreeRTOS. O estado ``pronto'' informa
que a tarefa está pronta para entrar em execução, aguardando apenas assumir o
controle do processador. No estado ``bloqueado'' a tarefa encontra-se bloqueada a
espera de algum evento necessário para continuar a sua execução. E por último, no
estado ``suspenso'', a tarefa foi suspensa pelo escalonador através da chamada ao
método vTaskSuspend(), disponível na API do FreeRTOS. O gráfico completo de
transição de estados que uma tarefa pode sofre é demonstrado na figura
\ref{fig:tkstates}.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{tkstate.eps}
\caption{Gráfico de transição de estados das tarefas do FreeRTOS}
\label{fig:tkstates}
\end{figure}

A prioridade de uma tarefa pode váriar de 0 até uma constante de prioridade
máxima, definida pelo o usuário. No FreeRTOS, as prioridades servem para indicar
a importância de uma tarefa para o sistema. Elas são usadas principalmente pela
política de escalonamento entre tarefas. Nessa política, as tarefas de maior
prioridade, tem preferência sobre as tarefas de menor prioridade do mesmo estado.
Assim, para escolher a tarefa que irá entrar em execução, o escalonador percorre
a lista de tarefas com o estado ``pronto'' selecionando aquela de maior
prioridade. Um exemplo do  funcionamento do escalonador pode ser visto na na
figura \ref{fig:scheduler}, na qual as tarefas de menores prioridades são
interrompidas por tarefas de maiores prioridades quando estas assumem o estado
``pronto''. Outro fator importante no funcionamento de escalonador que vale
apena resalta, é que tarefas de mesma prioridade dividem o tempo de execução
entre si. Com isso, se houver duas tarefas prontas e com a prioridade máxima,
elas irão dividir o tempo de processamento em frações iguais.


\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{scheduler.eps}
\caption{Funcionamento do escalonador do FreeRTOS}
\label{fig:scheduler}
\end{figure}

%Assim, o gráfico de transição de estados das tarefas do FreeRTOS comporta-se
%como o da figura \ref{fig:tkstates}.Nele uma tarefa pode ir do estado
%executando para pronta, bloqueado ou suspensa, de bloqueada para suspensa ou
%pronta, de suspensa para pronta e de pronta para executando ou suspens

% [Exemplificar utilizando uma figura do funcionamento do escalonador do
% FreeRTOS]
  
\subsection{Co-Rotina}
\label{subsec:crotina}
As co-rotinas são similares às tarefas, também possuem prioridade, estados e uma
função que é executado no momento em que a co-rotina assume o controle do
escalonador. Entranto, existem algumas diferenças importantes entre tarefas e
co-rotinas, sendo a principal, a ausência da pilha de contexto. Co-rotinas não
possuem pilha de contexto e, conseguentemente, não possuem contexto próprio, ou
seja, os valores armazenados nos registradores por uma co-rotinas, não são
guardados no momento em que ela interrompe a sua execução. Assim, uma co-rotina
pode armazenar o valor três em um registrador, antes de interrompe-se, e, quando
ela retorna a sua execução, o valor dessa variável pode ou não ser o mesmo, pois
pode ter entrado em execução e alterado o valor do registrado.

Outra diferença importante entre co-rotinas e tarefas está na quantidade de
estado. As co-rotinas só possuem os estado ``executando'', ``pronto'' e
``bloqueada'' diferente que, além dos três, possuem o estado ``suspenso''.
Conseguentemente, o gráfico de transição de estados de uma co-rotina também é
diferente do gráfico de tarefas, sendo esse demonstrado pela figura
\ref{fig:cstates}

As co-rotinas também possuem um gerenciamento diferente do de tarefas. Elas são
escalonadas de forma coopertiva, ou seja, elas são quem descidem o momento da sua
interrupção. Assim, resta apenas ao escalonador a tarefa de descidir qual
co-rotina deve assumir o processador no momento em que a co-rotina em execução
interrompe-se, sendo que a política usada para essa escolha é a mesma usadas
pelas tarefas.


\subsection{Fila de Mensagens}
\label{subsec:fmensagem}
Filas de mensagens são estruturas primitivas de comunicação entre tarefas. Elas
funcionam como um túnel no qual tarefas enviam e recebem mensagem. No FreeRTOS,
as filas de mensagens possuem tamanho fixo defino pelo tamanho e quantidade de
ítens (mensagem) que ela pode armazenados. Para uma tarefa enviar uma mensagem
para uma fila, primeiramente a fila não pode estar cheia, caso contrário, a
tarefa é bloqueada até que seja liberado um lugar na fila. O mesmo 
ocorre quando uma tarefa tenta receber uma mensagem de uma fila, só que,
nesse caso, a fila deve possuir pelo menos um item, para que esse seja lido,
caso contrário, a tarefa é bloqueda até a chegada de um item na fila de
mensagens.

No FreeRTOS, é possível definir o tempo máximo que uma tarefa pode ficar
bloqueada esperado por um evento(liberação de espaço ou chega de mensagem) em
uma fila. E no casos em que existerem mais de uma tarefa bloqueadas aguardando
por um evento de uma fila, as tarefas de maior prioridade têm preferência sobre
as demais.

\subsection{Semâforos}
Semâforos são mecanismo usados na sicronização entre tarefas. Eles funcionam como
uma chave que libera, ou não, o uso de um determinado recurso. Assim quando uma
tarefa deseja acessar um recurso comportilhado, ela primeiramente deve solicitar
o semâforo do recurso, caso esteja liberado, a tarefa tem a permição de utilizar
o recurso e, em seguida, libera o semáforo, caso contrário, a tarefa é
bloqueada até que o semáforo sejá liberado.

No FreeRTOS os semâforo funcionam como uma fila de mensagens com um único item.
Assim, quando a fila estiver vazia, indica que o semáforo está sendo usado e,
quando a fila estiver cheia, indica que o semâforo está liberado. Desse modo, as
tarefas que utilizam essa fila não estão preocupadas com o conteúdo
do item, mas apenas com o estado da fila, se ela está cheia ou vazia.


\subsection{Mutex}
Mutex são parecidos com o semáforo. A única diferênça entre os dois é que o mutex
implementa o mecanismo de herança de prioridade, o qual impede que uma tarefa de
maior prioridade fique bloqueada a espera de um semáforo ocupado por uma tarefa
de menor prioridade, causando o que chamamos de inversão de prioridade.

Para evitar esse problema, o mecanismo de herança de prioridade, ao perceber
que uma tarefa solicita o semáforo, verifica se a tarefa solicitante possui
prioridade maior que a tarefa com o semáforo. Caso afirmativo, a tarefa que
retém o semâforo tem mometaneamente sua prioridade elevada, para que assim ela
possar realizar a suas funções sem interrupções e, conseguentemente, liberar
rapidamente o semáforo.

\section{Projeto da Modelagem}
\label{sec:project}

Como demonstrado na sessão anterior, o FreeRTOS possui uma grande quantidade de
conceitos fundamentais. Devido a isso, antes de iniciar-se a sua especificação
foi criado em \cite{sroute} um projeto de modelagem, no qual alguns dos
seus principais conceitos fundamentais, junto com suas funcionalidades foram
escolhidos para serem modelados inicialmente. Assim, o projeto de modelagem
funcionou como um roteiro para a especificação, dizendo como o por onde começar a
modelagem do FreeRTOS.

Devido a sua grande importância, os conceito fundamentais escolhidos no projeto
de modelagem foram, tarefa (sessão \ref{subsec:tarefa}) e fila de mensagem
(sessão \ref{subsec:fmensagem}), sendo que cada um desses conceito possui uma
enorme quantidade de funcionalidades. Assim, para o melhor entendimento e
gerenciamento, essas funcionalidades foram classificadas em cinco conjuntos
diferentes: criação de tarefa; controle de tarefa; controle do kernel;
utilidades de tarefas e gerenciamento de fila. A seguir, tem-se em detalhe
a composição de cada um desses conjuntos grupo como também a descrição de cada
funcionalidade que os compoem

\subsection{Criação de tarefa}
\label{subsec:tcreation}

No conjuto Criação de tarefas, estão presente algumas funcionalidades
responsáveis pela criação, exclusão e referênciamente de uma tarefa. Ele é
formado pelas seguintes operações:

\begin{itemize}
  \item \textbf{xTaskCreate} - Cria uma nova tarefa que será gerenciada pelo
  FreeRTOS, retornando uma referência para a tarefa criada. Caso a tarefa não
  possa ser criada, uma referência nula é retornada no lugar da tarefa criada
  
  \item \textbf{xTaskDelete} - Remove uma tarefa do FreeRTOS. Entranto, os
  espaço alocado pela tarefa só será liberando pela a tarefa ociosa
  \footnote{Tarefa executada quando o processador estar ocioso (sem tarefas
  para entrar em execução). Ela é responsável pela liberação da memória
  alocada por determinadas estruturas (Tarefa, Fila de Mensagem, Co-rotina, etc)
  no FreeRTOS}.
  
  \item \textbf{xTaskHadle} - Estrutura de referênciamento a uma tarefa
\end{itemize}

\subsection{Controle de tarefa}
\label{subsec:tcontrol}
O grupo de Controle de tarefa é responsável pelo controle e gerênciamento das
tarefas presentes no FreeRTOS. Desse modo, as funcionalidades que forma esse
grupo são:

\begin{itemize}
  \item \textbf{uxTaskPriorityGet} - Informa a prioridade de uma tarefa
  
  \item \textbf{vTaskSuspend} - Coloca uma tarefa no estado ``suspenso''
  
  \item \textbf{vTaskResume}- Retorna uma tarefa suspensa colocando-a no estado
  pronto
  
  \item \textbf{vTaskPrioritySet} - Altera a prioridade de uma tarefa
  
  % \NOTE - Pedir para o David ler essa parte
  \item \textbf{vTaskDelay} - Bloqueia uma tarefa por uma determinada
  quantidade de tempo. Nesse método, o tempo de desbloqueio de uma tarefa é
  calculado com base no tempo de chamada ao mesmo, o que torna-no não
  recomendável para a criação de tarefas cíclicas, pois outras tarefas e
  interrupções podem influenciar no tempo em que o método será chamado
  novamente.
  
  \item \textbf{vTaskDelayUntil} - Esse método, assim como o
  \textit{vTaskDelay}, coloca uma tarefa no estado bloqueado por uma determinada
  quantidade de tempo. Entretanto, diferentemente do método passado, o tempo de
  desbloqueio de uma tarefa é calculado com base no instante do último
  desbloqueio mesma. Assim é garantido que tempo entre o bloqueio e o
  desbloqueio de uma tarefa será sempre o mesmo, o que torna esse método
  recomendado para a criação de tarefas cíclicas.
  
\end{itemize}

\subsection{Controle do kernel}
\label{subsec:kcontrol}
As funcionalidades presentes no conjunto Controle do kernel são responsáveis por
gerênciar, iniciar e finalizar as atividades. Nesse grupo estão presentes as
seguintes operações:

\begin{itemize}
  \item \textbf{vTaskStartScheduler} - Esse método primeiramente cria a tarefa
  ociosa e em seguinda inicia as atividades do escalonador, colocando-o no
  estado ``executando''\footnote{O escalonador do FreeRTOS possui três estados:
  executando, que indica que o escalonador está em execução; não iniciado, que 
 indica que o escalonador não foi inicializado ainda; e suspenso, que indica qu
e a atividades do escalonador estão suspensas }. Caso, a tarefa ociosa não
possa ser criada, o escalonador não será inicializado permanecendo no estado
não iniciado.

  \item \textbf{vTaskEndScheduler} - Finaliza as atividades do escalonador
  colocando-o no estado não iniciado. Para isso ele primeiramente exclui todas as
  estruturas (tarefas, filas de mensagens, co-rotinas, etc) criadas no FreeR
 TOS e em seguida finaliza o escalonador.
 
  \item \textbf{vTaskSuspendAll}- Suspende temporariamente todas atividades do
  escalonador colocando-o no estado suspenso.
  
  \item \textbf{xTaskResumeAll}- Retorna todas as atividades do escalonador
  quando esse encontra-se no estado suspenso.
  
\end{itemize}


\subsection{Utilidades de tarefas}
\label{subsec:tutilities}
No grupo de utilidades de tarefas, encontram-se as operações responsáveis
por fornecer informações úties sobre o estado do kernel. Esse grupo é composto
pelas seguintes funções:

\begin{itemize}
  \item \textbf{xTaskGetCurrentTaskHandle} - Retorna a referência para a
  tarefa em execução
  \item \textbf{xTaskGetSchedulerState} - Informa o atual estado do
  escalonador (executando, suspenso ou não iniciado).
  \item \textbf{uxTaskGetNumberOfTasks} - Informa a atual quantidade de tarefas
  tarefas do FreeRTOS.
  \item \textbf{xTaskGetTickCount} - Informa a quantidade de tempo decorrido
  desde a inicialização do escalonador 
\end{itemize}

\subsection{Gerenciamento das filas de mensagens}
\label{subsec:fmanagemente}
As funcionalidades presentes no grupo Gerenciamento das filas de mensagens cabêm
as obrigações de gerenciar, criar eexcluir as filas de mensagens do FreeRTOS.
Esse grupo é formado pela as seguintes funções:

\begin{itemize}
  \item \textbf{xQueueCreate} - Cria uma nova fila de mensagem, retornando uma
  referência para a mesma. Caso a fila de mensagem não possa ser criada, uma
  referência de fila nula é retornada.
  
  \item \textbf{xQueueSend} - Método usado por uma tarefa para enviar uma
  mensagem para uma fila de mensagens. Caso a fila esteja cheia e não possa
  receber a mensagem, a tarefa é bloqueada até que seja liberado uma lugar na
  fila.
  
  \item \textbf{xQueueSendToBack} - Esse método funciona do mesmo modo que o
  \textit{xQueueSendToBack}. Ele envia uma mensagem para o final de uma fila de
  uma fila de mensagem e caso essa esteja cheia, a tarefa que utilizou o método
  é bloqueada até que seja liberando um lugar na fila.
  
  \item \textbf{xQueueSendToFront} - Método utilizado por uma tarefa para
  enviar uma mensagem para o início de uma fila de mensagem. Caso a fila esteja
  cheia, a tarefa é bloqueada até que seja liberado um espaço na fila de
  mensagem
  
  \item \textbf{xQueueReceive} - Método utilizado por uma tarefa para ler e
  retirar uma mensagem localizada no início da fila de mensagens. Caso a fila de
  mensagens esteja vazia, a tarefa é bloqueada até que uma mensagem chegue na
  fila.
  
  \item \textbf{xQueuePeek} -  Método utilizado por uma tarefa para ler sem
  retirar uma mensagem localizada no início da fila de mensagens. Caso a fila de
  mensagens esteja vazia, a tarefa é bloqueada até que uma mensagem chegue na
  fila.
  
  \item \textbf{vQueueDelete} - Exclui uma fila de mensagens do FreeRTOS.
  Entretando, o espaço oculpado pela a mesma só será liberado pela a tarefa
  ociosa.
  
\end{itemize}

\subsection{Parâmentros de configuração}
\label{subsec:config}
Por último, tem-se um grupo que não trata das funcionalidades da API do FreeRTOS,
mas de seus parâmentros de configuração. Esses parâmetros são atributos que
permitem ao Kernel uma compilação sob medida para cada aplicação em particular.
Assim, eles funcionam basicamente como um indicativo para o kernel dizendo quais
os conceitos e funcionalidade que a aplicação ira utilizar. A lista completa de
todos os parâmentros utilizados no projeto de modelagem pode ser encontrada a
seguir:

\begin{itemize}
  \item \textbf{configMAX\_PRIORITIES} - Esse parâmentro informa o número da
  prioridade máxima prioridade que será utilizada no sistema.
  
  \item \textbf{INCLUDE\_vTaskPrioritySet} - Esse parâmetro indica a utilização,
  ou não, da funcionalidade \textit{vTaskPrioritySet} pelo sistema.
  
  \item {\textbf{INCLUDE\_vTaskSuspend} - Esse parâmetro indica a utilizção, ou
  não, da funcionalidade \textit{vTaskSuspend}} pelo sistema.
  
  \item \textbf{INCLUDE\_uxTaskPriorityGet} - Esse parâmetro indica a
  utilização, ou não, da funcionalidade \textit{uxTaskPriorityGet} pelo sistema.
  
  \item \textbf{INCLUDE\_vTaskDelete} - Esse parâmetro indica a utilização, ou
  não, da funcionalidade \textit{vTaskDelete} pelo sistema. 
  
  
  \item \textbf{INCLUDE\_xTaskGetSchedulerState} - Esse parâmetro indica a
  utilização, ou não, da funcionalidade \textit{xTaskGetSchedulerState} pelo sistema.
  
  \item \textbf{INCLUDE\_xTaskGetCurrentTaskHandle} - Esse parâmetro indica a
  utilização, ou não, da funcionalidade \textit{xTaskGetCurrentTaskHandle} pelo sistema.
  
  \item \textbf{INCLUDE\_vTaskDelay} - Esse parâmetro indica a
  utilização, ou não, da funcionalidade \textit{vTaskDelay} pelo sistema.  
  
  \item \textbf{INCLUDE\_vTaskDelayUntil} - Esse parâmetro indica a
  utilização, ou não, da funcionalidade \textit{vTaskDelayUntil} pelo sistema.  
   
\end{itemize}
	
\section{Modelagem}
\label{sec:Modelling}

%A modelagem B do FreeRTOS, foi dividida entre 7 máquinas (), nas quais são
%modelados os conceitos de tarefa, fila de mensagem, suas funcionalidades e seus
%parâmetros de configuração, descritos na sessão \ref{sec:project}. Assim, para
%uma melhor compreensão essa sessão foi dividida da seguinte forma, modelagem
%dos conceitos, explica como foram modelados os conceitos de tarefa e fila de
%mensagem, e modelagem das funcionalidades, demonstra como foram especificadas
%as funcionalidades e os parâmetros de configuração do FreeRTOS.

\subsection{Tarefas}
\subsubsection{Conceitos}

O conceito de tarefa é modelado através da máquina $\mathbf{Task\_Core}$.
Inicialmente esse conceito foi especificado contendo apenas a característica de
estado, sendo as demais características (ver sessão \ref{subsec:tarefa})
especificadas em futuros refinamentos. Assim, a especificação do conceito de
tarefa foi feita como demonstra a figura \ref{fig:task-modelling}. Nela,
percebe-se que primeiramente foi criado o conjunto abstrato $\mathit{TASK}$, que
simboliza o conjunto universo de todas as tarefas que podem ser criadas no
FreeRTOS. Em seguinda, o estado de máquina $\mathit{tasks}$ é especificado para
representar o conjunto de todas as tarefas que estão sendo gerenciadas pelo
sistema, gerando a seguinte definição $\mathit{tasks} \in
\mathbf{FIN}(\mathit{TASK})$.

Ainda na figura \ref{fig:task-modelling}, nota-se também que os estados de uma
tarefa são modelados através das variáveis $\mathit{ready}$, $\mathit{running}$,
$\mathit{blocked}$ e $\mathit{suspended}$, as quais representam respectivamente
os estados pronto, executando, bloqueado e suspenso. Assim, quando uma tarefa
encontra-se no conjunto de tarefas $\mathit{ready}$, indica que ela está no
estado pronto, ocorrendo o mesmo para os demais estado. Entretanto, para uma
completa e fiel especificação dos estados, além da definição das variáveis, são
necessárias algumas restrições adicionais como: uma tarefa so pode possuir um
estado ao mesmo tempo e o sistema só pode conter uma tarefa no estado executando
em um determinado instante. Essa restrições podem ser vistas maiores detalhes no
$\mathbf{INVARIANT}$ da figura \ref{fig:task-modelling}.

\begin{figure}[!b]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathbf{SETS}\\
\quad   \mathit{TASK};\\
\quad   \ldots \\\\
    		
\mathbf{VARIABLES}\\
\quad   \mathit{tasks},\\
\quad   \mathit{blocked},\\
\quad	\mathit{running},\\
\quad	\mathit{ready}, \\
\quad	\mathit{suspended}\\
\quad	\ldots
\end{array}
\begin{array}[t]{l}

\mathbf{INVARIANTS}\\

\quad \mathit{tasks} \in \mathbf{FIN}(\mathit{TASK}) \land \\
\quad \mathit{tasks} \neq \emptyset \land \\\\

\quad \mathit{blocked}	\in \mathbf{FIN}(\mathit{TASK}) \land \\
\quad \mathit{blocked} \subset \mathit{tasks} \land \\\\

\quad \mathit{ready} \in \mathbf{FIN}(\mathit{TASK}) \land \\
\quad \mathit{ready} \subset \mathit{tasks} \land \\\\	

\quad \mathit{suspended} \in \mathbf{FIN}(\mathit{TASK}) \land \\
\quad \mathit{suspended} \subset \mathit{tasks} \land \\
\quad \ldots
\end{array}

\begin{array}[t]{l}
\quad \mathit{running} \in \mathit{TASK} \land \\
\quad \mathit{running} \in \mathit{tasks} \land \\
\quad \mathit{running}  \not\in \mathit{ready} \land \\
\quad \mathit{running} \not\in  \mathit{blocked} \land \\
\quad \mathit{running} \not\in  \mathit{suspended} \land \\\\

\quad \mathit{ready} \cup \mathit{blocked} = \emptyset \land \\ 
\quad \mathit{blocked} \cup \mathit{suspended} = \emptyset \land \\
\quad \mathit{suspended} \cup \mathit{ready} = \emptyset \land \\\\

\quad \mathit{tasks} = \mathit{\{running\}} \cup \mathit{suspended} \\ 
\quad\quad\quad\quad\quad \cup \mathit{blocked} \cup \mathit{ready}

\end{array}
\end{array}
$$
\end{small}
\caption{Modelagem do conceito tarefa}
\label{fig:task-modelling}
\end{figure}
\subsubsection{Operações básicas}
Após modelado o conceito de tarefa com sua característica de estado, foram
criadas na máquina $\mathbf{TASK_CORE}$ operações básicas que manipulam os
estados de uma tarefa e servem como suporte para a especificação das
Funcionalidades da API do FreeRTOS. Ao todo, foram criadas 12 operações, entre
elas a operação Create, responsável pela criação de uma nova tarefa e que é
especificada como mostra a figura \ref{fig:Create}.

\begin{figure}[!t]
\begin{small}

$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
\mathit{result} \longleftarrow \mathit{Create}
										(\mathit{priority}) = \\
\mathbf{PRE}\\ 
\quad \mathit{priority} \in \mathit{PRIORITY} \land \\ 
\mathbf{THEN} \\
\quad \mathbf{ANY}\\
\quad\quad \mathit{task}\\
\quad \mathbf{WHERE}\\
\quad\quad \mathit{task} \in \mathit{TASK} \land\\
\quad\quad \mathit{task} \not\in \mathit{tasks}\\ 
\quad \mathbf{THEN} \\    	    
\quad\quad \mathit{tasks} := \{ \mathit{task} \} \cup \mathit{tasks} \parallel\\ 
\quad\quad \mathbf{CHOICE}\\        	    
\quad\quad\quad 
		\mathit{ready} := \{\mathit{running}\} \cup \mathit{ready}\parallel\\ 
\quad\quad\quad\mathit{running} := \mathit{task}\\
\quad\quad\mathbf{OR}\\
\quad\quad\quad \mathit{ready} :=  \{ \mathit{task} \} \cup \mathit{ready}\\
\quad\quad\mathbf{END}\parallel \\
\quad\quad\quad\mathit{result} := \mathit{task}\\
\quad\mathbf{END}\\      
\mathbf{END};\\
\end{array}
\end{array}
$$

\end{small}
\caption{Modelagem da operação $\mathit{Create}$}
\label{fig:Create}
\end{figure}

Na operação $\mathit{Create}$ inicialmente é definida uma nova tarefa
$\mathit{task}$ que pertence ao conjunto $\mathbf{TASK}$, mas não ao conjunto
$\mathit{tasks}$. Em seguinda, essa nova tarefa é adicionada ao conjunto de
tarefas gerenciadas pelo FreeRTOS ($\mathit{tasks}$) e definido o seu estado
inicial, podendo esse ser executando ou pronto. Por último, é passado como
retorno da função uma referência da nova tarefa criada. 

Ainda na função $\mathit{Create}$, percebe-se que essa recebe como argumento um
parâmetro pertencente ao conjunto universo das prioridades. Entretanto, esse
parâmetro não é utilizado na especificação da funcionalidade, pois a
característica prioridade, não é tratada nessa modelagem inicial. Assim, o
parâmetro declarado no início da função será usado apenas em futuros refinamentos
da funcionalidade. A lista completa de todas operações da máquina
$\mathbf{TASK_CORE}$, junto com suas descrições, pode ser vista a seguir:

\begin{itemize}
\item \textbf{Create} - Cria uma nova tarefa gerenciada pelo FreeRTOS, podendo
as mesma possuir estado executando ou pronto, dependendo da prioridade da
tarefa. Entranto, como a característica prioridade foi abstraida dessa modelagem inicial,
cabe ao refinamento que implementar tal característica descidir quando uma tarefa
será criada com os estado pronto ou executando.

\item \textbf{Delete} - Exclui uma tarefa gerenciada pelo FreeRTOS. Se a tarefa
que será excluida for a tarefa em execução, uma nova tarefa será escolhida,
entre as de estado pronto, para entrar em execução.

\item \textbf{Suspend} - Coloca uma tarefa no estado suspenso. No caso, em que a
tarefa suspensa será a tarefa em execução, uma nova tarefa deverá ser escolhida,
entre as de estado pronto, para entrar em execução.

\item \textbf{Resume} - Retorna uma tarefa que estava no estado suspenso
colocando-a no estado pronto ou executando.

\item \textbf{GetPriority} - Retorna a prioridade de uma determinada tarefa, mas
como a característica prioridade não é especificada nessa modelagem inicial, essa
operação retorna apenas um elemento que pertence ao conjunto abstrado denominado
$\mathit{PRIORITIES}$, o qual representa as possíveis prioridades do FreeRTOS.

\item \textbf{GetCurrent} - Retorna uma referência para a atual tarefa em
execução

\item \textbf{GetNumberOfTasks} - Retorna o número utual de tarefas de tarefas
do FreeRTOS

\item \textbf{DelayTask} - Coloca a tarefa em execução no estado boqueado ate
uma determinada quantidade de tempo

\item \textbf{Unblock}- Desboqueia uma tarefa que estava bloqueada, colocando-a
no estado pronto ou executando.
 
\item \textbf{StartScheduler}- Cria a tarefa ociosa podendo essa ser criada com
o estado executando ou com o estado pronto

\item \textbf{EndScheduler} - Exclui todas as tarefas do FreeRTOS, zerando os
conjuntos de estados e colocando uma referência de tarefa nula na variável de
estado em execução.

\item \textbf{ResumeAll} - Desbloqueia todas as tarefas que deveriam ser
boqueadas enquanto o escalonador estava suspenso.

\end{itemize}
\subsubsection{Funcionalidades}
Feita a modelagem do conceito de tarefa junto com as suas operações básicas,
resta apenas especificar as funcionalidades da API que utilizam-se desse
conceitos e suas operações. Essa especificação é feita através da máquina
$\mathbf{TASK_CORE}$ e as funcionalidades especificadas nessa máquina pertecem
aos grupos criação de tarefa, controle de tarefa, utilidades de tarefa e
controle do kernel. Assim, para uma boa compreensão da modelagem, será
demonstrado aqui, apenas uma funcionalidade de cada grupo, sendo que as demais
podem ser vistas no repositório do projeto em \cite{freertosb}.




\subsubsection* {Criação de tarefa}
A funcionalidade escolhida para o grupo criação de tarefa foi a
$\mathit{xTaskCreate}$. Nela, uma nova tarefa é criada ou não, dependendo da
disponibiliade de memória. Assim, a especificação dessa funcionalidade foi feita
como demonstra a figura \ref{fig:xTaskCreate}, onde são especificados os dois
comportamentos possíveis. Ou a tarefa é criada através da chamada ao método
$\mathit{Create}$ e uma referência para a nova tarefa criada, junto com a
mensagem sucesso, é retonada, ou, a tarefa não é criada e uma referência nula,
junto com a mensagem de erro, é retornada.

\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
\mathit{result}, \mathit{handle} \longleftarrow \mathit{xTaskCreate}
										(\mathit{pvTaskCode},\mathit{pcName},\\
\quad\quad \quad\quad \quad\quad \quad\quad\quad\quad\quad\quad\quad\quad
			\mathit{usStackDepth},\mathit{pvParameters}, \mathit{uxPriority}) = \\
\mathbf{PRE}\\ 
\quad \mathit{pvTaskCode} \in \mathit{TASK\_CODE} \land \\ 
\quad \mathit{pcName} \in \mathit{NAME} \land \\ 
\quad \mathit{usStackDepth} \in \mathit{NATURAL} \land \\  
\quad \mathit{pvParameters} \subset \mathit{PARAMETER} \land \\ 
\quad \mathit{uxPriority} \in \mathit{PRIORITY} \land \\
\mathbf{THEN} \\
\quad \mathbf{CHOICE}\\ 
\quad \quad \mathit{handle} \leftarrow \mathit{Create} (\mathit{uxPriority})
				\parallel\\ 
\quad \quad \mathit{result} := \mathbf{pdPASS}\\
\quad	\mathbf{OR} \\
\quad \quad
\mathit{result}:=\mathbf{errCOULD\_NOT\_ALLOCATE\_REQUIRED\_MEMORY} \parallel \\ 
\quad \quad 
\mathit{handle} := \mathbf{TASK\_NULL} \\
\quad \mathbf{END};\\
\end{array}
\end{array}
$$

\end{small}
\caption{Modelagem da operação $\mathit{xTaskCreate}$}
\label{fig:xTaskCreate}
\end{figure}

\subsubsection* {Controle de tarefa}
Para o grupo controle de tarefa, vale apena enfatizar a funcionalidade
$\mathit{xTaskDelay}$, responsável pelo bloqueio de uma tarefa durante um
determinado tempo. Essa funcionalidade é especifica como demostra a figura
\ref{fig:vTaskDelay}. Nela, a operação recebe como parâmetro o tempo no qual a
tarefa deve permanecer bloqueada e, em seguida, utiliza-se desse valor para
calcular o tempo em que a mesma deve ser desbloqueada incrementando ao
tempo corrente, $\mathit{tickCount}$ \footnote{Variável da máquina
$\mathbf{TasK_Basic}$ responsável por armazernar o tempo decorrido desde a
inicialização do escalonador}, o valor passado como argumento. Após calculado o
tempo de desbloqueio a operação $\mathit{Create}$ é invocada tendo como
parâmetro o tempo de desbloqueio e assim a tarefa bloqueada até o tempo
calculado.


\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathit{vTaskDelay}(\mathit{xTicksToDelay})=\\
	\mathbf{PRE}\\
\quad    	\mathit{xTicksToDelay} \in \mathit{TICK} \land \\ 
\quad    	\mathit{INCLUDE\_vTaskDelay} = 1 \land \\
\quad    	\mathbf{not}(\mathit{TICK\_INCREMENT}(\mathit{tickCount},
			\mathit{xTicksToDelay})=0)\\ 
\mathbf{THEN}\\
\quad    \mathit{DelayTask} (\mathit{TICK\_INCREMENT} (\mathit{tickCount},
													\mathit{xTicksToDelay}))\\ 
\mathbf{END};
\end{array}
\end{array}
$$
\end{small}
\caption{Modelagem da operação $\mathit{vTaskDelay}$}
\label{fig:vTaskDelay}
\end{figure}

\subsubsection* {Utilidades de tarefa} 

O grupo de utilidades de tarefa é formado por funcionalidades bastante simples,
pois elas apenas retornam informações importantes a respeito do estado do kernel.
Uma dessas funcionalidades é a $\mathit{xTaskGetCurrentTaskHandle}$, que retorna
uma referência para a tarefa em execução. A especificação dessa funcionalidade
pode ser vista na figura \ref{fig:xTaskGetCurrentTaskHandle}, na qual a função
apenas realiza uma chamada ao método $\mathit{GetCurrent}$ para obter a tarefa em
execução e passar como retorno da função.
  
\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathit{cTask} \longleftarrow \mathit{xTaskGetCurrentTaskHandle}= \\
	\mathbf{PRE}\\
\quad    	\mathit{INCLUDE\_xTaskGetCurrentTaskHandle} = 1\\
	\mathbf{THEN}\\
\quad    	\mathit{cTask} \gets \mathit{GetCurrent}\\

 
\mathbf{END};
\end{array}
\end{array}
$$
\end{small}
\caption{Modelagem da operação $\mathit{xTaskGetCurrentTaskHandle}$}
\label{fig:xTaskGetCurrentTaskHandle}
\end{figure}  
  
\subsubsection* {Controle do kernel}
No grupo controle do kernel existem várias funcionalidades importantes. Uma
dessas é a $\mathit{vTaskStartSchedule}$ que é responsável pela inicialização
do escalonador e pela criação da tarefa ociosa. Essa função comporta-se como
demonstra a figura \ref{fig:vTaskStartSchedule}. Nela, o escalonador pode
ou não ser inicializado. Caso o escalonador seja inicializado, primeiramente a
operação $\mathit{StartScheduler}$ é chamada, para que a tarefa ociosa seja
criada e, em seguida, o estado do escalonador, armazenado pela variável
$\mathit{scheduler}$, é alterado para executando. E caso o escalonador não
possa ser inicializado, nenhum estado da máquina é alterado.

\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathit{vTaskStartScheduler} =\\ 
\mathbf{PRE}\\
\quad \mathit{scheduler} = \mathit{taskSCHEDULER\_NOT\_STARTED} \land \\
\quad \mathit{running} = \mathbf{TASK\_NULL} \land \\
\quad \mathit{blocked} = \emptyset \land \\ 
\quad \mathit{suspended} = \emptyset \land \\ 
\quad \mathit{ready} = \emptyset\\  	
\mathbf{THEN}\\
\quad \mathbf{CHOICE}\\
\quad\quad \mathit{StartScheduler} \parallel\\
\quad\quad \mathit{scheduler}:=\mathbf{taskSCHEDULER\_RUNNING}\\
\quad \mathbf{OR}\\
 \quad\quad \mathit{skip}\\
\quad \mathbf{END}\\
\mathbf{END};
 
\end{array}
\end{array}
$$
\end{small}
\caption{Modelagem da operação $\mathit{vTaskStartSchedule}$}
\label{fig:vTaskStartSchedule}
\end{figure}




\subsection{Fila de Mensagem}
\subsubsection{Conceito}
A maquina responsável pelo conceito de fila de mensagens e a
$\mathbf{QUEUE\_CORE}$. Nela, uma fila de mensagem é especificada como sendo um
conjunto de item, um conjunto de tarefas que aguardam para enviar uma mesagem
para a fila e um conjunto de tarefas que aguardam para receber uma mensagem da
fila. As demais características da fila de mensagens (ver sessão
\ref{subsec:fmensagem}) serão modeladas em futuros refinamento.

A figura \ref{fig:queue-modelling} demonstra como é feita a especificação do
conceito de fila de mensagens. Inicialmente são declarados os conjuntos abstratos
$\mathit{QUEUE}$ e $\mathit{ITEM}$, que simbolizam, respectivamente, todas as
filas e itens que podem ser gerenciados pelo FreeRTOS. Em seguida, as variáveis
$\mathit{queues}$ é criadas para armazenar todas as filas de mensagens do
FreeRTOS. E por fim, são criados os estados $\mathit{queue\_items}$,
$ \mathit{queue\_sending}$ e $\mathit{queue\_receiving}$, reponsáveis por ligar
uma fila de mensagens a um conjunto de itens, a um conjunto de tarefas que
esparam para enviar uma mensagem para a fila e a um conjunto de tarefa que
aguardam para ler uma mensagem da fila.

Entranto, para a completa especificação do conceito de fila de mensagens, resta a
restrições de que toda fila de mensagens deve possuir um conjunto de itens e dois
conjuntos de tarefa que aguardam enviar e receber uma mensagem da fila. Essa
restrição pode ser observada no $\mathbf{INVARIANT}$ da máquina através das
declarações $\mathit{queues} = \mathbf{dom}(\mathit{queue\_items})$,
$\mathit{queues} = \mathbf{dom}(\mathit{queue\_receiving}) $ e $\mathit{queues} =
\mathbf{dom}(\mathit{queue\_sending})$, completando assim a especificação do
conceito de fila de mensagens.



\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathbf{SETS} \\
\quad   \mathit{QUEUE};\\
\quad   \mathit{ITEM};\\
\quad   \ldots \\
    		
\mathbf{VARIABLES}\\
\quad   \mathit{queues},\\
\quad\quad   \mathit{queue\_items},\\
\quad\quad   \mathit{queue\_receiving},\\
\quad\quad	 \mathit{queue\_sending}
\end{array}

\begin{array}[t]{l}

\mathbf{INVARIANTS}\\

\quad \mathit{queues} \in \mathbf{POW}(\mathit{QUEUE}) \land \\
\quad\quad \mathit{queue\_items} \in \mathit{QUEUE} \rightarrow\mkern-22mu+
\quad\quad \mathbf{POW}(\mathit{ITEM})\land \\

\quad\quad \mathit{queue\_receiving} \in \mathit{QUEUE} \rightarrow\mkern-22mu+
\quad\quad \mathbf{POW}(\mathit{TASK}) \land \\ 

\quad\quad \mathit{queue\_sending} \in \mathit{QUEUE}\rightarrow\mkern-22mu+
\quad\quad \mathbf{POW}(\mathit{TASK}) \land \\\\
    		
\quad \mathit{queues} = \mathbf{dom}(\mathit{queue\_items}) \land \\
\quad \mathit{queues} = \mathbf{dom}(\mathit{queue\_receiving}) \land \\
\quad \mathit{queues} = \mathbf{dom}(\mathit{queue\_sending})

\end{array}

\end{array}
$$
\end{small}
\caption{Modelagem do conceito fila de mensagem}
\label{fig:queue-modelling}
\end{figure}

\subsubsection{Operações Básicas}
Depois da modelagem do conceito de fila de mensagens, ainda ná máquina
$\mathbf{QUEUE\_CORE}$, foram criadas várias operações que manipulam as as
características de uma fila de mensagens e servem como base para a especificação
das funcionalidades que utilizam-se desse conceito. Entre essas operações
merece destaque a $\mathit{sendItem}$, que é responsável por enviar uma
mensagem para a fila e é especifica como demonstra a figura \ref{fig:sendItem}.

Nessa operação são passados como argumento a fila que receberá a mensagem, o
item, ou mensagem, que será colocada na fila e uma tarefa que está no conjunto de
tarefa que aguardam por uma mensagem da fila. Tendo esses parâmentros em mãos, o
funcionamento da operação resume-se apenas em a colocar a mensagem no conjunto
de mensagens da fila e retirar a tarefa do conjunto de tarefa que aguardavam por
uma mensagem da fila, pois a mensagem chegou e a tarefa não necessita mais
aguardar por ela.



\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathit{sendItem}( \mathit{pxQueue}, \mathit{pxItem}
					\mathit{task},\mathit{copy\_position}) = \\
\mathbf{PRE}\\
\quad  \mathit{pxQueue} \in \mathit{queues} \land \\ 
\quad  \mathit{pxItem} \in \mathit{ITEM} \land \\ 
\quad  \mathit{task}\in \mathit{TASK} \land \\ 
\quad  \mathit{copy\_position} \in \mathit{COPY\_POSITION} \land\\    
\quad  \mathit{task} \in \mathit{queue\_receiving}(\mathit{pxQueue})\\
\mathbf{THEN}\\
\quad  \mathit{queue\_items}(\mathit{pxQueue}):=
				\mathit{queue\_items}(\mathit{pxQueue}) \cup \{\mathit{pxItem}\}\parallel\\
\quad  \mathit{queue\_receiving}(\mathit{pxQueue}) :=
				\mathit{queue\_receiving}(\mathit{pxQueue}) - \{\mathit{task}\} \\
\mathbf{END};
\end{array}
\end{array}
$$
\end{small}
\caption{Modelagem da operação $\mathit{sendItem}$}
\label{fig:sendItem}
\end{figure}

\subsubsection{Operações Intermediárias}
Durante a modelagem das funcionalidades que utilizam-se do conceito de fila de
mensagem, percebeu-se que varios comportamentos se repetem entre essas
funcionalidades. Assim para uma maior modularização e controle, antes da
especificação das funcionalidades, foi criada uma máquina, denominada
$\mathbf{QUEUE\_BASIC}$ responsável por especificar comportamentos que se
repetem entre as funcionalidades que utilizam-se do conceito de fila de
mensagens.

Os comportamentos citados no paragrafo anterior foram agrupados em duas
operações: $\mathit{xQueueGenericSend}$, responsável por enviar um item para
uma fila de mensagem, bloquear a tarefa remetente, caso a fila esteja cheia, 
desbloquar uma tarefa que aguarda por uma mensagem da fila, caso a mensagem
seja enviada com sucesso, e retorna uma mesangem de erro, caso a mensagem não
possa ser enviada; e $\mathit{xQueueGenericReceive}$, que é responsável por
receber um item da fila, bloquear a tarefa receptora, caso não haja nenhum item
na fila, desbloquear uma tarefa que aguarda para enviar um item para fila, caso
a mensagem seja retirada da fila com sucesso, e retornar uma mensagem de erro,
no caso de uma mensagem não poder ser recebida. 

Na figura \ref{fig:xQueueGenericSend} tem-se a especificação dos três
comportamentos possíveis para a operação $\mathit{xQueueGenericReceive}$. No
primeiro comportamento, inicialmente é declarada uma tarefa que pertence ao
conjunto de tarefas que aguardam por uma mensagem da fila. Em seguida, essa
tarefa é passa como argumento, junto com a mensagem, $\mathit{pvItemToQueue}$,
para o método $\mathit{sendItem}$ que envia a mensagem para a fila e retira a
tarefa passada do conjunto de tarefas que aguardam por uma mensagem. No segundo
comportamento, através do método $\mathit{insertTaskWaitingToSend}$, a tarefa
corrente é adicionada no conjunto de tarefas que aguardam para enviar uma
mensagem para a fila e após ela é bloqueada pelo método $\mathit{DelayTask}$.
Por fim, no último comportamente, apenas uma messagem de erro é retornada,
informando que a mensagem não pode ser enviada e nem a tarefa foi colocada na
conjunto de tarefas que aguardam para enviar uma mensagem.


\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}   	
\ldots\\
\quad \mathbf{ANY}\\
\quad \quad \mathit{task}\\
\quad \mathbf{WHERE}\\
\quad \quad \mathit{task} \in \mathit{TASK} \land \\ 
\quad \quad \mathit{task}\in \mathit{blocked} \land \\
\quad  \quad \mathit{task}\in \mathit{queue_receiving}(\mathit{pxQueue})\\ 
\quad \mathbf{THEN}\\
\quad \quad \mathit{sendItem}(\mathit{pxQueue}
			,\mathit{pvItemToQueue},\mathit{task,copy_position})\parallel\\
\quad \quad \mathit{Unblock}(task)\parallel\\ 
\quad \quad \mathit{return}:=\mathit{pdPASS}\\
\quad \mathbf{END}\\        	
\ldots\\
\quad
\mathit{insertTaskWaitingToSend}(\mathit{pxQueue},\mathit{running})\parallel \\
\quad \mathit{DelayTask}(\mathit{xTicksToWait})\parallel\\
\quad \mathit{return}:=\mathit{pdTRUE}\\
\ldots\\
\quad \mathit{return}:=\mathit{errQUEUE_FULL}\\
\ldots
\end{array}
\end{array}
$$
\end{small}
\caption{Comportamentos da operação $\mathit{xQueueGenericReceive}$}
\label{fig:xQueueGenericSend}
\end{figure}

\subsubsection{Funcionalidades}
Após a criação das operações intermediárias, a máquina $\mathbf{QUEUE}$ foi
criada para especificar as funcionalidades que utilizam o conceito de fila de
mensagens. Nela estão presentens as funcionalidades do grupo gerenciamento de
fila de mensagens, sendo que uma das principais funcinalidades desse grupo é a
operação $\mathit{xQueueSend}$ responsável por enviar uma mensagem para uma
fila. A especificação competa dessa funcionalidade pode ser vista na figura
\ref{fig:xQueueSend}.




\subsubsection{Funcionalidades das filas de mensagens}
Para especificar as funcionalidades das fila de mensagem, que são as operações do
grupo gerênciamento de fila (sessão \ref{subsec:fmanagemente}), forma criadas
três máquinas ($\mathbf{QUEUE\_CORE}$, $\mathbf{QUEUE\_BASIC}$ e
$\mathbf{QUEUE}$ ). Na primeira máquina são especificados o conceito de tarefa e algumas
funcionalidades básica necessárias na modelagem da operação da API de
gerênciamento de fila. A segunda máquina trata de um aprimoramento, onde os
comportamentos repetitivos a maioria das funcionalidades do grupo são são
especificados em duas operações, assim as operações dessa máquina pode ser vista
como uma façada\footnote{Padrão de projeto que \ldots} que une as operações
básicas da máquina anterior em duas operações mais complexa que serão usadas na
especificação das funcionalidades. Por último, na máquina $\mathbf{QUEUE}$ é onde
são especificadas as funcionalidades em si.

\subsubsection*{QUEUE\_CORE}
A máquina $\mathbf{QUEUE\_CORE}$ é formada pelas as seguintes operações:
\begin{itemize}
  \item {\textbf{xQueueCreate} - Cria uma nova fila de mensagem retornando uma
  referência para a mesma. Se a fila não poder ser criada uma constante de
  tarefa nula $\mathbf{QUEUE\_NULL}$} é retornada no lugar da fila criada.
  \item {\textbf{sendItem} - Adiciona um novo item a uma fila e retira da fila 
  retirando da mesma uma tarefa que está na lista de espera pela chegada de um 
  item }
  \item {\textbf{receivedItem} - Remove, ou não um item de uma fila. Caso o
  item seja removido, a função retorna uma referencia para o item em
  questão, remove o item da fila e caso exista, retira uma tarefa do conjunto
  de tarefas que estão esperando por um lugar na fila }
  \item {\textbf{insertTaskWaitingToSend} - Insere uma tarefa no conjunto de
  tarefas que estão aguardando por um lugar na fila para enviar um item}
  \item {\textbf{insertTaskWaitingToRecived} - Insere uma tarefa no conjunto de
  tarefas que estão esperando pela chegada de um item na fila }
  \item {\textbf{removeFromEventListQueue} - Remove uma tarefa de todas as
  listas de eventos de todas as filas gerenciadas pelo FreeRTOS}
\end{itemize} 
\subsubsection*{$\mathbf{QUEUE\_BASIC}$}
Como dito anteriormenta, a máquina $\mathbf{QUEUE\_BASIC}$ é formada por duas
operações, $\mathit{xQueueGenericSend}$ e $\mathit{xQueueGenericReceive}$.
Essas possuem o funcionamento bastante parecido no qual é alterado apenas o
contexto de utilização das duas. Enquanto a primeira serve para enviar um intem
para uma fila, a segunda serve para retirar. Assim, a principal diferença entre
as operações é o uso das funções básicas $\mathit{SendItem}$, presente na
primeira operação e $\mathit{ReciveItem}$ presente na segunda operação. Com
isso, iremos demonstrar as especificação da operação
$\mathit{xQueueGenericSend}$.

A operação $\mathit{xQueueGenericSend}$ possui três opções de comportamento:
Enviar um item para uma fila de mensagem e caso exista, debloquear uma tarefa
no conjunto de tarefas que esperam pera chegado de um item na fila; bloquear a
tarefa atual, colocando-na na lista de tarefas que aguardam para enviar um item
para a fila; e retornar o erro de que a operação não pode ser realizada com
sucesso.

O primeiro comportamento, enviar um item para a fila de mensagem e desbloquear
uma tarefa da fila de eventos, é modelado como demonstra a figura
\ref{fig:xQueueGenericSend-1}. Nela primeiro pega-se uma tarefa contida no
conjunto $\mathit{queue\_receiving}$ da fila em questão. Em seguida, o item e a
tarefa escolhida são enviados para a operação $\mathit{sendItem}$ para que o item
possam ser enviados e a tarefa possa ser retirada do conjunto
$\mathit{queue\_receiving}$. Por ultimo, a tarefa é desbloquead com a chamada ao
método $\mathit{Unblock}$ (sessão \ref{subsubsec:tutilities}).


\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\ldots\\
\mathbf{ANY}\\
\quad  \mathit{task}\\
\mathbf{WHERE} \\
\quad  \mathit{task}\in \mathit{TASK} \land \\ 
\quad  \mathit{task}\in\mathit{blocked} \land \\ 
\quad  \mathit{task} \in \mathit{queue\_receiving}(\mathit{pxQueue})\\ 		
\mathbf{THEN}\\
\quad \mathit{sendItem}(\mathit{pxQueue},
		\mathit{pvItemToQueue},\mathit{task},\mathit{copy\_position}) \parallel\\ 
\quad\mathit{Unblock}(\mathit{task})\parallel\\
\quad\mathit{return}:=\mathit{pdPASS}\\
\mathbf{END}\\
\ldots
 
\end{array}
\end{array}
$$
\end{small}
\caption{Modelagem da operação $\mathit{xQueueGenericSend}$}
\label{fig:xQueueGenericSend-1}
\end{figure}


Os comportamentos de bloquear a tarefa atual e retorno de erro são especificado
de acordo com a figura \ref{fig:xQueueGenericSend-2}. Através dela pode-se ver
que para bloquear a tarefa utual é feita apenas a chamada ao método
$\mathit{DelayTask}$. E para informar que a operação não foi realizada com
sucesso a operação apenas retorna a constante $\mathbf{errQUEUE\_FULL}$,
indicando um erro de fila cheia

 
\begin{figure}[!h]
\begin{small}


$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
\ldots\\
\mathit{insertTaskWaitingToSend}(\mathit{pxQueue},\mathit{running})\parallel\\ 
\mathit{DelayTask}(\mathit{xTicksToWait})\parallel\\
\mathit{return}:=\mathbf{pdTRUE}\\
\ldots\\
\mathit{return}:=\mathbf{errQUEUE\_FULL}\\	
\ldots\\
\end{array}
\end{array}
$$
\end{small}
\caption{Continuação da modelagem da operação $\mathit{xQueueGenericSend}$}
\label{fig:xQueueGenericSend-2}
\end{figure}



	
\section{Considerações finais}
\label{sec:consideracoes} 
[Falar sobre as dificuldades encontradas na modelagem, como também a
inviabilidadede modelar um sistema de natureza concorrente no formalismo B]


\section{Trabalhos Futuros}
[Falar sobre o que pretende-se fazer nos futuros refinamentos. Como
especificar a característica de prioridade para o conceito de tarefa]



\bibliography{UFRN-DIMAp-2006-100-RT}



\end{document}

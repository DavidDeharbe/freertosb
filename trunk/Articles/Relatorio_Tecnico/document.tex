% Exemplo de relatório técnico e outros documentos do DIMAp-UFRN
% com texto em português formatado com LaTeX

\documentclass[capa]{rt-dimap}
% Opções da classe rt-dimap
%   [capa]  -> Gerar a capa colorida do relatório técnico
%   [plain] -> Usar o estilo "plain" de citação bibliográfica
%\newcommand{\FreeRTOS}{\operatorname{\textit{FreeRTOS }}}

%% Keywords for the B method
\newcommand{\MACHINE}{\operatorname{\mathbf{MACHINE}}}
\newcommand{\REFINEMENT}{\operatorname{\mathbf{REFINEMENT}}}
\newcommand{\IMPLEMENTATION}{\operatorname{\mathbf{IMPLEMENTATION}}}
\newcommand{\REFINES}{\operatorname{\mathbf{REFINES}}}
\newcommand{\SEES}{\operatorname{\mathbf{SEES}}}
\newcommand{\IMPORTS}{\operatorname{\mathbf{IMPORTS}}}
\newcommand{\SETS}{\operatorname{\mathbf{SETS}}}
\newcommand{\CONSTANTS}{\operatorname{\mathbf{CONSTANTS}}}
\newcommand{\PROPERTIES}{\operatorname{\mathbf{PROPERTIES}}}
\newcommand{\VARIABLES}{\operatorname{\mathbf{VARIABLES}}}
\newcommand{\INVARIANT}{\operatorname{\mathbf{INVARIANT}}}
\newcommand{\INITIALISATION}{\operatorname{\mathbf{INITIALISATION}}}
\newcommand{\OPERATIONS}{\operatorname{\mathbf{OPERATIONS}}}
\newcommand{\BEGIN}{\operatorname{\mathbf{BEGIN}}}
\newcommand{\END}{\operatorname{\mathbf{END}}}
\newcommand{\PRE}{\operatorname{\mathbf{PRE}}}
\newcommand{\IF}{\operatorname{\mathbf{IF}}}
\newcommand{\THEN}{\operatorname{\mathbf{THEN}}}
\newcommand{\ELSE}{\operatorname{\mathbf{ELSE}}}
\newcommand{\ELSIF}{\operatorname{\mathbf{ELSIF}}}
\newcommand{\ANY}{\operatorname{\mathbf{ANY}}}
\newcommand{\WHERE}{\operatorname{\mathbf{WHERE}}}
\newcommand{\CASE}{\operatorname{\mathbf{CASE}}}
\newcommand{\OF}{\operatorname{\mathbf{OF}}}
\newcommand{\EITHER}{\operatorname{\mathbf{EITHER}}}
\newcommand{\OR}{\operatorname{\mathbf{OR}}}
\newcommand{\WHILE}{\operatorname{\mathbf{WHILE}}}
\newcommand{\DO}{\operatorname{\mathbf{DO}}}
\newcommand{\VARIANT}{\operatorname{\mathbf{VARIANT}}}

%% Commonly used math entities
\newcommand{\pow}{\operatorname{\mathbb{P}}}
\newcommand{\dom}{\operatorname{\mbox{dom}}}
\newcommand{\nat}{\operatorname{\mathbb{N}}}
\newcommand{\pfun}{\operatorname{\rightarrow\mkern-22mu+}}

\begin{document}
%---------------------------------------------------------- PAGINA DE CAPA %
% Número do relatório (para reserva, consulte "regivan@dimap.ufrn.br.br").
\TRNumber{000}

% O tipo do documento: Relatório Técnico, Relatório de Disciplina, etc.
%   \TRType{Technical Report}
%   \TRTipo{Relatório Técnico}

%\TRType{Final Year Project Proposal}
%\TRTipo{Prop. de Projeto F. de Curso}

% \TRType{Lecture Report}
% \TRTipo{Relatório de Disciplina}


% Data de publição (para a capa)
\TRYear{2009}  
\TRMonth{02} % Numérico, 01-12

% Lista de autores para capa (sem afiliações).
\TRAuthor{Stephenson Galvão, David Déharbe}

% Título para a capa (use \\ para forcar quebras de linha).
\TRTitle{Modelagem em B do \\Sistema de Tempo Real FreeRTOS}

\TRMakeCover
%---------------------------------------------------------- PAGINA DE CAPA %


%%---------------------------------------------------------- TITULO E AUTOR DA PAG 1 %
% TITULO e NOMES DOS AUTORES, completos, para a pagina 1.
% Use "\\" para quebrar linhas, "\and" para separar autores.
%
\title{\bf Modelagem em B do \\Sistema de Tempo Real FreeRTOS}

\author{Stephenson Galvão \\ {\small stepgalvao@consiste.ufrn.br}  
	 \and David Déharbe \\ {\small deharbe@consiste.ufrn.br} }
    %\thanks{Aluno do Programa de Pós-graduação em Sistemas e Computação,  UFRN}
\date{}

\maketitle
%---------------------------------------------------------- TITULO E AUTOR DA PAG 1 %


%---------------------------------------------------------- CABECALHO DAS PAGINAS %
% Nomes de autores ABREVIADOS e título ABREVIADO, para cabecalhos em cada página.
\markboth{\small Galvão, S.S.L.}{\small Modelagem do FreeRTOS}
\pagestyle{myheadings}
%---------------------------------------------------------- CABECALHO DAS PAGINAS %


%----------------------------------------------------------ABSTRACT %
\begin{abstract}
This work aim start the resolve of the challenge, make for Jim,
of specific formally the operation real time system FreeRTOS. For
this, used the b method , a abstract modelling was create with some of majory
concepts and functionality majory concepts and functionality of this system.
This away, the present modelling can be used both to start the challenger of
Jim and information base for others works that intent specific formally the
FreeRTOS.
\end{abstract}

\begin{keywords}
Operation real time system, FreeRTOS, Challenge, Method B
\end{keywords}
%----------------------------------------------------------ABSTRACT %

% ----------------------------------------------------------RESUMO %
\begin{resumo} 

Este trabalho tem como principal objetivo iniciar a resolução do desafio,
proposto por Jim, de especificar formalmente um sistema operacional de tempo
real FreeRTOS, que devido a sua simplicidade, portabilidade e
eficiência é largemete utilizado em vários tipos de aplicações. Para cumprir
esse objetivo, foi criada, utilizando-se o método B, uma modelagem abstrata
desse sistema, na qual alguns dos seus principais conceitos e funcionalidades
foram especificados sendo os demais tratados em futuros refinamentos da
modelagem. Assim, a modelagem aqui desenvolvida além de servir como 
esforço inicial para a resolução do desafio de Jim, serve também como
base de informação para futuros trabalhos que pretendem especificar formalmente
o FreeRTOS.
\end{resumo}

\begin{palavras-chave}
Sistema operacional de tempo real, FreeRTOS, Desafio, Método B 
\end{palavras-chave}
%----------------------------------------------------------RESUMO %


\section{Introdução}
\label{sec:intr}


Sistemas de Tempo Real (STR) são sistemas que tem como principal característica
um rigoroso tempo de resposta aos eventos externos. Devido a isso, eles são bastante
utilizados, pelas industrias, em aplicações críticas que possuem o tempo de
resposta como um fator crucial. O monitoramento de paciente em hospitais, o controle de
processos industriais e o controle de veículos (aeronaves, trens e automóveis)
são apenas alguns exemplos de aplicações dos sistemas de tempo real.

Em razão dessa  grande importância e utilização dos STR, foi proposto, por Jim,
em \cite{jim:sbmf}, como um dos grandes desafios da ciência da computação, a
especificação formal de um sistema operacional de tempo real, denominado
FreeRTOS. Para assim, proporcionar ao mesmo a segurança, confiabilidade e
coerência que uma especificação formal oferece, tornando-no mais fidedigno

O FreeRTOS é um sistema operacional de tempo real bastante simples. Aprova disso
está em seu código fonte, que é aberto e composto aproximadamente 2.242 linhas de
código, número bastante pequeno para um sistema operacional. Além disso, ele é
capaz de trabalhar em ambientes com quantidade de recursos limitada, como os
microprocessadores, sendo, oficialmente\footnote{Existem também portas do FreeRTOS
não oficias, disponibilizada pelos usuários, para várias outras arquiteturas
diferentes}, portável para 17 arquiteturas de microprocessadores diferentes,
entre ela as \textit{PIC}, \textit{ARM}, \textit{Zilog 80} e \textit{Cygnal
8051}, arquiteturas bastante usada pelas industrias de microeletrônica
\cite{freertos}.

Seguindo esse contexto, o presente relatório tem como principal objetivo
descrever uma modelagem inicial em B \cite{Schn:01}, do sistema de tempo real
FreeRTOS e, com isso, iniciar a resolução do desafio proposto pelo Jim. Entretanto, por trata-se de uma
especificação inicial, alguns conceitos desse sistema de tempo real foram
brevemente abstraídos da modelagem, sendo que os mesmo serão tratados em futuros
refinamento. 
%Assim, primordialmente foram especificados, em um alto nível de
%abstração, somente os conceitos e funcionalidades de tarefas e filas de
%mensagens, dando ênfase principalemente à caracteristica de estado de um
%tarefa e suas trocas.

Para cumprir o seu objetivo, esse relatório foi divido da seguinte forma:
primeiramente tem-se uma introdução ao FreeRTOS, demonstrado as suas principais
características e conceitos fundamentais; em seguida, é apresentado o plano de
modelagem seguido na realização da especificação, nele estão presente, junto com
suas descrições, as funcionalidades e os conceitos das API escolhidos para serem
desenvolvidos nessa modelagem inicial; após isso, na sessão \ref{sec:Modelling},
é demonstrado como foi feita a modelagem do FreeRTOS, suas máquinas com seus
estados e operações; e para encerrar, tem-se as considerações finais, onde
estão as conclusões do trabalho, e os trabalhos futuros, falando como será
feita a continuação desta modelagem.




%Para ser aceito para publicação, um Relatório Técnico deve ser avalisado por,
%pelo menos um professor do INF. No caso de um professor ser autor ou co-autor
%do relatório, poderá solicitar que um outro professor faça a avaliação do
%mesmo. Neste caso, o nome deste professor avaliador deverá constar na seção de
%agradecimentos (Seção \ref{sec:agrad}).



\section{FreeRTOS}
\label{sec:freertos}
% [Uma introdução ao FreeRTOS demonstrando as suas funcionalidades (casos no qual
% o FreeRTOS é utilizado), características(portabilidade, pouco código,ect) e
% conceitos(tarefa,co-rotina, fila de mensagem, mutex, ect)]
 
O \textit{FreeRTOS} é um sistemas de tempo real projetado para ser pequeno,
simples e fácil de usar. O seu código fonte é aberto e possui aproximadamente
2.242 linhas de código, que estão basicamente distribuídas em três arquivos
(task.c, queue.c e list.c), nos quais são implementados seus principais conceitos
e funcionalidades. Além disso, outra característica importante desse STR é a sua
portabilidade, sendo oficialmente portável para 17 arquiteturas diferentes, entre
elas a PIC, ARM, Zilog Z80 e PC, bastantes usadas pelas industrias de
microeletrônica.

O seu \textit{kernel}, além de ser multitarefa, suporta três tipo diferentes de
configurações: preemptivo, cooperativo e híbrido. No tipo preemptivo, a tarefa
em execução pode ser interrompida a qualquer momento pelo escalonador, sendo em
seguida substituída por outra tarefa. Diferentemente, no tipo cooperativo, o
processo em execução é quem decide o momento de sua pausa, seguida da sua
substituição. E por fim, no tipo híbrido, o escalonador funciona hora como
preemptivo e hora como cooperativo.

Os conceitos fundamentais implementado pelo FreeRTOS e presente na maioria dos
sistemas de tempo real são tarefa, co-rotina, fila de mensagem, semáforo e mutex.
Eles, junto com suas funcionalidades, formam todo o núcleo do FreeRTOS, restando
para o usuário apenas a utilização desses conceitos para a criação de novos
sistemas. A seguir, detalharemos as características e utilização de cada 
conceito fundamental.

\subsection{Tarefa}
\label{subsec:tarefa}
Tarefas são unidades de trabalho independentes que compõem um sistema
multitarefas. No FreeRTOS, uma tarefa é composta por: um pilha de contexto, que
serve para armazenar o ambiente de execução (estados dos registradores)  no
momento que uma tarefa é interrompida; uma prioridade que serve para indicar a
importância da tarefa para o sistema; um estado que demonstra a atual
situação da tarefa; e uma função que é executado quando a tarefa assume o
controle do processado \cite{Li:2003}.

Os estados que uma tarefa pode assumir no FreeRTOS são: executando, pronto,
bloqueado e suspenso. O estado ``executando'' informa que a tarefa está em
execução, ou seja, possui, atualmente, o controle do processador. Somente uma
tarefa pode possuir o estado executando em um determinado momento. O estado
``pronto'' informa que a tarefa está pronta para entrar em execução, aguardando
apenas assumir o controle do processador. No estado ``bloqueado'' a tarefa
encontra-se bloqueada a espera de algum evento necessário para continuar a sua
execução. E por último, no estado ``suspenso'', a tarefa foi suspensa pelo
escalonador através da chamada ao método vTaskSuspend(), disponível na API do
FreeRTOS. O gráfico completo de transição de estados que uma tarefa pode sofre é
demonstrado na figura \ref{fig:tkstates}.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{tkstate.eps}
\caption{Gráfico de transição de estados das tarefas do FreeRTOS}
\label{fig:tkstates}
\end{figure}

A prioridade de uma tarefa pode variar de 0 (zero)até uma constante de prioridade
máxima, definida pelo o usuário. No FreeRTOS, as prioridades servem para indicar
a importância de uma tarefa para o sistema. Elas são usadas principalmente pela
política de escalonamento entre tarefas. Nessa política, as tarefas de maiores
prioridades, tem preferência sobre as tarefas de menores prioridades do mesmo
estado. Assim, para escolher a tarefa que irá entrar em execução, o escalonador percorre
a lista de tarefas de estado ``pronto'' selecionando aquela de maior
prioridade. Um exemplo do  funcionamento do escalonador pode ser visto na na
figura \ref{fig:scheduler}, na qual as tarefas de menores prioridades são
interrompidas por tarefas de maiores prioridades quando estas assumem o estado
``pronto''. Outro fator importante no funcionamento de escalonador que vale apena
ressaltar, é que tarefas de mesma prioridade dividem o tempo de execução entre si.
Com isso, se houver duas tarefas prontas e com a prioridade máxima, elas irão
dividir tempo de processamento em frações iguais entre si.


\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{scheduler.eps}
\caption{Funcionamento do escalonador do FreeRTOS}
\label{fig:scheduler}
\end{figure}


  
\subsection{Co-Rotina}
\label{subsec:crotina}
As co-rotinas são similares às tarefas, também possuem prioridade, estados e uma
função que é executada no momento em que a co-rotina assume o controle do
escalonador. Entretanto, existem algumas diferenças importantes entre tarefas e
co-rotinas, sendo a principal delas, a ausência da pilha de contexto. Co-rotinas
não possuem pilha de contexto e, consequentemente, não possuem contexto próprio, ou
seja, os valores armazenados nos registradores por uma co-rotinas, não são
guardados no momento em que ela interrompe a sua execução. Assim, uma co-rotina
pode armazenar o valor três em um registrador, antes de interrompe-se, e, quando
ela retorna a sua execução, o valor dessa variável pode ou não ser o mesmo, pois
outra tarefa pode ter entrado em execução e alterado o valor do registrado.

Outra diferença importante entre co-rotinas e tarefas está na quantidade de
estado. As co-rotinas só possuem os estado ``executando'', ``pronto'' e
``bloqueado'' diferente das tarefas que, além desses três estados, possuem o
estado ``suspenso''. Consequentemente, o gráfico de transição de estados de uma
co-rotina também é diferente do gráfico de tarefas, sendo esse demonstrado pela
figura \ref{fig:crstates}

\begin{figure}[!h]
\centering
\includegraphics[scale=0.5]{crstate.eps}
\caption{Gráfico de transição de estados das co-rotinas do FreeRTOS}
\label{fig:crstates}
\end{figure}

As co-rotinas também possuem um gerenciamento diferente do de tarefas. Elas são
escalonadas de forma cooperativa, ou seja, elas são quem decidem o momento da sua
interrupção. Assim, resta para o escalonador apenas a tarefa de decidir qual
co-rotina deve assumir o processador no momento em que a co-rotina em execução
interrompe-se, sendo que a política usada para essa escolha é baseada na
prioridade semelhante a utilizada nas tarefas.


\subsection{Fila de Mensagens}
\label{subsec:fmensagem}
Filas de mensagens são estruturas primitivas de comunicação entre tarefas. Elas
funcionam como um túnel no qual tarefas enviam e recebem mensagem. No FreeRTOS,
as filas de mensagens possuem tamanho fixo, defino pelo tamanho e quantidade de
itens (mensagem) que ela pode armazenados. Para uma tarefa enviar uma mensagem
para uma fila, primeiramente a fila não pode estar cheia, caso contrário, a
tarefa é bloqueada até que seja liberado um lugar na fila. O mesmo 
ocorre quando uma tarefa tenta receber uma mensagem de uma fila, só que,
nesse caso, a fila deve possuir pelo menos uma mensagem, para que essa seja
lida, caso contrário, a tarefa é bloqueada até a chegada de uma mensagem na fila.

No FreeRTOS, é possível definir o tempo máximo que uma tarefa pode ficar
bloqueada esperado por um evento(liberação de espaço ou chega de mensagem) em
uma fila. E no casos em que existem mais de uma tarefa bloqueadas aguardando
por um evento de uma fila, as tarefas de maior prioridade têm preferência sobre
as demais.

\subsection{Semáforos}
Semáforos são mecanismo usados na sincronização entre tarefas. Eles funcionam como
uma chave que libera, ou não, o uso de um determinado recurso. Assim quando uma
tarefa deseja acessar um recurso compartilhado, ela primeiramente deve solicitar
o semáforo do recurso, caso este esteja liberado, a tarefa tem a premiss o de
utilizar o recurso e, em seguida, libera o semáforo, caso contrário, a tarefa é
bloqueada até que o semáforo seja liberado.

No FreeRTOS os semáforo funcionam como uma fila de mensagens com um único item.
Assim, quando a fila estiver vazia, indica que o semáforo está sendo usado e,
quando a fila estiver cheia, indica que o semáforo está liberado. Desse modo, as
tarefas que utilizam uma fila de mensagens como semáforo não estão preocupadas
com o conteúdo da mensagem, mas apenas com o estado da fila, se ela está cheia ou
vazia.


\subsection{Mutex}
Mutex são parecidos com o semáforo. A única diferença entre os dois é que o mutex
implementa o mecanismo de herança de prioridade, o qual impede que uma tarefa de
maior prioridade fique bloqueada a espera de um semáforo ocupado por uma tarefa
de menor prioridade, causando o que chamamos de inversão de prioridade.

Para evitar esse problema, o mecanismo de herança de prioridade, ao perceber que
uma tarefa solicita o semáforo, verifica se a tarefa solicitante possui
prioridade maior que a tarefa com o semáforo. Caso afirmativo, a tarefa que retém
o semáforo tem, momentaneamente, a sua prioridade elevada, para que assim ela
possar realizar a suas funções sem interrupções e, consequentemente, liberar mais
rapidamente o semáforo.

\section{Projeto da Modelagem}
\label{sec:project}

Como demonstrado na sessão anterior, o FreeRTOS possui uma grande quantidade de
conceitos fundamentais. Devido a isso, antes de iniciar-se a sua especificação
foi criado em \cite{project} um projeto de modelagem, no qual alguns dos
seus principais conceitos fundamentais, junto com suas funcionalidades foram
escolhidos para serem modelados inicialmente. Assim, o projeto de modelagem
funcionou como um roteiro para a especificação, dizendo como o por onde começar a
modelagem do FreeRTOS.

Devido a sua grande importância, os conceito fundamentais escolhidos no projeto
de modelagem foram, tarefa (sessão \ref{subsec:tarefa}) e fila de mensagem
(sessão \ref{subsec:fmensagem}), sendo que cada um desses conceito possui uma
enorme quantidade de funcionalidades. Assim, para o melhor entendimento e
gerenciamento, essas funcionalidades foram classificadas em cinco conjuntos
diferentes: criação de tarefa; controle de tarefa; controle do kernel;
utilidades de tarefas e gerenciamento de fila. A seguir, tem-se em detalhe
a composição de cada um desses conjuntos grupo como também a descrição de cada
funcionalidade que os compõem

\subsection{Criação de tarefa}
\label{subsec:tcreation}

No conjunto Criação de tarefas, estão presente algumas funcionalidades
responsáveis pela criação, exclusão e referenciamento de uma tarefa. Ele é
formado pelas seguintes funções:

\begin{itemize}
  \item \textbf{xTaskCreate} - Cria uma nova tarefa que será gerenciada pelo
  FreeRTOS, retornando uma referência para a tarefa criada. Caso a tarefa não
  possa ser criada, uma referência nula é retornada no lugar da tarefa criada
  
  \item \textbf{xTaskDelete} - Remove uma tarefa do FreeRTOS. Entretanto, os
  espaço alocado pela tarefa só será liberando pela a tarefa ociosa
  \footnote{Tarefa executada quando o processador estar ocioso (sem tarefas
  para entrar em execução). Ela é responsável pela liberação da memória
  alocada por determinadas estruturas (Tarefa, Fila de Mensagem, Co-rotina, etc)
  no FreeRTOS}.
  
  \item \textbf{xTaskHadle} - Estrutura de referência a uma tarefa
\end{itemize}

\subsection{Controle de tarefa}
\label{subsec:tcontrol}
O grupo de Controle de tarefa é responsável pelo controle e gerenciamento das
tarefas presentes no FreeRTOS. Desse modo, as funcionalidades que forma esse
grupo são:

\begin{itemize}
  \item \textbf{uxTaskPriorityGet} - Informa a prioridade de uma tarefa
  
  \item \textbf{vTaskSuspend} - Coloca uma tarefa no estado ``suspenso''
  
  \item \textbf{vTaskResume}- Retorna uma tarefa suspensa colocando-a no estado
  pronto
  
  \item \textbf{vTaskPrioritySet} - Altera a prioridade de uma tarefa
  
  % \NOTE - Pedir para o David ler essa parte
  \item \textbf{vTaskDelay} - Bloqueia uma tarefa por uma determinada
  quantidade de tempo. Nesse método, o tempo de desbloqueio de uma tarefa é
  calculado com base no tempo de chamada ao mesmo, o que torna-no não
  recomendável para a criação de tarefas cíclicas, pois outras tarefas e
  interrupções podem influenciar no tempo em que o método será chamado
  novamente.
  
  \item \textbf{vTaskDelayUntil} - Esse método, assim como o
  \textit{vTaskDelay}, coloca uma tarefa no estado bloqueado por uma determinada
  quantidade de tempo. Entretanto, diferentemente do método passado, o tempo de
  desbloqueio de uma tarefa é calculado com base no instante do último
  desbloqueio mesma. Assim é garantido que tempo entre o bloqueio e o
  desbloqueio de uma tarefa seja sempre o mesmo, o que torna esse método
  recomendado para a criação de tarefas cíclicas.
  
\end{itemize}

\subsection{Controle do kernel}
\label{subsec:kcontrol}
As funcionalidades presentes no conjunto Controle do kernel são responsáveis por
gerenciar, iniciar e finalizar as atividades do kernel. Nesse grupo estão
presentes as seguintes operações:

\begin{itemize}
  \item \textbf{vTaskStartScheduler} - Esse método primeiramente cria a tarefa
  ociosa e, em seguida, inicia as atividades do escalonador, colocando-o no
  estado ``executando''\footnote{O escalonador do FreeRTOS possui três estados:
  executando, que indica que o escalonador está em execução; não inicializado, que 
 indica que o escalonador não foi inicializado ainda; e suspenso,que indica que
 as atividades do escalonador estão suspensas }. Caso, a tarefa ociosa não possa
 ser criada, o escalonador não será inicializado permanecendo no
 estado não inicializado.

  \item \textbf{vTaskEndScheduler} - Finaliza as atividades do escalonador
  colocando-o no estado não inicializado. Para isso, ele primeiramente exclui todas
  as estruturas (tarefas, filas de mensagens, co-rotinas, etc) criadas no FreeR
 TOS e em seguida finaliza o escalonador.
 
  \item \textbf{vTaskSuspendAll} - Suspende temporariamente todas atividades do
  escalonador colocando-o no estado suspenso.
  
  \item \textbf{xTaskResumeAll} - Retorna todas as atividades do escalonador
  quando este encontra-se no estado suspenso.
  
\end{itemize}


\subsection{Utilidades de tarefas}
\label{subsec:tutilities}
No grupo de utilidades de tarefas, encontram-se as operações responsáveis
por fornecer informações úteis sobre o estado do kernel. Esse grupo é composto
pelas seguintes funções:

\begin{itemize}
  \item \textbf{xTaskGetCurrentTaskHandle} - Retorna uma referência para a
  tarefa em execução
  \item \textbf{xTaskGetSchedulerState} - Informa o atual estado do
  escalonador (executando, suspenso ou não inicializado).
  \item \textbf{uxTaskGetNumberOfTasks} - Informa a atual quantidade de tarefas
  tarefas do FreeRTOS.
  \item \textbf{xTaskGetTickCount} - Informa a quantidade de tempo decorrido
  desde a inicialização do escalonador 
\end{itemize}

\subsection{Gerenciamento das filas de mensagens}
\label{subsec:fmanagemente}
As funcionalidades presentes no grupo Gerenciamento das filas de mensagens cabem
as obrigações de gerenciar, criar e excluir as filas de mensagens do FreeRTOS.
Esse grupo é formado pela as seguintes funções:

\begin{itemize}
  \item \textbf{xQueueCreate} - Cria uma nova fila de mensagem, retornando uma
  referência para a mesma. Caso a fila de mensagem não possa ser criada, uma
  referência de fila nula é retornada no lugar da tarefa criada.
  
  \item \textbf{xQueueSend} - Método usado por uma tarefa para enviar uma
  mensagem para uma fila de mensagens. Caso a fila esteja cheia e não possa
  receber a mensagem, a tarefa é bloqueada até que seja liberado um lugar na
  fila.
  
  \item \textbf{xQueueSendToBack} - Esse método funciona do mesmo modo que o
  \textit{xQueueSendToBack}. Ele envia uma mensagem para o final de uma fila de
  uma fila de mensagem e caso essa esteja cheia, a tarefa que utilizou o método
  é bloqueada até que seja liberando um lugar na fila.
  
  \item \textbf{xQueueSendToFront} - Método utilizado por uma tarefa para
  enviar uma mensagem para o início de uma fila de mensagem. Caso a fila esteja
  cheia, a tarefa é bloqueada até que seja liberado um espaço na fila de
  mensagem
  
  \item \textbf{xQueueReceive} - Método utilizado por uma tarefa para ler e
  retirar uma mensagem localizada no início da fila de mensagens. Caso a fila de
  mensagens esteja vazia, a tarefa é bloqueada até que uma mensagem chegue na
  fila.
  
  \item \textbf{xQueuePeek} -  Método utilizado por uma tarefa para ler sem
  retirar uma mensagem localizada no início da fila de mensagens. Caso a fila de
  mensagens esteja vazia, a tarefa é bloqueada até que uma mensagem chegue na
  fila.
  
  \item \textbf{vQueueDelete} - Exclui uma fila de mensagens do FreeRTOS.
  Entretanto, o espaço ocupado pela a mesma só será liberado pela tarefa
  ociosa.
  
\end{itemize}

\subsection{Parâmetros de configuração}
\label{subsec:config}
Por último, tem-se um grupo que não trata das funcionalidades da API do FreeRTOS,
mas de seus parâmetros de configuração. Esses parâmetros são atributos que
permitem ao Kernel uma configuração sob medida para cada aplicação em
particular. Assim, eles funcionam basicamente como um indicativo para o kernel dizendo quais
os conceitos e funcionalidade que a aplicação ira utilizar. A lista completa de
todos os parâmetros utilizados no projeto de modelagem pode ser encontrada a
seguir:

\begin{itemize}
  \item \textbf{configMAX\_PRIORITIES} - Esse parâmentro informa o número da
  prioridade máxima prioridade que será utilizada no sistema.
  
  \item \textbf{INCLUDE\_vTaskPrioritySet} - Esse parâmetro indica a utilização,
  ou não, da funcionalidade \textit{vTaskPrioritySet} pelo sistema.
  
  \item {\textbf{INCLUDE\_vTaskSuspend} - Esse parâmetro indica a utilização, ou
  não, da funcionalidade \textit{vTaskSuspend}} pelo sistema.
  
  \item \textbf{INCLUDE\_uxTaskPriorityGet} - Esse parâmetro indica a
  utilização, ou não, da funcionalidade \textit{uxTaskPriorityGet} pelo sistema.
  
  \item \textbf{INCLUDE\_vTaskDelete} - Esse parâmetro indica a utilização, ou
  não, da funcionalidade \textit{vTaskDelete} pelo sistema. 
  
  
  \item \textbf{INCLUDE\_xTaskGetSchedulerState} - Esse parâmetro indica a
  utilização, ou não, da funcionalidade \textit{xTaskGetSchedulerState} pelo sistema.
  
  \item \textbf{INCLUDE\_xTaskGetCurrentTaskHandle} - Esse parâmetro indica a
  utilização, ou não, da funcionalidade \textit{xTaskGetCurrentTaskHandle} pelo sistema.
  
  \item \textbf{INCLUDE\_vTaskDelay} - Esse parâmetro indica a
  utilização, ou não, da funcionalidade \textit{vTaskDelay} pelo sistema.  
  
  \item \textbf{INCLUDE\_vTaskDelayUntil} - Esse parâmetro indica a
  utilização, ou não, da funcionalidade \textit{vTaskDelayUntil} pelo sistema.  
   
\end{itemize}
	
\section{Modelagem}
\label{sec:Modelling}

A modelagem em B do FreeRTOS pode ser divida em dois grupos principais, o grupo
de tarefa e o grupo de fila de mensagens, os quais são responsáveis pela a
especificação dos conceitos, juntos com suas funcionalidades, de mesmo nome. Ao
todo foram criados 7 máquinas, das quais 2 pertencem ao grupo de tarefas e 3
pertencem ao grupo de fila de mensagens, restando 1 máquina para os parâmetros
de configuração e outra para a definição de tipos utilizados na modelagem. A
composição e explicação da modelagem realizada em cada grupo pode ser vista nas
sessão a seguir.

\subsection{Tarefas}
\subsubsection{Conceitos}

O conceito de tarefa é modelado através da máquina $\mathbf{Task\_Core}$. Nessa
modelagem inicial, uma tarefa é especificada contendo apenas a característica
estado, sendo as demais características (ver sessão \ref{subsec:tarefa})
especificadas em futuros refinamentos. Assim modelagem conceito de tarefa foi
feita como demonstra a figura \ref{fig:task-modelling}. Nela, percebe-se que
primeiramente foi criado o conjunto abstrato $\mathit{TASK}$, que simboliza o
conjunto universo de todas as tarefas que podem ser criadas no FreeRTOS. E, em
seguida, a variável $\mathit{tasks}$ é instituída para armazenar todas as tarefas
que estão sendo gerenciadas pelo sistema, proporcionando a seguinte definição
$\mathit{tasks} \in \mathbf{FIN}(\mathit{TASK})$.

Ainda na figura \ref{fig:task-modelling}, nota-se também que os estados de uma
tarefa são modelados através das variáveis $\mathit{ready}$, $\mathit{running}$,
$\mathit{blocked}$ e $\mathit{suspended}$, as quais representam respectivamente
os estados pronto, executando, bloqueado e suspenso. Assim, quando uma tarefa
encontra-se na variável $\mathit{ready}$, indica que ela está no estado pronto,
ocorrendo o mesmo para os demais estado. Entretanto, para uma completa e fiel
especificação dos estados de uma tarefa, além da definição das variáveis, são
necessárias algumas restrições adicionais como: uma tarefa não deve possuir mais
de um estado ao mesmo tempo e só deve existir uma tarefa no estado executando em
um determinado instante. Essa restrições podem ser vistas em maiores detalhes
através $\mathbf{INVARIANT}$ da figura \ref{fig:task-modelling}

\begin{figure}[!b]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathbf{SETS}\\
\quad   \mathit{TASK};\\
\quad   \ldots \\\\
    		
\mathbf{VARIABLES}\\
\quad   \mathit{tasks},\\
\quad   \mathit{blocked},\\
\quad	\mathit{running},\\
\quad	\mathit{ready}, \\
\quad	\mathit{suspended}\\
\quad	\ldots
\end{array}
\begin{array}[t]{l}

\mathbf{INVARIANTS}\\

\quad \mathit{tasks} \in \mathbf{FIN}(\mathit{TASK}) \land \\
\quad \mathit{tasks} \neq \emptyset \land \\\\

\quad \mathit{blocked}	\in \mathbf{FIN}(\mathit{TASK}) \land \\
\quad \mathit{blocked} \subset \mathit{tasks} \land \\\\

\quad \mathit{ready} \in \mathbf{FIN}(\mathit{TASK}) \land \\
\quad \mathit{ready} \subset \mathit{tasks} \land \\\\	

\quad \mathit{suspended} \in \mathbf{FIN}(\mathit{TASK}) \land \\
\quad \mathit{suspended} \subset \mathit{tasks} \land \\
\quad \ldots
\end{array}

\begin{array}[t]{l}
\quad \mathit{running} \in \mathit{TASK} \land \\
\quad \mathit{running} \in \mathit{tasks} \land \\
\quad \mathit{running}  \not\in \mathit{ready} \land \\
\quad \mathit{running} \not\in  \mathit{blocked} \land \\
\quad \mathit{running} \not\in  \mathit{suspended} \land \\\\

\quad \mathit{ready} \cup \mathit{blocked} = \emptyset \land \\ 
\quad \mathit{blocked} \cup \mathit{suspended} = \emptyset \land \\
\quad \mathit{suspended} \cup \mathit{ready} = \emptyset \land \\\\

\quad \mathit{tasks} = \mathit{\{running\}} \cup \mathit{suspended} \\ 
\quad\quad\quad\quad\quad \cup \mathit{blocked} \cup \mathit{ready}

\end{array}
\end{array}
$$
\end{small}
\caption{Modelagem do conceito tarefa}
\label{fig:task-modelling}
\end{figure}

\subsubsection{Operações básicas}
Após modelado o conceito de tarefa , foram criadas na máquina
$\mathbf{TASK\_CORE}$ operações básicas que manipulam os estados de uma tarefa e
servem como suporte para a especificação das funcionalidades da API do FreeRTOS
que utilizam o conceito de tarefa. Ao todo, foram criadas 12 operações, entre
elas a operação Create, responsável pela criação de uma nova tarefa e
especificada como mostra a figura \ref{fig:Create}.

\begin{figure}[!t]
\begin{small}

$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
\mathit{result} \longleftarrow \mathit{Create}
										(\mathit{priority}) = \\
\mathbf{PRE}\\ 
\quad \mathit{priority} \in \mathit{PRIORITY} \land \\ 
\mathbf{THEN} \\
\quad \mathbf{ANY}\\
\quad\quad \mathit{task}\\
\quad \mathbf{WHERE}\\
\quad\quad \mathit{task} \in \mathit{TASK} \land\\
\quad\quad \mathit{task} \not\in \mathit{tasks}\\ 
\quad \mathbf{THEN} \\    	    
\quad\quad \mathit{tasks} := \{ \mathit{task} \} \cup \mathit{tasks} \parallel\\ 
\quad\quad \mathbf{CHOICE}\\        	    
\quad\quad\quad 
		\mathit{ready} := \{\mathit{running}\} \cup \mathit{ready}\parallel\\ 
\quad\quad\quad\mathit{running} := \mathit{task}\\
\quad\quad\mathbf{OR}\\
\quad\quad\quad \mathit{ready} :=  \{ \mathit{task} \} \cup \mathit{ready}\\
\quad\quad\mathbf{END}\parallel \\
\quad\quad\quad\mathit{result} := \mathit{task}\\
\quad\mathbf{END}\\      
\mathbf{END};\\
\end{array}
\end{array}
$$

\end{small}
\caption{Modelagem da operação $\mathit{Create}$}
\label{fig:Create}
\end{figure}

Na operação $\mathit{Create}$ inicialmente é definida uma nova tarefa, denominada
$\mathit{task}$, que pertence ao conjunto abstrato $\mathbf{TASK}$ e não
pertence, ainda, ao conjunto de tarefas gerenciadas pelo FreeRTOS,
$\mathit{tasks}$. Em seguida, essa nova tarefa é finalmente adicionada ao a
variável ($\mathit{tasks}$) e, após isso, seu estado inicial é definido, podendo
este ser executando ou pronto. E ao final, um referência para a nova tarefa
criada é retornada pela operação.

Ainda na função $\mathit{Create}$, percebe-se que esta recebe como argumento um
parâmetro pertencente ao conjunto universo das prioridades,
$\mathit{PRIORITIES}$. Entretanto, esse parâmetro não é utilizado na
especificação da operação, pois a característica prioridade não é tratada nessa
modelagem inicial. Assim, o parâmetro declarado no cabeçalho da função será usado
apenas por futuros refinamentos da operação para decidir o estado inicial da
tarefa criada. A lista completa de todas operações da máquina
$\mathbf{TASK\_CORE}$, junto com suas descrições, pode ser vista a seguir:

\begin{itemize}
\item \textbf{Create} - Cria uma nova tarefa gerenciada pelo FreeRTOS, podendo
o estado inicial da mesma ser executando ou pronto.

\item \textbf{Delete} - Exclui uma tarefa gerenciada pelo FreeRTOS. Se a tarefa
que será excluída for a tarefa em execução, uma nova tarefa será escolhida,
entre as de estado pronto, para entrar em execução.

\item \textbf{Suspend} - Coloca uma tarefa no estado suspenso. No caso, em que a
tarefa suspensa será a tarefa em execução, uma nova tarefa deverá ser escolhida,
entre as de estado pronto, para entrar em execução.

\item \textbf{Resume} - Retorna uma tarefa que estava no estado suspenso
colocando-a no estado pronto ou executando.

\item \textbf{GetPriority} - Retorna a prioridade de uma determinada tarefa, mas
como a característica prioridade não é especificada nessa modelagem inicial, essa
operação retorna apenas um elemento que pertence ao conjunto abstrato denominado
$\mathit{PRIORITIES}$, o qual representa as possíveis prioridades do FreeRTOS.

\item \textbf{GetCurrent} - Retorna uma referência para a atual tarefa em
execução

\item \textbf{GetNumberOfTasks} - Retorna o número atual de tarefas de tarefas
do FreeRTOS

\item \textbf{DelayTask} - Coloca a tarefa em execução no estado boqueado ate
uma determinada quantidade de tempo

\item \textbf{Unblock}- Desboqueia uma tarefa que estava bloqueada, colocando-a
no estado pronto ou executando.
 
\item \textbf{StartScheduler}- Cria a tarefa ociosa podendo essa ser criada com
o estado executando ou com o estado pronto

\item \textbf{EndScheduler} - Exclui todas as tarefas do FreeRTOS, zerando os
conjuntos de estados e colocando uma referência de tarefa nula na variável de
estado em execução.

\item \textbf{ResumeAll} - Desbloqueia todas as tarefas que deveriam ser
boqueadas enquanto o escalonador estava suspenso.

\end{itemize}
\subsubsection{Funcionalidades}
Feita a modelagem do conceito de tarefa, junto com as suas operações básicas,
resta apenas especificar as funcionalidades da API que utilizam-se desse
conceitos. A especificação dessas funcionalidades é feita através da máquina
$\mathbf{TASK\_CORE}$, onde estão presente as funcionalidades dos grupos de
criação de tarefa, controle de tarefa, utilidades de tarefa e controle do kernel.
Assim, para uma boa e resumida compreensão da modelagem, será demonstrado aqui,
apenas uma funcionalidade importante de cada grupo, sendo que as demais podem
ser vistas no repositório da modelagem em \cite{repository}.


\subsubsection* {Criação de tarefa} 

A funcionalidade escolhida como principal para o grupo criação de tarefa foi a
$\mathit{xTaskCreate}$. Nela, uma nova tarefa pode ser criada ou não, dependendo
da disponibilidade de memória, característica não tratada nessa modelagem inicial.
Assim, a especificação dessa funcionalidade foi feita como demonstra a figura
\ref{fig:xTaskCreate}, onde são especificados os dois comportamentos possíveis
para a função. Ou a tarefa é criada através da chamada ao método
$\mathit{Create}$ e uma referência para a nova tarefa criada, junto com a
mensagem sucesso, é retornada, ou, a tarefa não é criada e uma referência nula,
junto com a mensagem de erro, é retornada.

\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}
\mathit{result}, \mathit{handle} \longleftarrow \mathit{xTaskCreate}
										(\mathit{pvTaskCode},\mathit{pcName},\\
\quad\quad \quad\quad \quad\quad \quad\quad\quad\quad\quad\quad\quad\quad
			\mathit{usStackDepth},\mathit{pvParameters}, \mathit{uxPriority}) = \\
\mathbf{PRE}\\ 
\quad \mathit{pvTaskCode} \in \mathit{TASK\_CODE} \land \\ 
\quad \mathit{pcName} \in \mathit{NAME} \land \\ 
\quad \mathit{usStackDepth} \in \mathit{NATURAL} \land \\  
\quad \mathit{pvParameters} \subset \mathit{PARAMETER} \land \\ 
\quad \mathit{uxPriority} \in \mathit{PRIORITY} \land \\
\mathbf{THEN} \\
\quad \mathbf{CHOICE}\\ 
\quad \quad \mathit{handle} \leftarrow \mathit{Create} (\mathit{uxPriority})
				\parallel\\ 
\quad \quad \mathit{result} := \mathbf{pdPASS}\\
\quad	\mathbf{OR} \\
\quad \quad
\mathit{result}:=\mathbf{errCOULD\_NOT\_ALLOCATE\_REQUIRED\_MEMORY} \parallel \\ 
\quad \quad 
\mathit{handle} := \mathbf{TASK\_NULL} \\
\quad \mathbf{END};\\
\end{array}
\end{array}
$$

\end{small}
\caption{Modelagem da operação $\mathit{xTaskCreate}$}
\label{fig:xTaskCreate}
\end{figure}

\subsubsection* {Controle de tarefa} 

Para o grupo controle de tarefa, vale apena demonstrar a modelagem da
funcionalidade $\mathit{xTaskDelay}$, responsável pelo bloqueio de uma tarefa
durante um determinado tempo. Essa funcionalidade é especifica como demostra a
figura \ref{fig:vTaskDelay}. Nela, a função recebe como parâmetro o tempo no qual
a tarefa deve permanecer bloqueada e, em seguida, utiliza-se desse valor para
calcular o tempo em que a mesma deve ser desbloqueada, incrementando ao tempo
corrente, $\mathit{tickCount}$ \footnote{Variável da máquina
$\mathbf{TasK_Basic}$ responsável por armazenar o tempo decorrido desde a
inicialização do escalonador}, o valor passado como argumento. Após calculado o
tempo de desbloqueio a operação $\mathit{DelayTask}$ é invocada, tendo como
parâmetro o tempo de desbloqueio, para que a tarefa seja bloqueada até o tempo
calculado.


\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathit{vTaskDelay}(\mathit{xTicksToDelay})=\\
	\mathbf{PRE}\\
\quad    	\mathit{xTicksToDelay} \in \mathit{TICK} \land \\ 
\quad    	\mathit{INCLUDE\_vTaskDelay} = 1 \land \\
\quad    	\mathbf{not}(\mathit{TICK\_INCREMENT}(\mathit{tickCount},
			\mathit{xTicksToDelay})=0)\\ 
\mathbf{THEN}\\
\quad    \mathit{DelayTask} (\mathit{TICK\_INCREMENT} (\mathit{tickCount},
													\mathit{xTicksToDelay}))\\ 
\mathbf{END};
\end{array}
\end{array}
$$
\end{small}
\caption{Modelagem da operação $\mathit{vTaskDelay}$}
\label{fig:vTaskDelay}
\end{figure}

\subsubsection* {Utilidades de tarefa} 

O grupo de utilidades de tarefa é formado por funcionalidades bastante simples,
pois elas apenas retornam informações importantes a respeito do estado do kernel.
Uma dessas funcionalidades é a $\mathit{xTaskGetCurrentTaskHandle}$, que retorna
uma referência para a tarefa em execução. A especificação dessa funcionalidade
pode ser vista pela figura \ref{fig:xTaskGetCurrentTaskHandle}, na qual a função
apenas realiza uma chamada ao método $\mathit{GetCurrent}$ para obter a tarefa em
execução e passar o retorno do método como retorno da função.
  
\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathit{cTask} \longleftarrow \mathit{xTaskGetCurrentTaskHandle}= \\
	\mathbf{PRE}\\
\quad    	\mathit{INCLUDE\_xTaskGetCurrentTaskHandle} = 1\\
	\mathbf{THEN}\\
\quad    	\mathit{cTask} \gets \mathit{GetCurrent}\\

 
\mathbf{END};
\end{array}
\end{array}
$$
\end{small}
\caption{Modelagem da operação $\mathit{xTaskGetCurrentTaskHandle}$}
\label{fig:xTaskGetCurrentTaskHandle}
\end{figure}  
  
\subsubsection* {Controle do kernel}
No grupo controle do kernel existem várias funcionalidades importantes. Uma
delas é a $\mathit{vTaskStartSchedule}$ que é responsável pela inicialização
do escalonador e pela criação da tarefa ociosa. Essa função comporta-se como
demonstra a figura \ref{fig:vTaskStartSchedule}. Nela, o escalonador pode
ou não ser inicializado. Caso o escalonador seja inicializado, primeiramente a
operação $\mathit{StartScheduler}$ é chamada, para que a tarefa ociosa seja
criada e, em seguida, o estado do escalonador, armazenado pela variável
$\mathit{scheduler}$, é alterado para executando. E caso o escalonador não
possa ser inicializado, nada é feito.

\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathit{vTaskStartScheduler} =\\ 
\mathbf{PRE}\\
\quad \mathit{scheduler} = \mathit{taskSCHEDULER\_NOT\_STARTED} \land \\
\quad \mathit{running} = \mathbf{TASK\_NULL} \land \\
\quad \mathit{blocked} = \emptyset \land \\ 
\quad \mathit{suspended} = \emptyset \land \\ 
\quad \mathit{ready} = \emptyset\\  	
\mathbf{THEN}\\
\quad \mathbf{CHOICE}\\
\quad\quad \mathit{StartScheduler} \parallel\\
\quad\quad \mathit{scheduler}:=\mathbf{taskSCHEDULER\_RUNNING}\\
\quad \mathbf{OR}\\
 \quad\quad \mathit{skip}\\
\quad \mathbf{END}\\
\mathbf{END};
 
\end{array}
\end{array}
$$
\end{small}
\caption{Modelagem da operação $\mathit{vTaskStartSchedule}$}
\label{fig:vTaskStartSchedule}
\end{figure}




\subsection{Fila de Mensagem}
\subsubsection{Conceito}
A maquina responsável pelo conceito de fila de mensagens e a
$\mathbf{QUEUE\_CORE}$. Nela, uma fila de mensagem é especificada como sendo um
conjunto de mensagens, um conjunto de tarefas que aguardam para enviar uma
mensagem para a fila e um conjunto de tarefas que aguardam para receber uma mensagem da
fila. As demais características da fila de mensagens (ver sessão
\ref{subsec:fmensagem}) serão modeladas em futuros refinamento.

A figura \ref{fig:queue-modelling} demonstra como é feita a especificação do
conceito de fila de mensagens. Inicialmente são declarados os conjuntos abstratos
$\mathit{QUEUE}$ e $\mathit{ITEM}$, que simbolizam, respectivamente, todas as
filas de mensagens e suas mensagens que podem ser gerenciados pelo FreeRTOS. Em
seguida, a variáveis $\mathit{queues}$ é criadas para armazenar todas as filas de
mensagens gerenciadas pelo FreeRTOS. E por fim, são criados as relações
$\mathit{queue\_items}$, $ \mathit{queue\_sending}$ e
$\mathit{queue\_receiving}$, reponsáveis por ligar uma fila de mensagens a um
conjunto de itens, a um conjunto de tarefas que esperam para enviar uma mensagem
para a fila e a um conjunto de tarefa que aguardam para ler uma mensagem da
fila, respectivamente.

Entretanto, para a completa especificação do conceito de fila de mensagens, resta a
restrições de que toda fila de mensagens deve possuir um conjunto de itens e dois
conjuntos de tarefa que aguardam para enviar e receber uma mensagem da fila.
Essa restrição pode ser observada pelo $\mathbf{INVARIANT}$ da máquina através
das declarações $\mathit{queues} = \mathbf{dom}(\mathit{queue\_items})$,
$\mathit{queues} = \mathbf{dom}(\mathit{queue\_receiving}) $ e $\mathit{queues} =
\mathbf{dom}(\mathit{queue\_sending})$, completando assim a especificação do
conceito de fila de mensagem.

\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathbf{SETS} \\
\quad   \mathit{QUEUE};\\
\quad   \mathit{ITEM};\\
\quad   \ldots \\
    		
\mathbf{VARIABLES}\\
\quad   \mathit{queues},\\
\quad\quad   \mathit{queue\_items},\\
\quad\quad   \mathit{queue\_receiving},\\
\quad\quad	 \mathit{queue\_sending}
\end{array}

\begin{array}[t]{l}

\mathbf{INVARIANTS}\\

\quad \mathit{queues} \in \mathbf{POW}(\mathit{QUEUE}) \land \\
\quad\quad \mathit{queue\_items} \in \mathit{QUEUE} \rightarrow\mkern-22mu+
\quad\quad \mathbf{POW}(\mathit{ITEM})\land \\

\quad\quad \mathit{queue\_receiving} \in \mathit{QUEUE} \rightarrow\mkern-22mu+
\quad\quad \mathbf{POW}(\mathit{TASK}) \land \\ 

\quad\quad \mathit{queue\_sending} \in \mathit{QUEUE}\rightarrow\mkern-22mu+
\quad\quad \mathbf{POW}(\mathit{TASK}) \land \\\\
    		
\quad \mathit{queues} = \mathbf{dom}(\mathit{queue\_items}) \land \\
\quad \mathit{queues} = \mathbf{dom}(\mathit{queue\_receiving}) \land \\
\quad \mathit{queues} = \mathbf{dom}(\mathit{queue\_sending})

\end{array}

\end{array}
$$
\end{small}
\caption{Modelagem do conceito fila de mensagem}
\label{fig:queue-modelling}
\end{figure}

\subsubsection{Operações Básicas}
Depois da modelagem do conceito de fila de mensagens, ainda na máquina
$\mathbf{QUEUE\_CORE}$, foram criadas várias operações que manipulam as
características de uma fila de mensagens e servem como base para a especificação
das funcionalidades que utilizam-se desse conceito. Entre essas operações
merece destaque a $\mathit{sendItem}$, que é responsável por enviar uma
mensagem para a fila e é especifica como demonstra a figura \ref{fig:sendItem}.

\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}

\mathit{sendItem}( \mathit{pxQueue}, \mathit{pxItem}
					\mathit{task},\mathit{copy\_position}) = \\
\mathbf{PRE}\\
\quad  \mathit{pxQueue} \in \mathit{queues} \land \\ 
\quad  \mathit{pxItem} \in \mathit{ITEM} \land \\ 
\quad  \mathit{task}\in \mathit{TASK} \land \\ 
\quad  \mathit{copy\_position} \in \mathit{COPY\_POSITION} \land\\    
\quad  \mathit{task} \in \mathit{queue\_receiving}(\mathit{pxQueue})\\
\mathbf{THEN}\\
\quad  \mathit{queue\_items}(\mathit{pxQueue}):=
				\mathit{queue\_items}(\mathit{pxQueue}) \cup \{\mathit{pxItem}\}\parallel\\
\quad  \mathit{queue\_receiving}(\mathit{pxQueue}) :=
				\mathit{queue\_receiving}(\mathit{pxQueue}) - \{\mathit{task}\} \\
\mathbf{END};
\end{array}
\end{array}
$$
\end{small}
\caption{Modelagem da operação $\mathit{sendItem}$}
\label{fig:sendItem}
\end{figure}

Nessa operação são passados como argumento a fila que receberá a mensagem, a
mensagem, ou item, que será colocada na fila e uma tarefa que pertence ao
conjunto de tarefa que aguardam por uma mensagem da fila. Tendo esses parâmetros
em mãos, o comportamento da operação resume-se em apenas a colocar a mensagem no
conjunto de mensagens da fila passada e retirar a tarefa do conjunto de tarefa
que aguardavam por uma mensagem da fila passada, pois com a chegada da mensagem
a tarefa é desbloqueada e retirada do presente conjunto. As demais operação da
máquina $\mathbf{QUEUE\_CORE}$ podem ser vistas na lista a seguir:

\begin{itemize}
  \item {\textbf{xQueueCreate} - Cria uma nova fila de mensagem retornando uma
  referência para a mesma. Se a fila não poder ser criada uma constante de
  tarefa nula $\mathbf{QUEUE\_NULL}$} é retornada no lugar da fila criada.
  \item {\textbf{sendItem} - Adiciona um novo item a uma fila e retira da fila 
  retirando da mesma uma tarefa que está na lista de espera pela chegada de um 
  item }
  \item {\textbf{receivedItem} - Remove, ou não um item de uma fila. Caso o
  item seja removido, a função retorna uma referencia para o item em
  questão, remove o item da fila e caso exista, retira uma tarefa do conjunto
  de tarefas que estão esperando por um lugar na fila }
  \item {\textbf{insertTaskWaitingToSend} - Insere uma tarefa no conjunto de
  tarefas que estão aguardando por um lugar na fila para enviar um item}
  \item {\textbf{insertTaskWaitingToRecived} - Insere uma tarefa no conjunto de
  tarefas que estão esperando pela chegada de um item na fila }
  \item {\textbf{removeFromEventListQueue} - Remove uma tarefa de todas as
  listas de eventos de todas as filas gerenciadas pelo FreeRTOS}
\end{itemize}


\subsubsection{Operações Intermediárias}
Durante a modelagem das funcionalidades que utilizam-se do conceito de fila de
mensagem, percebeu-se que vários comportamentos se repetem entre essas
funcionalidades. Assim para uma maior modularização e controle, antes da
especificação das funcionalidades, foi criada uma máquina, denominada
$\mathbf{QUEUE\_BASIC}$ responsável por especificar comportamentos que se
repetem entre as funcionalidades que utilizam-se do conceito de fila de
mensagens.

Os comportamentos citados no paragrafo anterior foram agrupados em duas
operações: $\mathit{xQueueGenericSend}$, responsável por enviar um mensagem para
uma fila de mensagem e desbloquear uma tarefa que aguarda por uma mensagem da
fila, bloquear a tarefa remetente, caso a fila esteja cheia, ou retorna uma
mensagem de erro, caso a mensagem não possa ser enviada e a tarefa não possa ser
bloqueada; e $\mathit{xQueueGenericReceive}$, que é responsável por receber um
mensagem da fila e desbloquear uma tarefa que aguarda para enviar uma mensagem
para a fila, bloquear a tarefa receptora, caso não haja nenhum item na fila ou
retornar uma mensagem de erro, no caso da mensagem não poder ser recebida e a
tarefa não poder ser bloqueada.

Na figura \ref{fig:xQueueGenericSend} tem-se a especificação dos três
comportamentos possíveis para a operação $\mathit{xQueueGenericReceive}$. No
primeiro comportamento, inicialmente é declarada uma tarefa que pertence ao
conjunto de tarefas que aguardam por uma mensagem da fila. Em seguida, essa
tarefa é passa como argumento, junto com a mensagem $\mathit{pvItemToQueue}$,
para o método $\mathit{sendItem}$, que envia a mensagem para a fila e retira a
tarefa passada do conjunto de tarefas que aguardam por uma mensagem. No segundo
comportamento, através do método $\mathit{insertTaskWaitingToSend}$, a tarefa
corrente é adicionada no conjunto de tarefas que aguardam para enviar uma
mensagem para a fila e, após isso, ela é bloqueada pelo método
$\mathit{DelayTask}$. Por fim, no último comportamento, apenas uma mensagem de
erro é retornada, informando que a mensagem não pode ser enviada e nem a tarefa
foi colocada na conjunto de tarefas que aguardam para enviar uma mensagem.


\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}   	
\ldots\\
\quad \mathbf{ANY}\\
\quad \quad \mathit{task}\\
\quad \mathbf{WHERE}\\
\quad \quad \mathit{task} \in \mathit{TASK} \land \\ 
\quad \quad \mathit{task}\in \mathit{blocked} \land \\
\quad  \quad \mathit{task}\in \mathit{queue_receiving}(\mathit{pxQueue})\\ 
\quad \mathbf{THEN}\\
\quad \quad \mathit{sendItem}(\mathit{pxQueue}
			,\mathit{pvItemToQueue},\mathit{task,copy_position})\parallel\\
\quad \quad \mathit{Unblock}(task)\parallel\\ 
\quad \quad \mathit{return}:=\mathit{pdPASS}\\
\quad \mathbf{END}\\        	
\ldots\\
\quad
\mathit{insertTaskWaitingToSend}(\mathit{pxQueue},\mathit{running})\parallel \\
\quad \mathit{DelayTask}(\mathit{xTicksToWait})\parallel\\
\quad \mathit{return}:=\mathit{pdTRUE}\\
\ldots\\
\quad \mathit{return}:=\mathit{errQUEUE\_FULL}\\
\ldots
\end{array}
\end{array}
$$
\end{small}
\caption{Comportamentos da operação $\mathit{xQueueGenericReceive}$}
\label{fig:xQueueGenericSend}
\end{figure}

\subsubsection{Funcionalidades}
Após a criação das operações intermediárias, a máquina $\mathbf{QUEUE}$ foi
criada para especificar as funcionalidades que utilizam o conceito de fila de
mensagens. Nela estão presentes as funcionalidades do grupo gerenciamento de
fila de mensagens, sendo que uma das principais funcionalidades desse grupo é a
operação $\mathit{xQueueSend}$ responsável por enviar uma mensagem para uma
fila de mensagens. A especificação completa dessa funcionalidade pode ser vista
na figura \ref{fig:xQueueSend}.

\begin{figure}[!h]
\begin{small}
$$
\begin{array}[t]{ccc}
\begin{array}[t]{l}  
\mathit{return} \longleftarrow \mathit{xQueueSend}(\mathit{pxQueue},
\mathit{pvItemToQueue}, \mathit{xTicksToWait})=\\
\mathbf{PRE}\\
\quad \mathit{pxQueue}\in \mathit{queues}  \land\\  
\quad \mathit{pvItemToQueue} \in \mathit{ITEM}  \land\\  
\quad \mathit{xTicksToWait}\in \mathit{TICK}\\
\mathbf{THEN}\\
\quad \mathbf{ANY}\\ 
\quad\quad \mathit{copy\_position}\\
\quad \mathbf{WHERE}\\
\quad\quad \mathit{copy\_position} \in \mathit{COPY\_POSITION}\\
\quad \mathbf{THEN}\\
\quad\quad \mathit{return} \gets \mathit{xQueueGenericSend}(\mathit{pxQueue},
\mathit{pvItemToQueue},\\
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad
\mathit{xTicksToWait},\mathit{copy\_position})\\ 
\quad \mathbf{END}\\
\mathbf{END}
	;
\end{array}
\end{array}
$$
\end{small}
\caption{Operação $\mathit{xQueueSend}$}
\label{fig:xQueueSend}
\end{figure}

Na especificação da funcionalidade $\mathit{xQueueSend}$ são passados como
argumentos para a função uma fila de mensagens, a mensagem que será enviada e o
tempo máximo que a tarefa remetente pode esperar para enviar uma mensagem para a
fila. Assim, devido a criação das operações intermediárias todo o trabalho
necessário para enviar uma mensagem para uma fila de mensagem, é realizado pela
operação $\mathit{xQueueGenericSend}$, que recebe os argumentos passados na
função e retorna o resultado da operação, dizendo se essa foi realizada com
sucesso ou não. Com isso, resta apenas a função $\mathit{xQueueSend}$ realizar
uma chamada à operação $\mathit{xQueueGenericSend}$, passando os devido
parâmetros necessários, para que uma mensagem seja enviada para a fila de
mensagens.
	
\section{Considerações finais}
\label{sec:consideracoes} 
Para chegar-se a essa modelagem inicial foram feitas várias outra especificações
sem sucesso. O fracasso das demais especificações deu-se principalmente devido a
dificuldades com as obrigações de prova, pois sempre que tentava-se fazer uma
modelagem mais complexa não conseguia-se provar todas as obrigações de provas
geradas pela modelagem.

Como consequência das dificuldades com as obrigações de prova, foi necessário
refazer toda a especificação inicial com um nível maior de abstração. Nessa
reformulação foi decidido que várias características, anteriormente tratadas pela
modelagem, como prioridade e tamanho de uma fila de mensagem, seriam excluídas da
modelagem inicial, restando apenas as características de estado de uma tarefa e
os conjuntos que compõem uma fila de mensagens.

Através da modelagem do FreeRTOS percebeu-se também que para especificar a
concorrência entre as tarefas gerenciadas pelo sistema, característica intrínseca
do FreeRTOS, será necessário um formalismo diferente do método B, pois o mesmo
não oferece suporte para especificar eventos concorrentes, como ocorre com as
tarefas do FreeRTOS. Com isso, o formalismo sugerido para tratar da concorrência
no FreeRTOS, sem a perda da especificação inicial criada, seria o Event B, um
formalismo capaz de especificar sistemas complexo e de natureza concorrente.

Em suma, a especificação inicial do FreeRTOS foi realizada através de 7
máquinas, $\mathbf{Task\_Core}$, $\mathbf{Task\_Basic}$,
$\mathbf{FreeRTOSConfig}$ $\mathbf{Queue}$, $\mathbf{Queue\_Basic}$,
$\mathbf{Queue\_Core}$ e $\mathbf{Types}$. No total, foram 
foram geradas 226 obrigações de provas, sendo que 208 dessas foram provadas
automaticamente através da ferramenta utilizada para especificação, AtelierB,
restando apenas 18, que foram provadas através de uma simples interação com o
provador da ferramenta. O quadro completo de todas as provas geradas das
principais máquinas pode ser visto na tabela \ref{tab:obp}

\begin{table*}[h]
\centering
\caption{Tabela de obrigações de prova das principais máquinas}
\label{tab:obp}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Máquinas} & \textbf{Nª Ob.} & \textbf{Nª P.A.} & \textbf{Nª P.I.}\\
\hline \hline
\textit{Task\_Core} & $179$ & $161$ & $18$\\ \hline
\textit{Task\_Base} & $16$ & $16$ & $0$\\ \hline
\textit{Queue\_Core} & $27$ & $27$ & $0$\\ \hline
\textit{Queue\_Basic}& $2$ & $2$ & $0$\\ \hline
\textit{Queue}& $0$ & $0$ & $0$ \\ \hline
\end{tabular}

\end{table*}
\section{Trabalhos Futuros}
A continuidade desse trabalho será feita através de refinamentos da especificação
inicial, nos quais os conceitos não tratadas nessa modelagem primordial serão
especificados e comprovados. Ao final do trabalho pretende-se ter uma modelagem
formal completa do sistema de tempo real FreeRTOS que possa tanto comprovar a
propriedades implementadas pelo sistema como também servir como entrada para
caso de teste do sistema de tempo real.

O formalismo adotado para os futuros refinamentos será o Event B, para que
assim, as características de concorrência presente no FreeRTOS possam ser
devidamente especificadas. Além disso, com a utilização do formalismo Event B,
parte da modelagem inicial feita em B pode ser aproveitada, pois existe uma
semelhança muito grande entre os dois formalismo B.

Contudo, esse trabalho trata-se apenas da inicialização da modelagem do
sistema operacional de tempo real FreeRTOS, sendo assim possível que sejam
feitos vários outros trabalhos em cima dessa especificação inicial.




\bibliography{UFRN-DIMAp-2006-100-RT}



\end{document}

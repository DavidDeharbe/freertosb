THEORY ProofList IS
  _f(1) & _f(2) & _f(5) & _f(23) & _f(45) & taskStartScheduler.1,(_f(46) & _f(26) => _f(14));
  _f(1) & _f(2) & _f(5) & _f(23) & _f(41) & vTaskResume.3,(_f(44) & _f(26) => _f(14));
  _f(1) & _f(2) & _f(5) & _f(23) & _f(41) & vTaskResume.2,(_f(28) => _f(43));
  _f(1) & _f(2) & _f(5) & _f(23) & _f(41) & vTaskResume.1,(_f(28) => _f(42));
  _f(1) & _f(2) & _f(5) & _f(23) & _f(36) & vTaskSuspend.3,(_f(40) & _f(26) => _f(14));
  _f(1) & _f(2) & _f(5) & _f(23) & _f(36) & vTaskSuspend.2,(_f(37) & _f(28) => _f(39));
  _f(1) & _f(2) & _f(5) & _f(23) & _f(36) & vTaskSuspend.1,(_f(37) & _f(28) => _f(38));
  _f(1) & _f(2) & _f(5) & _f(23) & _f(32) & prvIdleTask.2,(_f(35) & _f(26) => _f(14));
  _f(1) & _f(2) & _f(5) & _f(23) & _f(32) & prvIdleTask.1,(_f(33) & _f(28) => _f(34));
  _f(1) & _f(2) & _f(5) & _f(23) & _f(27) & vTaskDelete.3,(_f(31) & _f(26) => _f(14));
  _f(1) & _f(2) & _f(5) & _f(23) & _f(27) & vTaskDelete.2,(_f(28) => _f(30));
  _f(1) & _f(2) & _f(5) & _f(23) & _f(27) & vTaskDelete.1,(_f(28) => _f(29));
  _f(1) & _f(2) & _f(5) & _f(23) & _f(24) & xTaskCreate.1,(_f(25) & _f(26) => _f(14));
  _f(1) & _f(2) & _f(5) & AssertionLemmas.12,(_f(22) & _f(7) => _f(18));
  _f(1) & _f(2) & _f(5) & AssertionLemmas.11,(_f(21) & _f(7) => _f(18));
  _f(1) & _f(2) & _f(5) & AssertionLemmas.10,(_f(20) & _f(7) => _f(18));
  _f(1) & _f(2) & _f(5) & AssertionLemmas.9,(_f(19) & _f(7) => _f(18));
  _f(1) & _f(2) & _f(5) & AssertionLemmas.8,(_f(17) & _f(7) => _f(18));
  _f(1) & _f(2) & _f(5) & AssertionLemmas.7,(_f(15) & _f(7) => _f(16));
  _f(1) & _f(2) & _f(5) & AssertionLemmas.6,(_f(13) & _f(7) => _f(14));
  _f(1) & _f(2) & _f(5) & AssertionLemmas.5,(_f(6) & _f(7) => _f(12));
  _f(1) & _f(2) & _f(5) & AssertionLemmas.4,(_f(6) & _f(7) => _f(11));
  _f(1) & _f(2) & _f(5) & AssertionLemmas.3,(_f(6) & _f(7) => _f(10));
  _f(1) & _f(2) & _f(5) & AssertionLemmas.2,(_f(6) & _f(7) => _f(9));
  _f(1) & _f(2) & _f(5) & AssertionLemmas.1,(_f(6) & _f(7) => _f(8));
  _f(1) & _f(2) & Initialisation.1,(_f(3) => _f(4))
END
&
THEORY Formulas IS
  ("`Seen and used machines properties'" & configMAX_PRIORITIES: INTEGER & 0<=configMAX_PRIORITIES & configTOTAL_HEAP_SIZE: INTEGER & 0<=configTOTAL_HEAP_SIZE & configMINIMAL_STACK_SIZE: INTEGER & 0<=configMINIMAL_STACK_SIZE & INCLUDE_uxTaskPriorityGet: BIT & INCLUDE_vTaskDelete: BIT & INCLUDE_vTaskSuspend: BIT & INCLUDE_xTaskGetSchedulerState: BIT & INCLUDE_vTaskPrioritySet: BIT & INCLUDE_xTaskGetCurrentTaskHandle: BIT & configUSE_PREEMPTION: BIT & configUSE_IDLE_HOOK: BIT & configUSE_TICK_HOOK: BIT & configCPU_CLOCK_HZ: INTEGER & 0<=configCPU_CLOCK_HZ & configTICK_RATE_HZ: INTEGER & 0<=configTICK_RATE_HZ & configMAX_TASK_NAME_LEN: INTEGER & 0<=configMAX_TASK_NAME_LEN & configUSE_TRACE_FACILITY: BIT & configUSE_16_BIT_TICKS: BIT & configIDLE_SHOULD_YIELD: BIT & configUSE_USE_MUTEXES: BIT & configUSE_RECURSIVE_MUTEXES: BIT & configUSE_COUNTING_SEMAPHORES: BIT & configUSE_ALTERNATIVE_API: BIT & configCHECK_FOR_STACK_OVERFLOW: BIT & configQUEUE_REGISTRY_SIZE: BIT & configUSE_CO_ROUTINES: BIT & configMAX_CO_ROUTINE_PRIORITIES: INTEGER & 0<=configMAX_CO_ROUTINE_PRIORITIES & configKERNEL_INTERRUPT_PRIORITY: INTEGER & 0<=configKERNEL_INTERRUPT_PRIORITY & configMAX_SYSCALL_INTERRUPT_PRIORITY: INTEGER & 0<=configMAX_SYSCALL_INTERRUPT_PRIORITY & INCLUDE_vTaskCleanUpResources: BIT & INCLUDE_vTaskDelayUntil: BIT & INCLUDE_vTaskDelay: BIT & BIT = {0}\/{1} & ERROR_DEFINITION = { -5}\/{ -4}\/{ -2}\/{ -1} & pdTRUE: BIT & pdTRUE = 0 & pdFALSE: BIT & pdFALSE = 1 & pdPASS: BIT & pdPASS = 1 & pdFAIL: BIT & pdFAIL = 0 & errQUEUE_EMPTY: BIT & errQUEUE_EMPTY = 0 & errQUEUE_FULL: BIT & errQUEUE_FULL = 0 & errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY: ERROR_DEFINITION & errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY = -1 & errNO_TASK_TO_RUN: ERROR_DEFINITION & errNO_TASK_TO_RUN = -2 & errQUEUE_BLOCKED: ERROR_DEFINITION & errQUEUE_BLOCKED = -4 & errQUEUE_YIELD: ERROR_DEFINITION & errQUEUE_YIELD = -5 & POINTER: FIN(INTEGER) & not(POINTER = {}) & NAME: FIN(INTEGER) & not(NAME = {}) & PARAMETER: FIN(INTEGER) & not(PARAMETER = {}) & "`Component properties'" & PRIORITY = 0..configMAX_PRIORITIES-1 & TASK = struct(Name>>NAME,Priority>>PRIORITY,Task_Code>>TASK_CODE,Stack>>STACK,State>>(1..5)*{TASK_STATE}) & TASK_NULL: TASK & tskIDLE_PRIORITY: PRIORITY & tskIDLE_PRIORITY = 1 & TASK_CODE: FIN(INTEGER) & not(TASK_CODE = {}) & STACK: FIN(INTEGER) & not(STACK = {}) & (1..5)*{TASK_STATE}: FIN(NATURAL*{TASK_STATE}) & not((1..5)*{TASK_STATE} = {}) & (1..3)*{SCHEDULE_STATE}: FIN(NATURAL*{SCHEDULE_STATE}) & not((1..3)*{SCHEDULE_STATE} = {}));
  ("`Seen and used machines assertions'" & ERROR_DEFINITION: POW(INTEGER) & BIT: POW(NATURAL));
  "`Check that the invariant (tasks: POW(TASK)) is established by the initialisation - ref 3.3'";
  ({}: POW(TASK));
  ("`Component invariant'" & tasks: POW(TASK) & !(tk1,tk2).(tk1: tasks & tk2: tasks & tk1'State = 1|->TASK_STATE & tk2'State = 1|->TASK_STATE => tk1 = tk2) & schedule: (1..3)*{SCHEDULE_STATE});
  ("`Local hypotheses'" & tk1: TASK & tk2: TASK & tk1 = tk2);
  "`Check assertion (!(tk1,tk2).(tk1: TASK & tk2: TASK => tk1 = tk2 <=> (tk1'Name = tk2'Name & tk1'Priority = tk2'Priority & tk1'Task_Code = tk2'Task_Code & tk1'Stack = tk2'Stack & tk1'State = tk2'State) & not(tk1 = tk2) <=> (not(tk1'Name/=tk2'Name) or not(tk1'Priority/=tk2'Priority) or not(tk1'Task_Code/=tk2'Task_Code) or not(tk1'Stack/=tk2'Stack) or not(tk1'State/=tk2'State)))) deduction - ref 3.2, 4.2, 5.3'";
  (tk1'Name = tk2'Name);
  (tk1'Priority = tk2'Priority);
  (tk1'Task_Code = tk2'Task_Code);
  (tk1'Stack = tk2'Stack);
  (tk1'State = tk2'State);
  ("`Local hypotheses'" & tk1: TASK & tk2: TASK & tk1'Name = tk2'Name & tk1'Priority = tk2'Priority & tk1'Task_Code = tk2'Task_Code & tk1'Stack = tk2'Stack & tk1'State = tk2'State);
  (tk1 = tk2);
  ("`Local hypotheses'" & tk1: TASK & tk2: TASK & not(tk1 = tk2));
  (tk1'Name = tk2'Name or tk1'Priority = tk2'Priority or tk1'Task_Code = tk2'Task_Code or tk1'Stack = tk2'Stack or tk1'State = tk2'State);
  ("`Local hypotheses'" & tk1: TASK & tk2: TASK & tk1'Name = tk2'Name);
  (not(tk1 = tk2));
  ("`Local hypotheses'" & tk1: TASK & tk2: TASK & tk1'Priority = tk2'Priority);
  ("`Local hypotheses'" & tk1: TASK & tk2: TASK & tk1'Task_Code = tk2'Task_Code);
  ("`Local hypotheses'" & tk1: TASK & tk2: TASK & tk1'Stack = tk2'Stack);
  ("`Local hypotheses'" & tk1: TASK & tk2: TASK & tk1'State = tk2'State);
  ("`Component assertions'" & !(tk1,tk2).(tk1: TASK & tk2: TASK => (tk1 = tk2 => tk1'Name = tk2'Name & tk1'Priority = tk2'Priority & tk1'Task_Code = tk2'Task_Code & tk1'Stack = tk2'Stack & tk1'State = tk2'State) & (tk1'Name = tk2'Name & tk1'Priority = tk2'Priority & tk1'Task_Code = tk2'Task_Code & tk1'Stack = tk2'Stack & tk1'State = tk2'State => tk1 = tk2) & ((not(tk1 = tk2) => tk1'Name = tk2'Name or tk1'Priority = tk2'Priority or tk1'Task_Code = tk2'Task_Code or tk1'Stack = tk2'Stack or tk1'State = tk2'State) & (tk1'Name = tk2'Name or tk1'Priority = tk2'Priority or tk1'Task_Code = tk2'Task_Code or tk1'Stack = tk2'Stack or tk1'State = tk2'State => not(tk1 = tk2)))));
  ("`xTaskCreate preconditions in this component'" & pvTaskCode: TASK_CODE & pcName: NAME & usStackDepth: INTEGER & 0<=usStackDepth & pvParameters: POW(PARAMETER) & uxPriority: PRIORITY);
  ("`Local hypotheses'" & stack: STACK & task_code: TASK_CODE & task: TASK & task = rec(Name>>pcName,Priority>>uxPriority,Task_Code>>task_code,Stack>>stack,State>>(3|->TASK_STATE)) & tk1: tasks\/{task} & tk2: tasks\/{task} & tk1'State = 1|->TASK_STATE & tk2'State = 1|->TASK_STATE);
  "`Check that the invariant (!(tk1,tk2).(tk1: tasks & tk2: tasks & tk1'State = running & tk2'State = running => tk1 = tk2)) is preserved by the operation - ref 3.4'";
  ("`vTaskDelete preconditions in this component'" & INCLUDE_vTaskDelete = 1 & pxTaskToDelete: tasks & not(pxTaskToDelete'State = 5|->TASK_STATE));
  "`Check that the invariant (tasks: POW(TASK)) is preserved by the operation - ref 3.4'";
  (rec(Name>>pxTaskToDelete'Name,Priority>>pxTaskToDelete'Priority,Task_Code>>pxTaskToDelete'Task_Code,Stack>>pxTaskToDelete'Stack,State>>(5|->TASK_STATE)): TASK);
  (tasks-{pxTaskToDelete}: POW(TASK));
  ("`Local hypotheses'" & tk1: tasks-{pxTaskToDelete}\/{rec(Name>>pxTaskToDelete'Name,Priority>>pxTaskToDelete'Priority,Task_Code>>pxTaskToDelete'Task_Code,Stack>>pxTaskToDelete'Stack,State>>(5|->TASK_STATE))} & tk2: tasks-{pxTaskToDelete}\/{rec(Name>>pxTaskToDelete'Name,Priority>>pxTaskToDelete'Priority,Task_Code>>pxTaskToDelete'Task_Code,Stack>>pxTaskToDelete'Stack,State>>(5|->TASK_STATE))} & tk1'State = 1|->TASK_STATE & tk2'State = 1|->TASK_STATE);
  ("`prvIdleTask preconditions in this component'" & pvParameters: POW(PARAMETER));
  ("`Local hypotheses'" & task: tasks & task'State = 5|->TASK_STATE);
  (tasks-{task}: POW(TASK));
  ("`Local hypotheses'" & task: tasks & task'State = 5|->TASK_STATE & tk1: tasks & not(tk1 = task) & tk2: tasks & not(tk2 = task) & tk1'State = 1|->TASK_STATE & tk2'State = 1|->TASK_STATE);
  ("`vTaskSuspend preconditions in this component'" & INCLUDE_vTaskSuspend = 1 & pxTaskToSuspend: tasks);
  ("`Local hypotheses'" & not(pxTaskToSuspend'State = 4|->TASK_STATE));
  (rec(Name>>pxTaskToSuspend'Name,Priority>>pxTaskToSuspend'Priority,Task_Code>>pxTaskToSuspend'Task_Code,Stack>>pxTaskToSuspend'Stack,State>>(4|->TASK_STATE)): TASK);
  (tasks-{pxTaskToSuspend}: POW(TASK));
  ("`Local hypotheses'" & not(pxTaskToSuspend'State = 4|->TASK_STATE) & tk1: tasks-{pxTaskToSuspend}\/{rec(Name>>pxTaskToSuspend'Name,Priority>>pxTaskToSuspend'Priority,Task_Code>>pxTaskToSuspend'Task_Code,Stack>>pxTaskToSuspend'Stack,State>>(4|->TASK_STATE))} & tk2: tasks-{pxTaskToSuspend}\/{rec(Name>>pxTaskToSuspend'Name,Priority>>pxTaskToSuspend'Priority,Task_Code>>pxTaskToSuspend'Task_Code,Stack>>pxTaskToSuspend'Stack,State>>(4|->TASK_STATE))} & tk1'State = 1|->TASK_STATE & tk2'State = 1|->TASK_STATE);
  ("`vTaskResume preconditions in this component'" & INCLUDE_vTaskSuspend = 1 & pxTaskToResume: tasks & pxTaskToResume'State = 4|->TASK_STATE);
  (rec(Name>>pxTaskToResume'Name,Priority>>pxTaskToResume'Priority,Task_Code>>pxTaskToResume'Task_Code,Stack>>pxTaskToResume'Stack,State>>(3|->TASK_STATE)): TASK);
  (tasks-{pxTaskToResume}: POW(TASK));
  ("`Local hypotheses'" & tk1: tasks-{pxTaskToResume}\/{rec(Name>>pxTaskToResume'Name,Priority>>pxTaskToResume'Priority,Task_Code>>pxTaskToResume'Task_Code,Stack>>pxTaskToResume'Stack,State>>(3|->TASK_STATE))} & tk2: tasks-{pxTaskToResume}\/{rec(Name>>pxTaskToResume'Name,Priority>>pxTaskToResume'Priority,Task_Code>>pxTaskToResume'Task_Code,Stack>>pxTaskToResume'Stack,State>>(3|->TASK_STATE))} & tk1'State = 1|->TASK_STATE & tk2'State = 1|->TASK_STATE);
  ("`taskStartScheduler preconditions in this component'" & schedule = 1|->SCHEDULE_STATE);
  ("`Local hypotheses'" & idleTask: TASK & not(idleTask: tasks) & idleTask'State = 3|->TASK_STATE & idleTask'Priority = tskIDLE_PRIORITY & tk1: tasks\/{idleTask} & tk2: tasks\/{idleTask} & tk1'State = 1|->TASK_STATE & tk2'State = 1|->TASK_STATE)
END
&
THEORY EnumerateX IS
  TASK_STATE == {running,blocked,ready,suspended,deleted};
  SCHEDULE_STATE == {taskSCHEDULER_NOT_STARTED,taskSCHEDULER_RUNNING,taskSCHEDULER_SUSPENDED}
END
&
THEORY Version IS
  POVersion(V3.8.3)(CLT == "V3.7.6")(genOPO == KO, local_op == OK)
END

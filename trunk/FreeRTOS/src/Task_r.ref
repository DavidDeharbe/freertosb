/* Task_r

\brief Refinement of Task Core .

Module responsible for specific the features priority in the task concepts.


Author: Stephenson Galvao, David Deharbe
Creation date: Sun Mar 8 2009
Universidade Federal do Rio Grande do Norte
Departamento de Informatica e Matematica Aplicada
Programa de Pos-Graduacao em Sistemas e Computacao
Formal Methods and Languages Laboratory

*/
REFINEMENT
    Task_r
    
REFINES
    Task
    
SEES
    FreeRTOSConfig ,
    Types
    
CONSTANTS
    max_prt,
    schedule_p
    
PROPERTIES
     
    max_prt: PRIORITY * PRIORITY --> PRIORITY &
    max_prt = %(tmp_mprt_ready,t_prt).(tmp_mprt_ready : PRIORITY & t_prt : PRIORITY | max({tmp_mprt_ready,t_prt})) &
    
    /*
    This function is used to make a switch context. Here than return a set of task that are able to became in running 
    in this first case any one of this tasks can became in runnig states, but in future the sequence of task will be 
    implemented
    */
    schedule_p: (FIN(TASK) * (TASK +-> PRIORITY)) +-> FIN(TASK) &
    schedule_p = %(tasks, t_priority).
    (tasks : FIN(TASK) & t_priority : TASK +-> PRIORITY & tasks /= {} & tasks <: dom(t_priority) |
        tasks /\ dom(t_priority|> {max(t_priority[tasks])}))
        
ABSTRACT_VARIABLES
    active,
    tasks ,
    blocked ,
    running ,
    ready ,
    suspended,
    idle,
    pending,
    t_priority
    
INVARIANT
    active : BOOL &
    
    t_priority : TASK +-> PRIORITY & 
    dom(t_priority) = tasks &
    
    (active = TRUE =>
        t_priority(idle) = IDLE_PRIORITY &
        (!(tt).(tt : ready => (t_priority (tt) <= t_priority(running)))) &
        (!(tt).(tt : tasks => (IDLE_PRIORITY <= t_priority(tt)))))
    
ASSERTIONS
    (PRIORITY <: NATURAL);
    
    (active = TRUE => (running : dom(t_priority)));
    
    (active = TRUE => (!(tt).(tt : ready => (t_priority (tt) <= t_priority(running)))));
    
    (!(tasks, t_priority).(tasks : FIN(TASK) & t_priority : TASK +-> PRIORITY & tasks /= {} & tasks <: dom(t_priority) 
            => schedule_p(tasks, t_priority) <: tasks));
    
    (!(tasks, t_priority).(tasks : FIN(TASK) & t_priority : TASK +-> PRIORITY & tasks /= {} & tasks <: dom(t_priority) => 
            !(task).(task : tasks & task : schedule_p(tasks, t_priority) => t_priority(task) = max(t_priority[tasks]))))
    
INITIALISATION
    active := FALSE ||
    tasks := {} ||
    running :: TASK ||
    idle :: TASK ||
    t_priority := {} ||
    blocked , ready , suspended,pending := {},{},{},{}
    
OPERATIONS
    /**	
    \brief Task creation
    
    \do 
    This method create a new task. The task created can have the state ready or running. This choice 
    depend both of the priorities of the tasks in ready state and the priority of the new task created
    and will be implement in future refinement. The parameter priority is declared but not used.
    
    \parameters
    
    priority - The priority of the task
    
    \note 
    The actual function takes the handled as a parameter passed by reference.
    
    **/
    result <-- t_create (priority) =
    BEGIN	
        ANY
            task,
            n_ready,
            n_priority
        WHERE
            task : TASK &
            task /: tasks&
            task/=TASK_NULL&
            
            n_ready<: tasks &
            n_ready= {task} \/ ready&
            
            n_priority:TASK +-> PRIORITY&
            n_priority= t_priority \/ {task|->priority}
            
        THEN     	    
            tasks := n_tasks ||
            t_priority:= n_priority||
            ready := n_ready ||
            
            
            IF active = TRUE THEN
                IF t_priority(running) >= priority THEN /* Scheduler actived and the new task priority gratter then running tasks */
                    running::schedule_p(n_ready,n_priority) /* forcing the switch context */
                END
            ELSE
                IF ready = {} THEN
                    running:=task
                ELSE
                    IF t_priority(running) >= priority THEN
                        running::schedule_p(n_ready,n_priority)
                    END
                END
            END||
            result := task
            
        END                  
    END;
    
    /**
    \brief Delete Task
    
    \do	
    Delete a task managed by FreeRTOS. If the task that will be delete is the current task, a ready 
    task will became the running task. The NULL task can't be deleted. 
    
    \parameters 
    aTask - Task that will be deleted
    
    \question
    can it delete the idle task?
    R - the handle to idle task is not visible for user
    when the task that gonna delete is the unique task in tasks, what do it do?
    R- I don't allow this. The handle for idle task can't be take.
    
    **/
    t_delete (atask)=
    BEGIN
        ANY
            n_priority
        WHERE
            n_priority:TASK +-> PRIORITY&
            n_priority= {atask} <<| t_priority
        THEN
            tasks := tasks - { atask } || 	
            t_priority :=n_priority||
        	IF atask : ready  THEN
            	ANY
                	n_ready
            	WHERE 
               		n_ready<:tasks&
                	n_ready= ready - { atask } 
                THEN
                	ready := n_ready ||
                	IF atask = running	THEN
                    	IF active = TRUE THEN 
                        	running::schedule_p(n_ready,n_priority)
                    	END
                	END            
            	END
        	ELSIF atask : blocked  THEN
            	blocked := blocked - { atask }||
            	pending:=pending-{atask}
        	ELSIF atask : suspended THEN
            	suspended := suspended - { atask }||
            	pending:=pending-{atask}
         	END
        END
    END;
    
        
    /**
    \brief Suspend Task
    
    \do	
    This method suspend the passed task. If the task that will be suspend is 
    the current task, a task with the state ready will choice to be the current task.
    
    \parameters 
    atask- Task that will be suspend
    
    **/
    t_suspend (stask)=
   BEGIN
        IF stask:ready THEN
            ANY
                n_ready
            WHERE
                n_ready <:tasks &
                n_ready = ready - { stask }
            THEN
                ready := n_ready||
                IF running=running THEN
                    running::schedule_p(n_ready,t_priority)
                END
            END
        ELSIF stask : blocked THEN
            blocked := blocked - { stask }
        END ||
        suspended := suspended \/ { stask }
    END;
    
    /**
    \brief	Resume Task
    
    \do	
    This method resume a suspended tasks. The resumed task can go to ready or running state depend 
    the priority of resumed tasks (this choice will be specific in future refinement)
    
    \parameters 
    atask - Task that will be resume
    
    **/
    t_resume(rtask) =
    BEGIN 
        ANY 
            n_ready
        WHERE
            n_ready<:tasks &
            n_ready = ready \/ {rtask}
        THEN
            suspended := suspended - {rtask} ||
            ready:=n_ready||
            IF t_priority(rtask) >= t_priority(running) THEN
                running::schedule_p(n_ready,t_priority)
            END
        END	
    END;
    /**
    \brief	Get Task Priority
    
    \do	
    This method get the priority of the task passed, but here this only return a priority available. 
    It will implement in future refinement.
    
    \parameters 
    atask - Task that will be returned the priority
    
    \returns
    priority - a priority belong of Priority set
    
    **/
    priority <-- t_getPriority(atask)=
    BEGIN
        priority := t_priority(atask)
    END;
    
    /**
    \brief	Get Current Task
    
    \do	
    Return the currently running task
    
    \returns
    result - The currently running task
    
    **/
    result <-- t_getCurrent =
    BEGIN
        result := running
    END;
    
    /**
    \brief	Get Number of Task
    
    \do	
    Get the number of tasks managed by the FreeRTOS
    
    \returns
    numberOfTasks -  number of tasks managed by the FreeRTOS
    
    **/
    result <-- t_getNumberOfTasks =
    BEGIN
        result := card(tasks)
    END;
    
    /**
    \brief	Delay Task
    
    \do	
    Change the state of the current task for the blocked state during the number tick passed. 
    But here it only change the state of task leaving the feature time of block for the next refinement
    
    
    \paramenters
    tick - The tick that the task should be unbloked. Is declared but no used here
    
    **/
    t_delayTask(ticks,task)=
    BEGIN
        ANY
            n_ready
        WHERE
            n_ready <: tasks &
            n_ready = ready-{running}    	    
        THEN   		    
            running::schedule_p(n_ready,t_priority)             
         END||
         blocked := blocked \/ {running}
    END;
    
    /**
    \brief	Start Scheduler
    
    \do	
    Start the scheduler and create the idle task		
    
    \return 
    
    **/
    t_startScheduler = 
    BEGIN
        active := TRUE ||
        blocked, suspended := {}, {} ||
        ANY
            idle_task 
        WHERE
            idle_task : TASK & 
            idle_task /: tasks 
        THEN
            tasks := tasks \/ { idle_task } ||
            t_priority := t_priority \/ { idle_task |-> IDLE_PRIORITY } ||
            idle := idle_task ||
            ANY 
                n_ready
            WHERE
                n_ready <: tasks &
                n_ready = ready\/{idle_task}
            THEN
                ready:= n_ready ||           	        
                running::schedule_p(n_ready,t_priority)
            END
        END
    END;
    
    /**
    \brief	End Scheduler
    
    \do	
    End the task of schuler
    **/
    t_endScheduler =
    BEGIN
        active := FALSE ||
        tasks := {} ||
        t_priority:= {} ||
        blocked , ready , suspended := {},{},{}
    END;
    
    
    /**
    \brief	Resume All
    
    \do	
    Method used for resume the scheduler. It increment the tick with missed ticks and verify the list of 
    blocked tasks to unblock the tasks with expired timers.
    **/
    t_resumeAll(unblocked) = 
    BEGIN
        
        IF  unblocked /= {} or pending /={} THEN
            ANY
                n_ready
            WHERE
                n_ready<:tasks &
                n_ready= ready \/ unblocked\/ pending
                
            THEN
                blocked := blocked - unblocked - pending ||
                suspended := suspended - pending||   
                ready:=n_ready||
                IF t_priority(running) <= max(t_priority[schedule_p(n_ready,t_priority)])  THEN
                    running::schedule_p(n_ready,t_priority)
                END
            END
        END
    END;
    
    /**
    \brief	Remove From Block List
    
    \do
    Unblock the given task
    
    **/
    t_unblock(task)=
    BEGIN
        blocked := blocked - { task } ||
        ANY
            n_ready
        WHERE
            n_ready<:tasks &
            n_ready = ready\/{ task }
        THEN
        	IF t_priority(task) >= t_priority(running) THEN
        	    running :: schedule_p(n_ready,t_priority)
        	END||
        	ready:=n_ready
        END            
    END;
    
/*
SG->DD
Adicionei mais essa operação
falta apenas uma obrigação de prova sobre essa operação
*/
    
    t_setPriority (task, priority)=
    BEGIN
        t_priority(task) := priority ||
        IF task : ready & t_priority(running) <= priority 
        THEN
            running := task ||        
            ready := (ready \/{running})-{task}
        ELSIF task = running & priority < max(t_priority[ready])  THEN
            ANY
                atask
            WHERE
                atask : TASK &
                atask : schedule_p(ready, t_priority)
            THEN
                running := atask ||
                ready := (ready \/ { running }) - { atask }
            END
        END
    END;
    
    
    t_PriorityInherit(xTicksToWait,holderTask)=
    BEGIN
        IF t_priority(running) > t_priority(holderTask) 
        THEN
            t_priority(holderTask):=t_priority(running)
        END 
    END
END

